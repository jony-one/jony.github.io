<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务调研</title>
      <link href="/jony.github.io/7ff3cbdf01d6/"/>
      <url>/jony.github.io/7ff3cbdf01d6/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文档">参考文档</h2><p><a href="https://skyao.io/learning-dapr/">Dapr学习笔记</a><br><a href="http://dapr.site/">Dapr用户文档</a><br><a href="https://dapr.io/">dapr</a></p>]]></content>
      
      
      <categories>
          
          <category> 导航 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microservices </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 无服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量控制：令牌和桶算法</title>
      <link href="/jony.github.io/6ee15c371963/"/>
      <url>/jony.github.io/6ee15c371963/</url>
      
        <content type="html"><![CDATA[<h1>流量控制：令牌和桶算法</h1><p>流量整形的两个关键要素就是<strong>令牌</strong>和<strong>桶</strong></p><p>为了控制流量的进出流量，一种方式是直接哦统计队列中出出队列的报文和字节数，但是为了保证精确性就需要复杂的计算。在流量控制中广泛应用的另一种方式就是令牌桶，令牌桶以一定的速率产生令牌，报文或字节出队时从令牌桶中取令牌，只有取到令牌后才能出队。</p><p>举个例子更加抽象的理解：<br>一群人正排队等待乘坐游乐场的游览车。想象一下现在有一条固定的道路，游览车以固定的速度抵达，每个人都必须等待游览车到达后才能乘坐。游览车和游客就可以抽象为令牌或者报文，这种机制就是速率限制或流量整形，在一个固定的时间段内只有一部分人能乘坐游览车。</p><p>继续上面的比方，设想有大量的游览车正停在车站等待游客乘坐，但现在没有一个游客。如果突然有一大群游客同时过来了（高并发），那么他们都可以马上乘上游览车。在这里，我们就可以将车站类比为桶，一个桶中包含一定数量的令牌，桶中的令牌可以一次性被使用完而不管数据包到达的时间。</p><p>让我们来完成这个比方，游览车以固定的速率抵达车站，如果没人乘坐就会停满车站，即令牌以一定的速率进入桶中，如果令牌一直没被使用那么桶就可以被装满，而如果令牌不断的被使用那么桶就不会满。令牌桶是处理会产生流量突发应用（比如HTTP）的关键思想。</p><p>使用令牌桶过滤器的排队规则（TBF qdisc，Token Bucket Filter）是流量整形的一个经典例子。TBF以<strong>给定的速度</strong>产生令牌，当桶中有令牌时才发送数据，令牌是整流的基本思想。</p><p>在某些情况下，队列中可能无数据包，因此不会立即需要令牌，这些令牌就会被<strong>收集起来</strong>直到队列需要。但无限制的积累令牌可能会<strong>失去流量整形</strong>的意义，所以令牌积累到一定量就会<strong>停止</strong>。由于积累了令牌，当有大量的报文或字节需要出队时就有足够的令牌可用。这种虚拟的令牌被存储在虚拟的桶中，一个桶中能存放多少令牌取决于桶的大小。</p><p>这意味着如果桶的大小设计不合理，在任何时刻桶中都可能充满令牌。<strong>小型的令牌桶适合流量较为稳定的网络，大型的令牌桶适合有较大突发流量的网络</strong>，除非你的目的就是为了限制数据流的突发传输。</p><p>总之，令牌以固定的速度产生，桶中可以积满令牌，这样就可以处理突发流量，使网络流量更为平滑。</p><p>令牌和桶的概念紧密相联，它们被用于TBF(一种无类qdiscs)和HTB（一种分类qdiscs）中。在tcng语言中，二色和三色标识法就是令牌桶的应用。<br>下面参考图看下：<br><img src="/jony.github.io/images/tbf-qdisc.png" alt="Token Bucket Filter"></p><hr><h1>参考连接</h1><p><a href="https://blog.csdn.net/zgangz/article/details/42737871">Linux流量控制指南</a><br><a href="https://tldp.org/HOWTO/html_single/Traffic-Control-HOWTO/">Traffic Control HOWTO</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
            <tag> tc </tag>
            
            <tag> 流量控制 </tag>
            
            <tag> 算法理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eBPF 扩展阅读-BPF Map</title>
      <link href="/jony.github.io/7ba20d0e3fad/"/>
      <url>/jony.github.io/7ba20d0e3fad/</url>
      
        <content type="html"><![CDATA[<h1>eBPF 扩展阅读 - BPF Maps</h1><p>通过向程序传递消息而引起程序行为被调用，这种方式在软件工程中使用广泛。BPF 的功能之一就是内核中运行的代码和加载这些代码的程序可以通过<strong>消息传递</strong>的方式实现实时通信。</p><p>BPF Map 以键/值保存在内核中，可以被任何 BPF 程序访问。<strong>用户空间</strong> 使用文件描述符的方式访问 BPF Map。BPF Map 中可以保存任何类型的数据。本质是是保存的<strong>二进制数据</strong>，所以内核并不关心 BPF Map  保存的内容。</p><h2 id="1-创建-BPF-Maps">1. 创建 BPF Maps</h2><p>创建 BPF Maps 最直接的方法是使用 bpf 系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size )</span></span>;</span><br></pre></td></tr></table></figure><p>cmd是eBPF支持的cmd，分为三类： 操作注入的代码、操作用于通信的map、前两个操作的混合。<br>创建一个新的 Map ：</p><p><strong>第一个参数</strong>：BPF_MAP_CREATE 表示创建一个新的 Map 。调用后将返回与创建 Map 相关的文件描述符。<br><strong>第二个参数</strong>是 Map 的设置。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">__u32 map_type;</span><br><span class="line">__u32 key_size;</span><br><span class="line">__u32 value_size;</span><br><span class="line">__u32 max_entries;</span><br><span class="line">__u32 map_flags;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三个参数</strong>是设置属性的大小。</p><p>实际操作创建一个 Key 和 Value 为无符号整数的哈希表 Map：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">my_map</span> &#123;</span></span><br><span class="line">.map_type = BPF_MAP_TYPE_HASH,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = bpf(BPF_MAP_CREATE, &amp;my_map, <span class="keyword">sizeof</span>(my_map));</span><br></pre></td></tr></table></figure><p>如果系统调用失败，内核将会返回 <code>-1</code>,失败有三种原因，可以通过 <code>errno</code> 来区分你：</p><ul><li>属性无效：内核将 <code>errno</code> 变量设置为 <code>EINVAL</code></li><li>无权操作：内核将 <code>errno</code> 变量设置为 <code>EPERM</code></li><li>内存不足：内核将 <code>errno</code> 变量设置为 <code>ENOMEM</code></li></ul><hr><p>当然内核也包含了一些约定和帮助函数，用于生成和使用 BPF Map。调用这些约定比直接执行系统调用更为常用，因为约定的方式更具有可读性且更易遵循。但是这些约定底层仍然是通过 bpf 系统调用来创建 <code>Map</code>。比如 <code>bpf_create_map</code> 就封装了上述的编写的代码，如下：</p><h2 id="code￼3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = bpf_create_map(BPF_MAP_TYPE_HASH, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">100</span>, BPF_F_NO_PREALLOC);</span><br></pre></td></tr></table></figure></h2><p>当然如果事先知道将要使用的 Map 类型的话，我们也可以预先定义 Map。让程序更易于理解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">&quot;maps&quot;</span>)</span> my_map </span>= &#123;</span><br><span class="line">.map_type = BPF_MAP_TYPE_HASH,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式使用 <code>section</code> 属性来定义 Map，本示例中为 <code>SEC(&quot;maps&quot;)</code>。这个<code>宏</code>告诉内核该结构是 BPF Map ，并告诉内核创建相应的 Map。使用这种方式的创建 Map 如果需要使用与之想关联的文件描述符可以使用如下方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = map_data[<span class="number">0</span>].fd;</span><br></pre></td></tr></table></figure><p>因为内核使用 <code>map_data</code> 全局变量来保存 BPF 程序 Map 信息。这个变量是数组结构，存储的内容是按照程序中指定 Map 的顺序进行排序。<br>初始化完成后，就可以使用它们在<strong>内核和用户空间</strong>之间传递消息。</p><h2 id="使用-Map">使用 Map</h2><p>内核和用户空间之间通信的基础就是编写 BPF 程序。内核和用户空间都可以访问 Map。</p><h3 id="更新-BPF-Map-元素">更新 BPF Map 元素</h3><p>创建 Map 后，就需要使用其保存数据。我们可以使用 <code>bpf_map_update_elem</code> 来实现功能。<br><strong>内核程序</strong>需要从 <code>bpf/bpf_helpers.h</code> 文件加载 <code>bpf_map_update_elem</code> 函数。<br><strong>用户空间程序</strong>则需要从 <code>tools/lib/bpf/bpf.h</code> 文件加载 <code>bpf_map_update_elem</code> 函数。</p><p>因为二者的访问方式不同，<strong>内核程序</strong> 可以直接访问 <code>Map</code> ，而用户空间需要使用<strong>文件描述符</strong>来引用 <code>Map</code> 。而且两者访问 <code>Map</code> 的行为也略有不同。在内核上可以直接访问内存中的 <code>Map</code> ，而且操作也是<strong>原子性</strong>的。但是在<strong>用户控件</strong>中运行的代码需要发送消息到内核，需要先复制值再进行更新 <code>Map</code>，这使得更新操作非<strong>原子性</strong>的。如果更新操作成功就会范围 <code>0</code>，否则返回 <code>-1</code> 错误信息将会写入到全局变量 errno 中。</p><p>**<code>内核</code>**调用 <code>bpf_map_update_elem</code> 函数需要四个参数。</p><ul><li>第一个指向已定义 <code>Map</code> 的指针。</li><li>第二个指向要更新的<strong>键</strong>的指针。</li><li>第三个参数是我们要存入的值</li><li>第四个参数是指定更新 <code>Map</code> 的方式：<ul><li>如果传递 0（常量：BPF_ANY），表示如果元素存在，<strong>内核</strong>将<strong>更新元素</strong>；如果不存在则<strong>创建</strong></li><li>如果传递 1（常量：BPF_NOEXIST），表示仅在元素不存在时，内核<strong>创建元素</strong></li><li>如果传递 2（常量：BPF_EXIST），表示仅在元素存在时，内核<strong>更新元素</strong></li></ul></li></ul><h4 id="示例程序">示例程序</h4><p>在<strong>内核空间</strong>直接访问元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result;</span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// other operator BPF_NOEXSIT and BPF_EXSIT etd;</span></span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_ANY);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Kernel create or update element Success !\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Kernel create or update elem Fail :%d %s\n&quot;</span>, result, stderror(errno) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>用户空间</strong>访问元素需要使用到<strong>文件描述符</strong>，而不是直接使用 <code>Map</code> 的指针，当然<strong>文件描述符</strong>使用全局文件描述<code>map_data[0].fd</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result;</span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">result = bpf_map_update_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value, BPF_ANY);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space create or update element Success !\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space create or update element Fail :%d %s\n&quot;</span>, result, stderror(errno) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取-BPF-Map-元素">读取 BPF Map 元素</h3><p>BPF 根据程序执行的位置提供了<strong>两个不同</strong>的帮助函数来读取 <code>Map</code> 元素，即<strong>内核</strong>与<strong>用户空间</strong>。这两个帮助函数名都为 <code>bpf_map_lookup_elem</code>。与更新帮助函数一样，它们仅在第一个参数上有所不同。第二个参数即为读取的键，第三个参数是指向变量的指针，该变量将保存从 <code>Map</code> 中读取的值。</p><h4 id="示例程序-2">示例程序</h4><p>在<strong>内核空间</strong>访问 <code>BPF Map</code> 中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result;</span><br><span class="line">key = <span class="number">1</span>;</span><br><span class="line">result = bpf_map_lookup_elem(&amp;my_map, &amp;key, &amp;value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Kernel lookup element Success %d!\n&quot;</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Kernel create or update elem Fail :%d %s\n&quot;</span>, result, stderror(errno) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>用户空间</strong>访问 <code>BPF Map</code> 的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result;</span><br><span class="line">key = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">result = bpf_map_lookup_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space lookup element Success %d!\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space lookup element Fail :%d %s\n&quot;</span>, result, stderror(errno) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-BPF-Map-元素">删除 BPF Map 元素</h3><p>下面将要介绍的是<strong>删除</strong>操作。与读取 <code>BPF Map</code> 元素相同， BPF 为我们提供了两个帮助函数来删除，函数名都为 <code>bpf_map_delete_element</code> 。</p><ul><li>第一个参数与之前介绍帮助函数的一样</li><li>第二个参数即为要删除的键的引用</li><li>返回值也与之前的一样，但是情况有所不同，如果存在则返回正常结果，如果不存在则返回负数，并返回 <code>not found</code> 信息。</li></ul><h4 id="示例程序-3">示例程序</h4><p><strong>内核空间</strong>操作删除帮助函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result;</span><br><span class="line">key = <span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(&amp;my_map, &amp;key);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space delete element Success %d!\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space delete element Fail :%d %s\n&quot;</span>, result, stderror(errno) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用户空间</strong>操作删除帮助函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result;</span><br><span class="line">key = <span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(map_data[<span class="number">0</span>].fd, &amp;key);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space delete element Success %d!\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User Space delete element Fail :%d %s\n&quot;</span>, result, stderror(errno) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代-BPF-Map-元素">迭代 BPF Map 元素</h3><p>当然除了 CURD 之外，我们还需要查找指定的 <code>Map</code> 元素。BPF 也提供了此类功能的帮助函数 <code>bpf_map_get_next_key</code> 指令。该指令与之前的指令不同，该指令只能运行与 <code>用户空间</code> 。<br>该指令需要三个参数：</p><ul><li>第一个参数是 <code>Map</code> 的文件描述符</li><li>第二个参数是要查找的 Key</li><li>第三个参数是 <code>Map</code> 中的下一个 Key 即：next_key</li></ul><p>一般情况下获取 <code>key</code> 的内容只需要调用 <code>bpf_map_lookup_elem</code> 即可，但是某些情况下想要获取当前 <code>key</code> 的下一个 <code>next_key</code> 是什么就需要调用这个帮助函数。</p><h4 id="示例代码">示例代码</h4><p>我们打印 <code>Map</code> 中的所有 <code>Key</code> ，只需要设置 <code>next_key</code> 为不存在的 <code>key</code> 即可，当返回值为<strong>负数</strong>时，代表以及遍历了 <code>Map</code> 的全部元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key;</span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The next key in the map is: %s\n&quot;</span>, next_key);</span><br><span class="line">lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们之前存入了Key ：1、2、3、4<br>则将会输出：<br>The next key in the map is: 1<br>The next key in the map is: 2<br>The next key in the map is: 3<br>The next key in the map is: 4</p><p><strong>注意</strong><br>另外需要注意的是。BPF 使用 <code>bpf_map_get_next_key</code> 在遍历 <code>Map</code> 前不复制 <code>Map</code> 的值。如果程序正在遍历 <code>Map</code> 元素，程序的其他代码删除了映射中的元素，当遍历程序尝试查找下一个值是<strong>已经删除的键</strong>时，<code>bpf_map_get_next_key</code> 将重新开始查找，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key;</span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The next key in the map is: %s\n&quot;</span>, next_key);</span><br><span class="line"><span class="keyword">if</span> (next_key == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Deleting key `2`\n&quot;</span>, );</span><br><span class="line">bpf_map_delete_element(map_data[<span class="number">0</span>].fd, &amp;next_key);</span><br><span class="line">&#125;</span><br><span class="line">lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们之前存入了Key ：1、2、3、4、5<br>则将会输出：<br>The next key in the map is: 1<br>The next key in the map is: 2<br>Deleting key <code>2</code><br>The next key in the map is: 1<br>The next key in the map is: 3<br>The next key in the map is: 4<br>The next key in the map is: 5</p><h3 id="查找并删除元素">查找并删除元素</h3><p>内核为 BPF Map 提供了一个在 <code>Map</code> 中查找指定的键并删除元素同时将该元素的值赋予元素的功能 <code>bpf_map_lookup_and_delete_element</code>。当我们使用<strong>队列</strong>和<strong>栈映射</strong>时，这个功能将会派上用场。</p><h4 id="示例代码-2">示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result, it;</span><br><span class="line">key = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (it = <span class="number">0</span>; it &lt; <span class="number">2</span>; ++it)</span><br><span class="line">&#123;</span><br><span class="line">result = bpf_map_lookup_and_delete_element(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Value read from the map: &#x27;%d&#x27;\n&quot;</span>, value);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to read value from the map: %d (%s)\n&quot;</span>, result, stderror(errno) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们尝试两次提取并删除相同的元素。第一次可能执行成功，但是第二次将会失败，并且错误为 <code>not found</code> 。</p><h3 id="并发访问-Map-元素">并发访问 Map 元素</h3><p>既然 <code>Map</code> 是全局共享的，那么就肯定会存在多个应用程序并发访问相同的 <code>Map</code> 。这可能会在 BPF 程序中产生竞争条件，并使得 <code>Map</code> 的行为不可预测。为了防止竞争条件，BPF 引入了 BPF <strong>自旋锁</strong>的概念，可以在操作 <code>Map</code> 映射时对访问的 <code>Map</code> 元素进行锁定，<strong>自旋锁</strong>仅适用于 <code>数组</code>、<code>哈希</code>、<code>cgroup</code> 存储 Map。</p><p><strong>内核</strong>中有两个帮组函数与<strong>自旋锁</strong>一起使用：bpf_spin_lock 锁定，bpf_spin_unlock 解锁。工作原理：<code>使用充当信号的数据结构访问包括信号的元素，当信号锁定后，其他程序无法访问该元素值，直至信号被解除</code>。<br><strong>用户空间</strong>可以使用一个标志来改变锁的状态：<code>BPF_F_LOCK</code>。</p><h4 id="示例代码-3">示例代码</h4><p>使用<strong>自旋锁</strong>，我们需要做的第一件事就是创建要锁定访问的元素，然后为该元素添加信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_spin_lock</span> <span class="title">semaphore</span>;</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要将这个结构保存在 BPF Map 中，并在元素中使用 semaphore 防止对元素不可预测的访问。<br><strong>该元素必须使用 BPF 类型格式（BPF Type Format，BTF）进行注释，以便验证器知道如何解释 BTF</strong>。</p><p>这里我们使用 <code>libbpf</code> 的内核宏来注释这个并发映射，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">&quot;maps&quot;</span>)</span> concurrent_map</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.type = BPF_MAP_TYPE_HASH,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(struct concurrent_element),</span><br><span class="line">.max_entries = <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BPF_ANNOTATE_KV_PAIR(concurrent_map, <span class="keyword">int</span>, struct concurrent_element);</span><br></pre></td></tr></table></figure><p>在 BPF 程序中，我们可以使用这两个锁帮助函数保护这些元素防止竞争条件。Map 元素的信号被锁定，程序就可以安全的修改元素的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_program</span><span class="params">(struct pt_regs *ctx)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> <span class="title">init_value</span> =</span> &#123;&#125;,</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> *<span class="title">read_value</span>,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">bpf_map_create_elem</span>(&amp;<span class="title">concurrent_map</span>, &amp;<span class="title">key</span>, &amp;<span class="title">init_value</span>, <span class="title">BPF_NOEXSIT</span>);</span></span><br><span class="line"></span><br><span class="line">read_value = bpf_map_lookup_elem(&amp;concurrent_map, &amp;key);</span><br><span class="line">bpf_spin_lock(&amp;read_value-&gt;semaphore); <span class="comment">// lock</span></span><br><span class="line">read_value-&gt;count += <span class="number">100</span>; <span class="comment">//原子更新</span></span><br><span class="line">bpf_spin_unlock(&amp;read_value-&gt;semaphore); <span class="comment">// unlock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是在内核空间，对 Map 元素的并发访问进行控制。</p><p>在<strong>用户空间</strong>上，我们可以使用标识 <code>BPF_F_LOCK</code> 保存并发映射的引用。我们可以在 <code>bpf_map_update_elem</code> 和 <code>bpf_map_lookup_elem_flags</code> 两个帮助函数中使用此标志。从而无需担心数据竞争问题。</p><p>到目前为止，BPF 已经支持大于 150 个辅助函数，30 个 BPF Maps。</p><h2 id="参考文档">参考文档</h2><ul><li><a href="https://www.cnblogs.com/zhangzl2013/p/4008838.html">BPF系统调用API v1</a></li><li><a href="https://blog.csdn.net/eydwyz/article/details/107983479">Linux内核功能eBPF入门学习</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. eBPF 应用案例</title>
      <link href="/jony.github.io/99a44d212429/"/>
      <url>/jony.github.io/99a44d212429/</url>
      
        <content type="html"><![CDATA[<h1>tc BPF FAQ</h1><p>本节列出一些经常被问的、与 tc BPF 程序有关的问题。</p><ul><li><p><strong>用 act_bpf 作为 tc action module 怎么样，现在用的还多吗？</strong></p><p>不多。虽然对于 tc BPF 程序来说 cls_bpf 和 act_bpf 有相同的功能 ，但前者更加灵活，因为它是后者的一个超集（superset）。tc 的工作原理是将 tc actions attach 到 tc 分类器。要想实现与 cls_bpf 一样的灵活性，act_bpf 需要 被 attach 到 cls_matchall 分类器。如名字所示，为了将包传递给 attached tc action 去处理，这个分类器会匹配每一个包。相比于工作在 direct-action 模式的 cls_bpf，act_bpf 这种方式会导致较低的包处理性能。如果 act_bpf 用在 cls_bpf or cls_matchall 之外的其他分类器，那性能会更差，这是由 tc 分类器的 操作特性（nature of operation of tc classifiers）决定的。同时，如果分类器 A 未 匹配，那包会传给分类器 B，B 会重新解析这个包以及重复后面的流量，因此这是一个线 性过程，在最坏的情况下需要遍历 N 个分类器才能匹配和（在匹配的分类器上）执行 act_bpf。因此，act_bpf 从未大规模使用过。另外，和 cls_bpf 相比， act_bpf 也没有提供 tc offload 接口。</p></li><li><p><strong>是否推荐在使用 cls_bpf 时选择 direct-action 之外的其他模式?</strong></p><p>不推荐。原因和上面的问题类似，选择其他模式无法应对更加复杂的处理情况。tc BPF 程序本身已经能以一种高效的方式做任何处理，因此除了 direct-action 这个模式 之外，不需要其他的任何东西了。</p></li><li><p><strong>offloaded cls_bpf 和 offloaded XDP 有性能差异吗？</strong></p><p>没有。二者都是由内核内的同一个编译器 JIT 的，这个编译器负责 offload 到智能网 卡以及，并且对二者的加载机制是非常相似的。因此，要在 NIC 上原生执行，BPF 程 序会被翻译成相同的目标指令。</p><p>tc BPF 和 XDP BPF 这两种程序类型有不同的特性集合，因此根据使用场景的不同，你 可以选择 tc BPF 或者是 XDP BPF，例如，二者的在 offload 场景下的辅助函数可能 会有差异。</p></li></ul><hr><h1>tc BPF 使用案例</h1><p>本节列出了 tc BPF 程序的主要使用案例。但要注意，这里列出的并不是全部案例，而且考 虑到 tc BPF 的可编程性和效率，人们很容易对它进行定制化（tailor）然后集成到编排系 统，用来解决特定的问题。XDP 的一些案例可能有重叠，但 tc BPF 和 XDP BPF 大部分情 况下都是互补的，可以单独使用，也可以同时使用，就看哪种情况更适合解决给定的问题了 。</p><ul><li><p><strong>为容器落实策略（Policy enforcement）</strong></p><p>tc BPF 程序适合用来给容器实现安全策略、自定义防火墙或类似的安全工具。在传统方式中，容器隔离是通过网络命名空间时实现的，veth pair 的一端连接到宿主机的初始命 名空间，另一端连接到容器的命名空间。因为 veth pair 的一端移动到了容器的命名空间，而另一端还留在宿主机上（默认命名空间），容器所有的网络流量都需要经过主机端的 veth 设备，因此可以在这个 veth 设备的 tc ingress 和 egress hook 点 attach tc BPF 程序。目标地址是容器的网络流量会经过主机端的 veth 的 tc egress hook，而从容器出来的网络流量会经过主机端的 veth 的 tc ingress hook。</p><p>对于像 veth 这样的虚拟设备，XDP 在这种场景下是不合适的，因为内核在这里只操作 skb，而通用 XDP 有几个限制，导致无法操作克隆的 skb。而克隆 skb 在 TCP/IP 协议栈中用的非常多，目的是持有（hold）准备重传的数据片（data segments），而通 用 XDP hook 在这种情况下回被直接绕过。另外，generic XDP 需要顺序化（linearize ）整个 skb 导致严重的性能下降。相比之下， tc BPF 非常灵活，因为设计中它就是工作在接 收 skb 格式的输入上下文中，因此没有 generic XDP 遇到的那些问题。</p></li><li><p><strong>转发和负载均衡</strong></p><p>转发和负载均衡的使用场景和 XDP 很类似，只是目标更多的是在东西向容器流量而不是 南北向（虽然两者都可以用于东西向或南北向场景）。XDP 只能在 ingress 方向使用， tc BPF 程序还可以在 egress 方向使用，例如，可以在初始命名空间内（宿主机上的 veth 设备上），通过 BPF 对容器的 egress 流量同时做地址转化（NAT）和负载均衡， 整个过程对容器是透明的。由于在内核网络栈的实现中，egress 流量已经是 sk_buff 形式的了，因此很适合 tc BPF 对其进行重写（rewrite）和重定向（redirect）。 使用 bpf_redirect() 辅助函数，BPF 就可以接管转发逻辑，将包推送到另一个网络设 备的 ingress 或 egress 路径上。因此，有了 tc BPF 程序实现的转发网格（ forwarding fabric），网桥设备都可以不用了。</p></li><li><p><strong>流抽样（Flow sampling）、监控</strong></p><p>和 XDP 类似，可以通过高性能无锁 per-CPU 内存映射 perf 环形缓冲区（ring buffer ）实现流抽样（flow sampling）和监控，在这种场景下，BPF 程序能够将自定义数据、 全部或截断的包内容或者二者同时推送到一个用户空间应用。在 tc BPF 程序中这是通过 bpf_skb_event_output() BPF 辅助函数实现的，它和 bpf_xdp_event_output() 有相 同的函数签名和语义。</p><p>考虑到 tc BPF 程序可以同时 attach 到 ingress 和 egress，而 XDP 只能 attach 到 ingress，另外，这两个 hook 都在（通用）网络栈的更低层，这使得可以监控每台节点 的所有双向网络流量。这和 tcpdump 和 Wireshark 使用的 cBPF 比较相关，但是，不 需要克隆 skb，而且因为其可编程性而更加灵活，例如。BPF 能够在内核中完成聚合 ，而不用将所有数据推送到用户空间；也可以对每个放到 ring buffer 的包添加自定义 的 annotations。Cilium 大量使用了后者，对被 drop 的包进一步 annotate，关联到 容器标签以及 drop 的原因（例如因为违反了安全策略），提供了更丰富的信息。</p></li><li><p><strong>包调度器预处理</strong>（Packet scheduler pre-processing）<br>sch_clsact’s egress hook 被 sch_handle_egress() 调用，在获得内核的 qdisc root lock 之前执行，因此 tc BPF 程序可以在包被发送到一个真实的 full blown qdis （例如 sch_htb）之前，用来执行包分类和 mangling 等所有这些高开销工作。 这种 sch_clsact 和后面的发送阶段的真实 qdisc（例如 sch_htb） 之间的交互， 能够减少发送时的锁竞争，因为 sch_clsact 的 egress hook 是在无锁的上下文中执行的。</p></li></ul><p>同时使用 tc BPF 和 XDP BPF 程序的一个具体例子是 Cilium。Cilium 是一个开源软件， 透明地对（K8S 这样的容器编排平台中的）容器之间的网络连接进行安全保护，工作在 L3/L4/L7。Cilium 的核心基于 BPF，用来实现安全策略、负载均衡和监控。</p><hr><p>XDP BPF 在生产环境使用的一个例子是 Facebook 的 SHIV 和 Droplet 基础设施，实现了 它们的 L4 负载均衡和 DDoS 测量。从基于 netfilter 的 IPV（IP Virtual Server）迁移到 XDP BPF 使它们的生产基础设施获得了 10x 的性能提升。这方面 的工作最早在 netdev 2.1 大会上做了分享：</p><ul><li><a href="https://www.netdevconf.org/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf">演讲 Slides</a></li><li><a href="https://youtu.be/YEU2ClcGqts">演讲视频</a></li></ul><p>另一个例子是 Cloudflare 将 XDP 集成到它们的 DDoS 防御流水线中，替换了原来基于 cBPF 加 iptables 的 xt_bpf 模块所做的签名匹配（signature matching）。 基于 iptables 的版本在发生攻击时有严重的性能问题，因此它们考虑了基于用户态、 bypass 内核的一个方案，但这种方案也有自己的一些缺点，并且需要不停轮询（busy poll ）网卡，并且在将某些包重新注入内核协议栈时代价非常高。迁移到 eBPF/XDP 之后，两种 方案的优点都可以利用到，直接在内核中实现了高性能、可编程的包处理过程：</p><ul><li><a href="https://www.netdevconf.org/2.1/slides/apr6/bertin_Netdev-XDP.pdf">演讲 Slides</a></li><li><a href="https://youtu.be/7OuOukmuivg">演讲视频</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. Program_Types</title>
      <link href="/jony.github.io/4b2ecddadcc3/"/>
      <url>/jony.github.io/4b2ecddadcc3/</url>
      
        <content type="html"><![CDATA[<pre><code>XDP 负责宿主机到宿主机之间的负载均衡，进入的流量会被统一拦截和转发TC 负责宿主机到容器之间的流量转发，进入、发出的流量会被统一拦截和转发</code></pre><h1>术语</h1><p>per-packet cost ：每包成本，处理一个网络数据包的成本<br>hairpinning：发卡模式。<a href="https://docs.fortinet.com/document/fortigate/5.4.0/cookbook/105831">hairpin</a><br>skb: <a href="https://blog.csdn.net/shanshanpt/article/details/21024465">sock_buffer</a><br>Spectre:<a href="https://zh.wikipedia.org/wiki/%E5%B9%BD%E7%81%B5%E6%BC%8F%E6%B4%9E">幽灵漏洞</a><br>CPUMAP:<a href="https://xdp-project.net/areas/cpumap.html">BPF CPUMAP映射类型</a><br>BPF Flow Dissector：<a href="https://www.kernel.org/doc/html/v5.1/networking/bpf_flow_dissector.html">flow dissector</a><br><a href="https://en.wikipedia.org/wiki/TCP_offload_engine">offload</a><br>tc层：<a href="https://www.nsnam.org/docs/models/html/traffic-control-layer.html">Traffic Control Layer</a>，2 层之上3层之下，2.5层<br>qdisc:<a href="https://tonydeng.github.io/sdn-handbook/linux/tc.html">qdisc</a></p><h1>3 程序类型</h1><p>写作本文时，一共有 18 种不同的 BPF 程序类型，本节接下来进一步介绍其中两种和 网络相关的类型，即 XDP BPF 程序和 tc BPF 程序。这两种类型的程序在 LLVM、 iproute2 和其他工具中使用的例子已经在前一节“工具链”中介绍过了。本节将关注其架 构、概念和使用案例。</p><hr><h1>3.1 XDP</h1><p>XDP（eXpress Data Path）提供了一个内核态、高性能、可编程 BPF 包处理框架。这个框架在软件中最早可以处理包的位置 <strong>（即网卡驱动收到包的时刻）</strong> 运行 BPF 程序。</p><p>XDP hook 位于网络驱动的快速路径上，XDP 程序直接从接收缓冲区（receive ring）中将 包拿下来，无需执行任何耗时的操作，例如分配 skb 然后将包推送到网络协议栈，或者 将包推送给 <strong><a href="https://jaminzhang.github.io/hardware/NIC-offload-Introduction/"><code>GRO 引擎</code></a></strong> 等等。因此，只要有 CPU 资源，XDP BPF 程序就能够在最早的位置执行处理。</p><ul><li><p>XDP 可以<strong>复用所有上游开发的内核网络驱动、用户空间工具，以及其他一些可用的内核 基础设施</strong>，例如 BPF 辅助函数在调用自身时可以使用系统路由表、socket 等等。</p></li><li><p>因为驻留在内核空间，因此 XDP 在<strong>访问硬件时与内核其他部分有相同的安全模型</strong>。</p></li><li><p><strong>无需跨内核/用户空间边界</strong>，因为正在被处理的包已经在内核中，因此可以灵活地将 其转发到内核内的其他实体，例如容器的命名空间或内核网络栈自身。Meltdown 和 Spectre 漏洞尤其与此相关（Spectre 论文中一个例子就是用 ebpf 实现的，译者注 ）。</p></li><li><p>将包从 XDP 送到内核中非常简单，可以<strong>复用内核</strong>中这个健壮、高效、使用广泛的 TCP/IP 协议栈，而<strong>不是像一些用户态框架</strong>一样需要自己维护一个独立的 TCP/IP 协 议栈。</p></li><li><p>基于 BPF 可以<strong>实现内核的完全可编程</strong>，保持 ABI 的稳定，保持内核的系统调用 ABI <code>“永远不会破坏用户空间的兼容性”</code> 的保证。而且，与内核 模块（modules）方式相比，它还更加安全，这来源于 <strong>BPF 校验器</strong>，它能保证内核操作 的稳定性。</p></li><li><p>XDP 轻松地支持在<code>运行时（runtime）</code>原子地<code>创建（spawn）</code>新程序，而**<code>不会导致任何网络流量中断</code>**，甚至不需要重启内核/系统。</p></li><li><p>XDP 允许对负载进行灵活的结构化，然后集成到内核。例 如，它可以工作在<code>“不停轮询”</code>或<code>“中断驱动”</code>模 式。不需要显式地将专门 CPU 分配给 XDP。没有特殊的硬件需求，它也不依赖 <code>hugepage（大页）</code>。</p></li><li><p>XDP 不需要任何第三方内核模块或许可（licensing）。它是一个长期的架构型解决方案，是 Linux 内核的一个核心组件，而且是由内核社 区开发的。</p></li><li><p>主流发行版中，4.8+ 的内核已经内置并启用了 XDP，并支持主流的 10G 及更高速网络 驱动。</p></li></ul><p>作为一个在驱动中运行 BPF 的框架，XDP 还保证了包是线性放置并且可以匹配到单 个 DMA 页面，这个页面对 BPF 程序来说是可读和可写的。XDP 还提供了额外的 256 字 节 headroom 给 BPF 程序，后者可以利用 <strong><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html"><code>bpf_xdp_adjust_head()</code> </a>辅助函数</strong>  实现自定义 <strong><code>封装头</code></strong> ，或者通过 <strong><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html"><code>bpf_xdp_adjust_meta()</code></a> 在包前面添加自定义元数据</strong>。</p><p>下一节会深入介绍 XDP 操作码，BPF 程序会根据返回的操作码来指导驱动接下来应该对这个包做什么，而且它还使得我们可以原子地替换运行在 XDP 层的程序。XDP 在设计上就是定位于高性能场景的。BPF 允许以“直接包访问”的 方式访问包中的数据，这意味着程序直接将数据的指针放到了寄存器中，然后将内容加载到寄存器，相应地再将内容从寄存器写到包中。</p><p>数据包在 XDP 中的表示形式是 xdp_buff，这也是传递给 BPF 程序的结构体（BPF 上下 文）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xdp_buff</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">void</span> *data_end;</span><br><span class="line">    <span class="keyword">void</span> *data_meta;</span><br><span class="line">    <span class="keyword">void</span> *data_hard_start;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xdp_rxq_info</span> *<span class="title">rxq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>data</code></strong>: 指向页面（page）中包数据的起始位置</li><li><strong><code>data_end</code></strong>:  执行包数据 的结尾位置</li><li><strong><code>data_meta</code></strong>: 开始时指向与 data 相同的位置，<code>bpf_xdp_adjust_meta()</code> 能够将其朝着 <code>data_hard_start</code> 移动</li><li><strong><code>data_hard_start</code></strong>:XDP 支持 headroom，因此 data_hard_start 指向页面中最大可能的 headroom 开始位置<ul><li>即，当对包进行封包（加 header）时，data 会逐渐向 data_hard_start 靠近，这是通过 <code>bpf_xdp_adjust_head()</code> 实现的，该辅助函数还支 持解拆包（去 header）。</li></ul></li><li><strong><code>rxq</code></strong>:指向某些额外的、和每个接收队列相关的元数据：<ul><li>这些元数据是在缓冲区设置时确定的（并不是在 XDP 运行时）。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xdp_rxq_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    u32 queue_index;</span><br><span class="line">    u32 reg_state;</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure><hr><p><strong><code>注：</code></strong> data_meta 开始时指向与 data 相同的位置，bpf_xdp_adjust_meta() 能够将其朝着 <code>data_hard_start</code>移动，这样可以给自定义元数据提供空间，这个空间对内核网络栈是不可见的，但对 tc BPF 程序可见，因为 <strong>tc 需要将它从 XDP 转移到 skb</strong>。 反之亦然，这个辅助函数也可以将 data_meta 移动到离 data_hard_start 比较远的位 置，这样就可以达到删除或缩小这个自定义空间的目的。 <strong>data_meta 还可以单纯用于在尾调用时<code>传递状态</code></strong>，和 tc BPF 程序中用 skb-&gt;cb[] 控制块（control block）类似。</p><p>这样，我们就可以得到这样的结论，对于 struct xdp_buff 中数据包的指针，有： <code>data_hard_start &lt;= data_meta &lt;= data &lt; data_end</code>.</p><p>BPF 程序可以从 netdevice 自身获取 queue_index 以及其他信息，例如 ifindex。</p><hr><h1>BPF 程序返回码</h1><p>XDP BPF 程序执行结束后会返回一个判决结果（verdict），告诉驱动接下来如何处理这个 包。在系统头文件 linux/bpf.h 中列出了所有的判决类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">xdp_action</span> &#123;</span></span><br><span class="line">    XDP_ABORTED = <span class="number">0</span>,</span><br><span class="line">    XDP_DROP,</span><br><span class="line">    XDP_PASS,</span><br><span class="line">    XDP_TX,</span><br><span class="line">    XDP_REDIRECT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>XDP_DROP 表示立即在驱动层将包丢弃。这样可以节省很多资源，对于 DDoS mitigation 或通用目的防火墙程序来说这尤其有用。</p></li><li><p>XDP_PASS 表示允许将这个包送到内核网络栈。同时，当前正在处理这个包的 CPU 会 分配一个 skb，做一些初始化，然后将其送到 GRO 引擎。这是没有 XDP 时默 认的包处理行为是一样的。</p></li><li><p>XDP_TX 是 BPF 程序的一个高效选项，能够在收到包的网卡上直接将包再发送出去。对于实现防火墙+负载均衡的程序来说这非常有用，因为这些部署了 BPF 的节点可以作为一 个 <a href="https://docs.fortinet.com/document/fortigate/5.4.0/cookbook/105831">hairpin</a> （发卡模式，从同一个设备进去再出来）模式的负载均衡器集群，将<code>收到的包</code>在 XDP BPF 程序中<code>重写</code>之后直接推送回去。</p></li><li><p>XDP_REDIRECT 与 XDP_TX 类似，但是<strong>通过另一个网卡</strong>将包发出去。另外， <code>XDP_REDIRECT</code> 还可以将包重定向到一个 BPF cpumap，即，当前执行 XDP 程序的 CPU 可以将这个包交给某个远端 CPU，由后者（某个远端 CPU）将这个包送到更上层的内核栈，当前 CPU 则继续在这个网卡执行接收和处理包的任务。这和 <code>XDP_PASS</code> 类似。但当前 CPU 不用去做将包送到内核协议栈的准备工作（分配 skb，初始化等等），因为这部分开销还是很大的。</p></li><li><p>XDP_ABORTED 表示程序产生异常，其行为和 XDP_DROP，但 XDP_ABORTED 会经过 trace_xdp_exception tracepoint，因此可以通过 tracing 工具来监控这种非正常行为。</p></li></ul><hr><h1>XDP 使用案例</h1><p>本节列出了 XDP 的几种主要使用案例。这里列出的并不全，而且考虑到 XDP 和 BPF 的可 编程性和效率，人们能容易地将它们适配到其他领域。</p><ul><li><p><strong>DDoS 防御、防火墙</strong><br>XDP BPF 的一个基本特性就是用 <code>XDP_DROP</code> 命令驱动将包丢弃，由于这个丢弃的位置 非常早 <strong>（网卡驱动收到包的时刻）</strong> ，因此这种方式可以实现高效的网络策略，平均到每个包的开销非常小（ per-packet cost）。这对于那些需要处理任何形式的 DDoS 攻击的场景来说是非常理 想的，而且由于其通用性，使得它能够在 BPF 内实现任何形式的防火墙策略，开销几乎为零， 例如，作为 standalone 设备（例如通过 XDP_TX 清洗流量）；或者广泛部署在节点上，保护节点的安全（通过 <code>XDP_PASS</code> 或 <code>cpumap XDP_REDIRECT</code> 允许“好流量”经过）。</p><p>Offloaded XDP 将本来就已经很小的 per-packet cost （每包成本）全部下放到网卡以 线速（line-rate）进行处理，从而使这一点更上一层楼。</p></li><li><p><strong>转发和负载均衡</strong><br>XDP 的另一个主要使用场景是包转发和负载均衡，这是通过 <code>XDP_TX</code> 或 <code>XDP_REDIRECT</code> 动作实现的。</p><p>XDP 层运行的 BPF 程序能够 <strong>任意修改（mangle）</strong> 数据包，即使是 BPF 辅助函数都能增加或减少包的 <code>headroom</code>，这样就可以在将包再次发送出去之前，对包进行任何的封包/拆包。</p><p>利用 XDP_TX 能够实现 hairpinned（发卡）模式的负载均衡器，这种均衡器能够 在接收到包的网卡再次将包发送出去，而 <code>XDP_REDIRECT</code> 动作能够将包转发到另一个网卡然后发送出去。</p><p><code>XDP_REDIRECT</code> 返回码还可以和 <a href="https://lwn.net/Articles/736336/">BPF cpumap</a> 一起使用，对那些目标是本机协议栈、 将由 non-XDP 的远端（remote）CPU 处理的包进行负载均衡。</p></li><li><p><strong>栈前（Pre-stack）过滤/处理</strong>：进入协议栈前处理</p><p>除了策略执行，XDP 还可以用于加固内核的网络栈，这是通过 XDP_DROP 实现的。 这意味着，XDP 能够在可能的最早位置丢弃那些与本节点不相关的包，这个过程发生在 内核网络栈看到这些包之前。例如假如我们已经知道某台节点只接受 TCP 流量，那任 何 UDP、SCTP 或其他四层流量都可以在发现后立即丢弃。</p><p>这种方式的好处是包不需要再经过各种实体（例如 GRO 引擎、内核的 <a href="https://www.kernel.org/doc/html/v5.1/networking/bpf_flow_dissector.html">flow dissector</a> 以及其他的模块），就可以判断出是否应该丢弃，因此减少了内核的 受攻击面。正是由于 XDP 的早期处理阶段，这有效地对内核网络栈“假装”这些包根本就没被网络设备看到。</p><p>另外，如果内核接收路径上某个潜在 bug 导致 <a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E4%BA%A1%E4%B9%8BPing">ping of death</a> 之类的场景，那我们能够利用 XDP 立即丢弃这些包，而不用重启内核或任何服务。而且由于能够原子地替换 程序，这种方式甚至都不会导致宿主机的任何流量中断。</p><p>栈前处理的另一个场景是：在内核<strong>分配 skb 之前</strong>，XDP BPF 程序可以对包进行**<code>任意修改</code>**，而且对内核“假装”这个包从网络设备收上来之后就是这样的。对于某些自定义包 修改（mangling）和封装协议的场景来说比较有用，在这些场景下，包在进入 GRO 聚合之前会被修改和解封装，否则 GRO 将无法识别自定义的协议，进而无法执行任何形式的聚合。</p><p>XDP 还能够在包的前面 push 元数据（非包内容的数据）。这些元数据对常规的内核栈是不可见的，但能被 GRO 聚合（匹配元数据），稍后可以和 tc ingress BPF 程序一起处理，tc BPF 中携带了 skb 的某些上下文，例如，设置了某些 skb 字段。</p></li><li><p><strong>流抽样（Flow sampling）和监控</strong></p><p>XDP 还可以用于包监控、抽样或其他的一些网络分析，例如作为流量路径中间节点 的一部分；或运行在终端节点上，和前面提到的场景相结合。对于复杂的包分析，XDP 提供了设施来高效地将网络包（截断的或者是完整的 payload）或自定义元数据 push 到 perf 提供的一个快速、无锁、per-CPU 内存映射缓冲区，或者是一 个用户空间应用。</p><p>这还可以用于流分析和监控，对每个流的初始数据进行分析，一旦确定是正常流量，这个流随 后的流量就会跳过这个监控。感谢 BPF 带来的灵活性，这使得我们可以实现任何形式 的自定义监控或采用。</p></li></ul><hr><h1>XDP 工作模式</h1><p>XDP 有三种工作模式，默认是 native（原生）模式，当讨论 XDP 时通常隐含的都是指这 种模式。</p><ul><li><p><strong>Native XDP</strong><br>默认模式，在这种模式中，XDP BPF 程序直接运行在网络驱动的早期接收路径上（ early receive path）。大部分广泛使用的 10G 及更高速的网卡都已经支持这种模式 。</p></li><li><p><strong>Offloaded XDP</strong><br>在这种模式中，XDP BPF 程序直接 offload 到网卡，而不是在主机的 CPU 上执行。 因此，本来就已经很低的 per-packet 开销完全从主机下放到网卡，能够比运行在 native XDP 模式取得更高的性能。这种 offload 通常由**智能网卡(SmartNIC)**实现，这些网卡有多 线程、多核流处理器（flow processors），一个位于内核中的 JIT 编译器（ in-kernel JIT compiler）将 BPF 翻译成网卡的原生指令。</p><p>支持 offloaded XDP 模式的驱动通常也支持 native XDP 模式，因为 BPF 辅助函数可 能目前还只支持后者。</p></li><li><p><strong>Generic XDP</strong></p><p>对于还没有实现 native 或 offloaded XDP 的驱动，内核提供了一个 generic XDP 选 项，这种模式不需要任何驱动改动，因为相应的 XDP 代码运行在网络栈很后面的一个 位置（a much later point）。</p><p>这种设置主要面向的是用内核的 XDP API 来编写和测试程序的开发者，并且无法达到 前面两种模式能达到的性能。对于在生产环境使用 XDP，推荐要么选择 native 要么选择 offloaded 模式。</p></li></ul><h1>驱动支持</h1><p>由于 BPF 和 XDP 的特性和驱动支持还在快速发展和变化，因此这里的列表只统计到了 4.17 内核支持的 native 和 offloaded XDP 驱动。<br>略…</p><hr><h1>tc (traffic control)</h1><p>除了 XDP 等类型的程序之外，BPF 还可以用于内核数据路径的 tc (traffic control，流量控制)层。</p><p><strong>tc 和 XDP BPF 程序的不同。从高层看，tc BPF 程序和 XDP BPF 程序有三点主要不同：</strong></p><ul><li><p>BPF 的输入上下文（input context）是一个 sk_buff 而不是 xdp_buff。当内核 <strong>协议栈</strong> 收到一个包时（说明包通过了 XDP 层），它会分配一个缓冲区，解析包，并存储包 的元数据。表示这个包的结构体就是 <strong><code>sk_buff</code></strong>。这个结构体会暴露给 BPF 输入上下文， 因此 tc <code>ingress</code> 层的 BPF 程序就可以利用这些（由协议栈提取的）包的元数据。这些元数据很有用，但在包达到 tc 的 hook 点之前，协议栈执行的<strong>缓冲区分配</strong>、<strong>元数据提取</strong>和其他处理等过程也是有<code>开销</code>的。从定义来看，xdp_buff 不需要访问这些元数据，因为 XDP hook 在进入协议栈<strong>之前</strong>就会被调用。这是 XDP 和 tc hook 性能差距的重要原因之一 。</p><p>因此，attach 到 tc BPF hook 的 BPF 程序可以读取 skb 的 mark、pkt_type、 protocol、priority、queue_mapping、napi_id、cb[]、hash、tc_classid 、tc_index、vlan 元数据和 <strong>XDP 层传过来的自定义元数据</strong> 以及其他信息。 tc BPF 的 BPF 上下文中使用了 <strong><a href="https://elixir.bootlin.com/linux/latest/source/include/linux/skbuff.h#L714"><code>struct \_\_sk_buff</code></a></strong>，这个结构体中的所有成员字段都定义在 **<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/bpf.h"><code>linux/bpf.h</code></a>**系统头文件。</p><p>通常来说，<strong><a href="https://elixir.bootlin.com/linux/latest/C/ident/sk_buff"><code>sk_buff</code></a></strong> 和 <strong><a href="https://elixir.bootlin.com/linux/latest/C/ident/xdp_buff"><code>xdp_buff</code></a></strong> 完全不同，二者各有优缺点。例如，sk_buff 的优点就是修改与其关联的元数据（its associated metadata）非常方便，但它包含了大量协议相关的特定信息（例如 GSO 相关的状态），这使得无法仅仅通过重写包数据来**<code>切换协议</code><strong>。这是因为</strong>协议栈是基于元数据处理包的，而不是每次都去读包的内容**。因此，BPF 辅助函数需要<strong>额外的转换</strong>，并且还要正确处理 sk_buff 内部信息。xdp_buff 没有这些问题，因为它所处的阶段非常早，此时内核还没有分配 sk_buff，因此很容易实现各种类型的数据包重写（packet rewrite）。 但是，xdp_buff 的缺点是在它这个阶段进行任意修改的时候，无法利用到 <code>sk_buff</code> 元数据。解决这个问题的方式是从 XDP BPF <strong>传递自定义的元数据</strong>到 tc BPF。这样，根据使用场景的不同，可以同时利用这两者 BPF 程序，以达到互补的效果。</p><p>注：XDP 可以修改数据包来切换协议。比如 TCP 转 UDP ，修改数据包的协议头部分即可。可以理解 XDP 可以工作在三层，tc 工作在三层半</p></li><li><p>tc BPF 程序在数据路径上的 <strong><code>ingress</code></strong> 和 <strong><code>egress</code></strong> 点都可以触发；而 <strong>XDP BPF 程序 只能在 ingress 点触发</strong>。<br>内核两个 hook 点：</p><ol><li>ingress hook sch_handle_ingress()：由 <strong><a href="https://elixir.bootlin.com/linux/latest/source/net/core/dev.c#L5111"><code>\_\_netif_receive_skb_core()</code></a></strong> 触发</li><li>egress hook sch_handle_egress()：由 <strong><a href="https://elixir.bootlin.com/linux/latest/source/net/core/dev.c#L4049"><code>\_\_dev_queue_xmit()</code></a></strong> 触发</li></ol><p>__netif_receive_skb_core() 和 __dev_queue_xmit() 是 data path 的主要接收和 发送函数，不考虑 XDP 的话（XDP 可能会拦截或修改，导致不经过这两个 hook 点）， 每个网络进入或离开系统的网络包都会经过这两个点，从而使得 tc BPF 程序具备完全可观测性。</p></li><li><p>tc BPF 程序不需要驱动做任何改动，因为它们运行在网络栈通用层中的 hook 点。因此，它们可以 attach 到任何类型的网络设备上。</p><h2 id="ingress">ingress</h2><p>这提供了很好的灵活性，但跟运行在原生 XDP 层的程序相比，性能要差一些。然而，tc BPF 程序仍然是内核的通用 data path 做完 GRO 之后、且处理任何协议<strong>之前</strong>最早的 处理点。传统的 iptables 防火墙也是在这里处理的，例如 iptables PREROUTING 或 nftables ingress hook 或其他数据包包处理过程。</p><h2 id="egress">egress</h2><p>类似的，对于 <strong>egress</strong>，tc BPF 程序在将包交给驱动之前的<strong>最晚</strong>的地方（latest point）执 行，这个地方在传统 iptables 防火墙 hook 之后（例如 iptables POSTROUTING）， 但在内核 GSO 引擎之前。</p><p>唯一需要驱动做改动的场景是：将 tc BPF 程序 <code>offload</code> 到网卡。形式通常和 XDP offload 类似，只是特性列表不同，因为二者的 BPF 输入上下文、辅助函数和返回码（ verdict）不同。</p></li></ul><h2 id="cls-bpf-分类器"><a href="https://elixir.bootlin.com/linux/latest/source/net/sched/cls_bpf.c"><code>cls_bpf</code></a> 分类器</h2><p><em>注：<a href="https://netdevconf.info/1.2/slides/oct7/10_nic_viljoen_eBPF_Offload_to_Hardware__cls_bpf_and_XDP_finalised.pdf">eBPF Offload to Hardware:<br><code>cls_bpf</code> and XDP</a></em></p><p>运行在 tc 层的 BPF 程序是从 <code>cls_bpf</code> 分类器开始运行的。虽然 <strong>tc 术语将 <code>BPF连接点</code>描述为<code>“分类器”</code></strong>，但这个词其实有点误导，因为它没有充分的描述了<code>cls_bpf</code>可以 做的事情。attachment point 是一个完全可编程的包处理器，不仅能够读取 skb 元数据和包数据，还可以任意修改这两者，并通过动作判决终止TC处理。因此，<code>cls_bpf</code> 可以认为是一个<strong>管理和执行 tc BPF 程序的独立实体</strong>。</p><p><code>cls_bpf</code> 可以持有一个或多个 tc BPF 程序。Cilium 在部署 <code>cls_bpf</code> 程序时 ，对于一个给定的 hook 点只会附着一个程序，并且用的是 <strong>直接操作（direct-action）</strong> 模式。 典型情况下，在传统 tc 方案中，<code>分类器（classifier ）</code>和<code>操作模块（action modules）</code> 之间是分开的，每个分类器可以 attach 多个 action，当匹配到这个分类器时这些 action 就会执行。<br>在现代世界，在软件 data path 中使用 tc 做复杂包处理时这种模型<strong>扩展性不好</strong>。 考虑到附着到 <code>cls_bpf</code> 的 tc BPF 程序 是完全独立的，因此它们有效地将解析和 action 过程融合到了单个单元（unit）中。得益于 <code>cls_bpf</code> 的 <code>direct-action</code> 模式，它只需要返回 tc action 判决结果，然后立即 终止处理流水线。这使得能够在网络 data path 中实现可扩展可编程的包处理，避免动作的线性迭代。<code>cls_bpf</code> 是 tc 层中唯一支持这种快速路径（fast-path）的一个分类器模块。</p><p>和 XDP BPF 程序类似，tc BPF 程序能在运行时（runtime）通过 <code>cls_bpf</code> 原子地更新， 而不会导致<strong>任何网络流量中断</strong>，也不用重启服务。</p><p><code>cls_bpf</code> 可以附着的 tc ingress 和 egress hook 点都是由一个名为 <code>sch_clsact</code> 的 伪 qdisc 管理的，它是 ingress qdisc 的一个超集（superset），可以无缝替换后 者，因为它既可以管理 ingress tc hook 又可以管理 egress tc hook。对于 <code>\_\_dev_queue_xmit()</code> 内的 tc egress hook，需要注意的是这个 hook 并不是在内核的 qdisc root lock 下执行的。因此，ingress 和 egress hook 都是在快速路径中以无锁（ lockless）方式执行的。不管是 ingress 还是 egress，抢占（preemption ）都被关闭， 并且执行发生在 <code>[RCU](https://zhuanlan.zhihu.com/p/30583695)</code> 读的一侧。</p><p>通常在 egress 的场景下，有很多类型的 qdisc 会 attach 到 netdevice，例如 <code>sch_mq</code>, <code>sch_fq</code>, <code>sch_fq_codel</code> 或者 <code>sch_htb</code>，其中某些是<strong>有分类的 qdiscs</strong>，这些 qdisc 包含<strong>多个子类别</strong>。 因此需要一个对包进行分类的机制，决定将包 <strong>分离（demux）</strong> 到哪里。这个机制是 由调用 <code>tcf_classify()</code> 实现的，这个函数会进一步调用 <code>tc 分类器</code>（如果提供了）。</p><p>在 这种场景下， <code>cls_bpf</code> 也可以被 attach 和使用。这种操作通常发生在 qdisc root lock 下面，因此会面临锁竞争的问题。 <code>sch_clsact</code> qdisc 的 egress hook 点位于<strong>更前面</strong>，没有落入这个锁的范围内，因此完全<strong>独立于</strong>常规 egress qdisc 而执行。</p><p>因此对于 sch_htb 这种场景，<code>sch_clsact</code> qdisc 可以将繁重的数据包分类工作可通过 tc BPF 程序，在 qdisc root lock 之外执行，在这些 tc BPF 程序中设置 <code>skb-&gt;mark</code> 或 <code>skb-&gt;priority</code> ，因此随后 <code>sch_htb</code> 只需要一个简单的映射，而没有原来在 root lock 下面昂贵的包分类开销，还减少了锁竞争。</p><p>在 <code>sch_clsact</code> 结合 <code>cls_bpf</code> 场景下支持 Offloaded tc BPF 程序， 在这种场景下，原来加载到<strong>智能网卡驱动</strong>的 BPF 程序被 JIT，在网卡原生执行。 只有工作在 direct-action 模式的 <code>cls_bpf</code> 程序支持 offload。 <code>cls_bpf</code> 只支持 offload 单个程序，不支持<strong>同时</strong> offload 多个程序。另外，<strong>只有 ingress hook 支持 offloading BPF 程序</strong>。</p><p>一个 <code>cls_bpf</code> 实例内部可以持有多个 tc BPF 程序。如果由多个程序， <code>TC_ACT_UNSPEC</code> 程序返回码就是让继续执行列表中的下一个程序。但这种方式的缺点是： <strong>每个程序都需要解析一遍数据包，性能会下降</strong>。</p><h1>BPF 程序返回码</h1><p>tc ingress 和 egress hook 共享相同的返回码（动作判决），定义在 linux/pkt_cls.h 系统头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_UNSPEC         (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_OK               0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_SHOT             2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_STOLEN           4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TC_ACT_REDIRECT         7</span></span><br></pre></td></tr></table></figure><p>系统头文件中还有一些 <code>TC_ACT_*</code> 动作判决，也用在了这两个 hook 中。但是，这些判决 和上面列出的那几个共享相同的语义。这意味着，从 tc BPF 的角度看， <code>TC_ACT_OK</code> 和 <code>TC_ACT_RECLASSIFY</code> 有相同的语义， <code>TC_ACT_STOLEN</code>, <code>TC_ACT_QUEUED</code> and <code>TC_ACT_TRAP</code> 返回码也是类似的情况。因此， 对于这些情况，我们只描述 <code>TC_ACT_OK</code> 和 <code>TC_ACT_STOLEN</code> 操作码。</p><h2 id="TC-ACT-UNSPEC-和-TC-ACT-OK"><code>TC_ACT_UNSPEC</code> 和 <code>TC_ACT_OK</code></h2><p><code>TC_ACT_UNSPEC</code> 表示“未指定的动作”（unspecified action），在三种情况下会用到：</p><ol><li>attach 了一个 offloaded tc BPF 程序，tc ingress hook 正在运行，被 offload 的 程序的 <code>cls_bpf</code> 表示会返回 <code>TC_ACT_UNSPEC</code></li><li>为了在 <code>cls_bpf</code> 多程序的情况下，继续下一个 tc BPF 程序。这种情况可以和第一种情况中提到的 offloaded tc BPF 程序一起使用，将继续运行在不是 offloaded 下的 tc BPF 程序，并返回 <code>TC_ACT_UNSPEC</code></li><li><code>TC_ACT_UNSPEC</code> 还用于单个程序从场景，只是通知内核继续执行 <code>skb</code> 处理，但不要带 来任何副作用（without additional side-effects）。</li></ol><p>TC_ACT_UNSPEC 在某些方面和 <code>TC_ACT_OK</code> 非常类似，因为二者都是将 <code>skb</code> 向下一个 处理阶段传递，在 <code>ingress</code> 的情况下是传递给内核协议栈的更上层，在 egress 的情况下 是传递给网络设备驱动。<strong>唯一的不同是 <code>TC_ACT_OK</code> <code>基于 tc BPF 程序</code>设置的 classid 来设置 skb-&gt;tc_index</strong>，而 <code>TC_ACT_UNSPEC</code> 是通过 tc BPF 程序之外的 BPF 上下文中的 <code>skb-&gt;tc_classid</code> 设置。</p><h2 id="TC-ACT-SHOT-和-TC-ACT-STOLEN"><code>TC_ACT_SHOT</code> 和 <code>TC_ACT_STOLEN</code></h2><p>这两个返回码指示内核将包丢弃。这两个返回码很相似，只有少数几个区别：</p><ul><li><code>TC_ACT_SHOT</code> 提示内核 <code>skb</code> 是通过 <code>kfree_skb()</code> 释放的，并<strong>返回 <code>NET_XMIT_DROP</code> 给调用方</strong>，作为立即反馈</li><li><code>TC_ACT_STOLEN</code> 通过 consume_skb() 释放 <code>skb</code>，<strong>返回 <code>NET_XMIT_SUCCESS</code> 给上层<code>假装</code>这个包已经被正确发送了</strong></li></ul><h2 id="TC-ACT-REDIRECT">TC_ACT_REDIRECT</h2><p>这个返回码加上 bpf_redirect() 辅助函数，允许重定向一个 <code>skb</code> 到同一个或另一个设备的 <code>ingress</code> 或 <code>egress</code> 路径。能够将包注入另一个设备的 <code>ingress</code> 或 <code>egress</code> 路径使 得基于 BPF 的包转发具备了完全的灵活性。对目标网络设备没有额外的要求，<strong>只要本身是一个网络设备就行了</strong>，在目标设备上不需要运行 <code>cls_bpf</code> 实例或其他限制。</p><hr><h1>文档连接</h1><p><a href="https://www.dazhuanlan.com/2019/12/10/5dee76b007da0/">Linux BPF 3.2、BPF and XDP Reference Guide</a><br><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">[译] Cilium：BPF 和 XDP 参考指南（2019）</a><br><a href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">BPF 辅助函数</a><br><a href="https://man7.org/linux/man-pages/man2/bpf.2.html">BPF man 文档</a><br><a href="https://docs.fortinet.com/document/fortigate/5.4.0/cookbook/105831">Using Hairpinning in a Network</a><br><a href="https://lwn.net/Articles/736336/">BPF cpumap</a><br><a href="https://xdp-project.net/">Top-level XDP project management</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. iproute2</title>
      <link href="/jony.github.io/ada1626fa032/"/>
      <url>/jony.github.io/ada1626fa032/</url>
      
        <content type="html"><![CDATA[<h1>2.3 iproute2</h1><h1>文档连接</h1><p><a href="https://www.dazhuanlan.com/2019/12/10/5dee76b007da0/">Linux BPF 3.2、BPF and XDP Reference Guide</a><br><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">[译] Cilium：BPF 和 XDP 参考指南（2019）</a><br><a href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">BPF 辅助函数</a><br><a href="https://man7.org/linux/man-pages/man2/bpf.2.html">BPF man 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. C BPF 编程规范</title>
      <link href="/jony.github.io/3006e0a225f3/"/>
      <url>/jony.github.io/3006e0a225f3/</url>
      
        <content type="html"><![CDATA[<h1>C BPF 代码注意事项</h1><p><strong>用 C 语言编写 BPF 程序不同于用 C 语言做应用开发，有一些陷阱需要注意。本节列出了 二者的一些不同之处。</strong></p><h2 id="1-所有函数都需要内联（inlined）、不支持函数调用（对于老版本-LLVM）、不支持共享库调用">1. 所有函数都需要内联（inlined）、不支持函数调用（对于老版本 LLVM）、不支持共享库调用</h2><p>BPF 不支持共享库（Shared libraries）。但是，可以将 <strong>常规</strong> 的库代码（library code）放到头文件中，然后在主程序中 include 这些头文件，例如 Cilium 就大量使用了这种方式 （可以查看 bpf/lib/ 文件夹）。另外，也可以 include 其他的一些头文件，例如内核 或其他库中的头文件，复用其中的静态内联函数（static inline functions）或宏/定义（ macros / definitions）。</p><p>内核 4.16+ 和 LLVM 6.0+ 之后已经支持 BPF-to-BPF 函数调用。对于任意给定的程序片段 ，在此之前的版本只能将全部代码编译和内联成一个扁平的 BPF 指令序列（a flat sequence of BPF instructions）。在这种情况下，最佳实践就是为每个库函数都使用一个 像 __inline 一样的注解（annotation ），下面的例子中会看到。推荐使用 always_inline，因为编译器可能会对只注解为 inline 的长函数仍然做 uninline 操 作。</p><p>如果是后者，LLVM 会在 ELF 文件中生成一个重定位项（relocation entry），BPF ELF 加载器（例如 iproute2）无法解析这个重定位项，因此会产生一条错误，因为对加载器 来说只有 BPF maps 是合法的、能够处理的重定位项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME)                  \</span></span><br><span class="line">   __attribute__((section(NAME), used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __inline</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __inline                         \</span></span><br><span class="line">   <span class="keyword">inline</span> __attribute__((always_inline))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_drop</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="2-多个程序可以放在同一-C-文件中的不同-section">2. 多个程序可以放在同一 C 文件中的不同 section</h2><p><strong>BPF C 程序大量使用 section annotations</strong> 。一个 C 文件典型情况下会分为 3 个或更多个 section。BPF ELF 加载器利用这些名字来 <strong>提取</strong> 和 <strong>准备</strong> 相关的信息，以通过 bpf()系 统调用加载程序和 maps。例如，查找创建 map 所需的元数据和 BPF 程序的 license 信息时，iproute2 会分别使用 maps 和 license 作为默认的 section 名字。注意在程序 创建时 license section 也会加载到内核，如果程序使用的是兼容 GPL 的协议，这些信 息就可以启用那些 GPL-only 的辅助函数，例如 bpf_ktime_get_ns() 和 bpf_probe_read() 。</p><p>其余的 section 名字都是和特定的 BPF 程序代码相关的，例如，下面经过修改之后的代码 包含两个程序 section：ingress 和 egress。这个非常简单的示例展示了不同 section （这里是 ingress 和 egress）之间可以共享 BPF map 和常规的静态内联辅助函数（ 例如 account_data()）。</p><hr><h2 id="示例程序">示例程序</h2><p>这里将原来的 xdp-example.c 修改为 tc-example.c，然后用 tc 命令加载，attach 到 一个 netdevice 的 ingress 或 egress hook。该程序对传输的字节进行计数，存储在一 个名为 acc_map 的 BPF map 中，这个 map 有两个槽（slot），分别用于 ingress hook 和 egress hook 的流量统计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt; // 标准 C  文件头</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_cls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iproute2/bpf_elf.h&gt; // 特定 iproute2 头文件，有 struct bpf_elf_map 定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __section(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __inline inline __attribute__((always_inline))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> lock_xadd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lock_xadd(ptr,val) ((void) __sync_fetch_and_add(ptr, val))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BPF_FUNC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_FUNC(NAME, ...) (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联到上面的宏定义，宏展开后 BPF_FUNC_map_lookup_elem，该函数在 iap/linux/bpf.h 中有定义</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> &amp;<span class="title">BPF_FUNC</span><span class="params">(map_lookup_elem, <span class="keyword">void</span> *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maps 放在 section 为了让加载器找到</span></span><br><span class="line"><span class="comment">// struct bpf_elf_map 是特定用于 iproute2 的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_elf_map</span> <span class="title">acc_map</span> __<span class="title">section</span>(&quot;<span class="title">maps</span>&quot;) =</span> &#123; <span class="comment">// 每条记录定义一个该 map</span></span><br><span class="line">        .type           = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .size_key       = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">        .size_value     = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">        .pinning        = PIN_GLOBAL_NS,<span class="comment">// map 固定为BPF伪文件系统。路径 /sys/fs/bpf/tc/globals/acc_map</span></span><br><span class="line">        .max_elem       = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">int</span> <span class="title">account_data</span><span class="params">(struct __sk_buff *skb, <span class="keyword">uint32_t</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> *bytes;</span><br><span class="line">        <span class="comment">// map 传递给辅助函数</span></span><br><span class="line">        bytes = map_lookup_elem(&amp;acc_map, &amp;dir);</span><br><span class="line">        <span class="keyword">if</span> (bytes)&#123;</span><br><span class="line">                <span class="comment">// 这里有锁，原子操作</span></span><br><span class="line">                lock_xadd(bytes, skb-&gt;len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;ingress&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tc_ingress</span><span class="params">(struct __sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> account_data(skb, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;egress&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tc_egress</span><span class="params">(struct __sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> account_data(skb, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>程序说明</h1><p>这个例子还展示了其他一些很有用的东西，在开发过程中要注意。</p><p>首先，include 了内核头文件、标准 C 头文件和一个特定的 iproute2 头文件 iproute2/bpf_elf.h，后者定义了struct bpf_elf_map。iproute2 有一个通用的 BPF ELF 加载器，因此 struct bpf_elf_map的定义对于 XDP 和 tc 类型的程序是完全一样的 。</p><p>其次，程序中每条 struct bpf_elf_map 记录（entry）定义一个 map，这个记录包含了生成一 个（ingress 和 egress 程序需要用到的）map 所需的全部信息（例如 key/value 大 小）。这个结构体的定义必须放在 maps section，这样加载器才能找到它。可以用这个 结构体声明很多名字不同的变量，但这些声明前面必须加上 __section(“maps”) 注解。</p><p>结构体 struct bpf_elf_map 是特定于 iproute2 的。不同的 BPF ELF 加载器有不同 的格式，例如，内核源码树中的 libbpf（主要是 perf 在用）就有一个不同的规范 （结构体定义）。iproute2 保证 struct bpf_elf_map 的后向兼容性。Cilium 采用的 是 iproute2 模型。</p><p>另外，这个例子还展示了 BPF 辅助函数是如何映射到 C 代码以及如何被使用的。这里首先定义了 一个宏 BPF_FUNC，接受一个函数名 NAME 以及其他的任意参数。然后用这个宏声明了一 个 NAME 为 map_lookup_elem 的函数，经过宏展开后会变成 BPF_FUNC_map_lookup_elem 枚举值，后者以辅助函数的形式定义在 uapi/linux/bpf.h 。当随后这个程序被加载到内核时，校验器会检查传入的参数是否是期望的类型，如果是， 就将辅助函数调用重新指向（re-points）某个真正的函数调用。另外， map_lookup_elem() 还展示了 map 是如何传递给 BPF 辅助函数的。这里，maps section 中的 &amp;acc_map 作为第一个参数传递给 map_lookup_elem()。</p><p>由于程序中定义的数组 map （array map）是全局的，因此计数时需要使用原子操作，这里 是使用了 lock_xadd()。LLVM 将 __sync_fetch_and_add() 作为一个内置函数映射到 BPF 原子加指令，即 BPF_STX | <a href="http://lists.infradead.org/pipermail/linux-arm-kernel/2015-November/384376.html">BPF_XADD</a> | BPF_W（for word sizes）。</p><p>另外，struct bpf_elf_map 中的 .pinning 字段初始化为 PIN_GLOBAL_NS，这意味 着 tc 会将这个 map 作为一个节点（node）钉（pin）到 BPF 伪文件系统。默认情况下， 这个变量 acc_map 将被钉到 /sys/fs/bpf/tc/globals/acc_map。</p><ul><li>如果指定的是 <strong><code>PIN_GLOBAL_NS</code></strong>，那 map 会被放到 <code>/sys/fs/bpf/tc/globals/</code>。 <strong>globals</strong> 是一个跨对象文件的全局命名空间。</li><li>如果指定的是 <strong><code>PIN_OBJECT_NS</code></strong>，tc 将会为对象文件创建一个它的**<code>本地目录</code>**（local to the object file）。例如，只要指定了 PIN_OBJECT_NS，不同的 C 文件都可以像上面一样定义各自的 acc_map。在这种情况下，这个 map 会在不同 BPF 程序之间共享。</li><li><strong><code>PIN_NONE</code></strong> 表示 map 不会作为节点（node）钉（pin）到 BPF 文件系统，因此当 tc 退 出时这个 map 就无法从用户空间访问了。同时，这还意味着独立的 tc 命令会创建出独 立的 map 实例，因此后执行的 tc 命令无法用这个 map 名字找到之前被钉住的 map。 在路径 /sys/fs/bpf/tc/globals/acc_map 中，map 名是 acc_map。</li></ul><p>因此，在加载 ingress 程序时，tc 会先查找这个 map 在 BPF 文件系统中是否存在，不 存在就创建一个。创建成功后，map 会被钉（pin）到 BPF 文件系统，因此当 egress 程序通过 tc 加载之后，它就会发现这个 map 存在了，接下来会复用这个 map 而不是再创建一个新的。在 map 存在的情况下，加载器还会确保 map 的属性（properties）是匹配的， 例如 key/value 大小等等。</p><p>就像 tc 可以从同一 map 获取数据一样，第三方应用也可以用 bpf 系统调用中的 BPF_OBJ_GET 命令创建一个指向某个 map 实例的新文件描述符，然后用这个描述 符来查看/更新/删除 map 中的数据。</p><p>通过 clang 编译和 iproute2 加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -Wall -target bpf -c tc-example.c -o tc-example.o</span><br><span class="line"></span><br><span class="line">$ tc qdisc add dev ens32 clsact</span><br><span class="line">$ tc filter add dev ens32 ingress bpf da obj tc-example.o sec ingress</span><br><span class="line">$ tc filter add dev ens32 egress bpf da obj tc-example.o sec egress</span><br><span class="line"></span><br><span class="line">$ tc filter show dev ens32 ingress</span><br><span class="line">filter protocol all pref 49152 bpf</span><br><span class="line">filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action id 1 tag c5f7825e5dac396f</span><br><span class="line"></span><br><span class="line">$ tc filter show dev ens32 egress</span><br><span class="line">filter protocol all pref 49152 bpf</span><br><span class="line">filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action id 2 tag b2fd5adc0f262714</span><br><span class="line"></span><br><span class="line">$ mount | grep bpf</span><br><span class="line">sysfs on /sys/fs/bpf <span class="built_in">type</span> sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)</span><br><span class="line">bpf on /sys/fs/bpf <span class="built_in">type</span> bpf (rw,relatime,mode=0700)</span><br><span class="line"></span><br><span class="line">$ tree /sys/fs/bpf/</span><br><span class="line">/sys/fs/bpf/</span><br><span class="line">+-- ip -&gt; /sys/fs/bpf/tc/</span><br><span class="line">+-- tc</span><br><span class="line">|   +-- globals</span><br><span class="line">|       +-- acc_map</span><br><span class="line">+-- xdp -&gt; /sys/fs/bpf/tc/</span><br><span class="line"></span><br><span class="line">4 directories, 1 file</span><br></pre></td></tr></table></figure><p>以上步骤指向完成后，当包经过 ens32 设备时，BPF map 中的计数器就会递增。</p><hr><h1>3. 不允许全局变量</h1><p>由于在第1点已经提到的原因，BPF不能像普通C程序中经常使用的那样具有全局变量。<br>但是，我们有间接的方式实现全局变量的效果：BPF 程序可以使用一个 <strong><code>BPF_MAP_TYPE_PERCPU_ARRAY</code></strong> 类型的、只有一个槽（slot）的、可以存放任意类型数据（ arbitrary value size）的 BPF map。这可以实现全局变量的效果原因是，<strong>BPF 程序在执行期间不会被内核抢占</strong>，因此可以用单个 map entry 作为一个暂存缓冲区(scratch buffer)使用，存储临时数据，例如扩展 BPF 栈的限制（512 字节）。这种方式在尾调用中也是可以工作的，因为尾调用执行期间也不会被抢占。</p><p>另外，如果要在不同次 BPF 程序执行之间保持状态，使用常规的 BPF map 就可以了。</p><hr><h1>4. 不支持常量字符串或数组（const strings or arrays）</h1><p>BPF C 程序中不允许定义 const 字符串或其他数组，原因和第 1 点及第 3 点一样，即 ，ELF 文件中生成的重定位项（relocation entries）会被加载器拒绝，因为不符合加 载器的 ABI（加载器也无法修复这些重定位项，因为这需要对已经编译好的 BPF 序列进行 大范围的重写）。</p><p>将来 LLVM 可能会检测这种情况，提前将错误抛给用户。现在可以用下面的辅助函数来作为 短期解决方式（work around）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BPF_FUNC</span><span class="params">(trace_printk, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, <span class="keyword">int</span> fmt_size, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> printk</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> printk(fmt, ...)                                      \</span></span><br><span class="line">    (&#123;                                                         \</span><br><span class="line">        <span class="keyword">char</span> ____fmt[] = fmt;                                  \</span><br><span class="line">        trace_printk(____fmt, <span class="keyword">sizeof</span>(____fmt), ##__VA_ARGS__); \</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>有了上面的定义，程序就可以自然地使用这个宏，例如 <code>printk(&quot;skb len:%u\n&quot;, skb-&gt;len);</code>。 输出会写到 trace pipe，用 tc exec bpf dbg 命令可以获取这些打印的消息。</p><p>不过，使用 trace_printk() 辅助函数也有一些不足，因此不建议在生产环境使用。每次 调用这个辅助函数时，常量字符串（例如 “skb len:%u\n”）都需要加载到 BPF 栈，但这 个辅助函数最多只能接受 5 个参数，因此使用这个函数输出信息时只能传递三个参数。</p><p>因此，虽然这个辅助函数对快速调试很有用，但（对于<strong>网络程序</strong>）还是推荐使用 <strong><code>skb_event_output()</code></strong> 或 <strong><code>xdp_event_output()</code></strong> 辅助函数。这两个函数接受从 BPF 程序 传递自定义的结构体类型参数，然后将参数以及可选的包数据（packet sample）放到 perf event ring buffer。这些函数通过一个无锁的、内存映射的、 per-CPU 的 <strong><code>perf ring buffer</code></strong> 传递数据，因此要远快于 <code>trace_printk()</code>。例如，Cilium monitor 利用这些辅助函数实现了一个调试框架，以及 在发现违反网络策略时发出通知等功能。</p><hr><h1>5. 使用 LLVM 内置的函数做内存操作</h1><p>因为 BPF 程序除了调用 BPF 辅助函数之外无法执行任何函数调用，因此常规的库代码必须 实现为内联函数。另外，LLVM 也提供了一些可以用于特定大小（这里是 n）的内置函数 ，这些函数永远都会被内联：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> memset</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> memset(dest, chr, n)   __builtin_memset((dest), (chr), (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> memcpy</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> memcpy(dest, src, n)   __builtin_memcpy((dest), (src), (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> memmove</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> memmove(dest, src, n)  __builtin_memmove((dest), (src), (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>LLVM 后端中的某个问题会导致内置的 memcmp() 有某些边界场景下无法内联，因此在这 个问题解决之前不推荐使用这个函数。</p><h1>6. （目前还）不支持循环</h1><p>内核中的 BPF 校验器除了对其他的控制流进行图验证（graph validation）之外，还会对 所有程序路径执行深度优先搜索（depth first search），确保其中不存在循环。这样做的 目的是确保程序永远会结束。</p><p>但可以使用 <code>#pragma unroll</code> 指令实现<strong>常量的、不超过一定上限的<code>循环</code></strong>。下面是一个例子 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> unroll</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IPV6_MAX_HEADERS; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (nh) &#123;</span><br><span class="line">        <span class="keyword">case</span> NEXTHDR_NONE:</span><br><span class="line">            <span class="keyword">return</span> DROP_INVALID_EXTHDR;</span><br><span class="line">        <span class="keyword">case</span> NEXTHDR_FRAGMENT:</span><br><span class="line">            <span class="keyword">return</span> DROP_FRAG_NOSUPPORT;</span><br><span class="line">        <span class="keyword">case</span> NEXTHDR_HOP:</span><br><span class="line">        <span class="keyword">case</span> NEXTHDR_ROUTING:</span><br><span class="line">        <span class="keyword">case</span> NEXTHDR_AUTH:</span><br><span class="line">        <span class="keyword">case</span> NEXTHDR_DEST:</span><br><span class="line">            <span class="keyword">if</span> (skb_load_bytes(skb, l3_off + len, &amp;opthdr, <span class="keyword">sizeof</span>(opthdr)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> DROP_INVALID;</span><br><span class="line"></span><br><span class="line">            nh = opthdr.nexthdr;</span><br><span class="line">            <span class="keyword">if</span> (nh == NEXTHDR_AUTH)</span><br><span class="line">                len += ipv6_authlen(&amp;opthdr);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                len += ipv6_optlen(&amp;opthdr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *nexthdr = nh;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>另外一种实现循环的方式是：用一个 BPF_MAP_TYPE_PERCPU_ARRAY map 作为本地 scratch space（暂存存储空间），然后用尾调用的方式调用函数自身。虽然这种方式更加动态，但目前 最大只支持 32 层嵌套调用。</p><p>将来 BPF 可能会提供一些更加原生、但有一定限制的循环。</p><hr><h2 id="7-尾调用的用途">7. 尾调用的用途</h2><p>尾调用能够从一个程序调到另一个程序，提供了在运行时（runtime）原子地改变程序行 为的灵活性。为了选择要跳转到哪个程序，尾调用使用了程序数组 map（ <code>BPF_MAP_TYPE_PROG_ARRAY</code>），将 map 及其索引（index）传递给将要跳转到的程序。跳 转动作一旦完成，就没有办法返回到原来的程序；但如果给定的 map 索引中没有程序（无 法跳转），执行会继续在原来的程序中执行。</p><p>例如，可以用尾调用实现解析器的不同阶段，可以在运行时（runtime）更新这些阶段的新 解析特性。</p><p>尾调用的另一个用处是事件通知，例如，Cilium 可以在运行时（runtime）开启或关闭<strong>丢包</strong>的通知（packet drop notifications），其中对 skb_event_output() 的调用就是发生在被尾调用的程序中。因此，在常规情况下，执行的永远是从上到下的路径（ fall-through path），当某个程序被加入到相关的 map 索引之后，程序就会解析元数据， 触发向用户空间守护进程（user space daemon）发送事件通知。</p><p>程序数组 map 非常灵活， map 中每个索引对应的程序可以实现各自的动作（actions）。 例如，连接到 tc 或 XDP 的 root 程序执行初始的、跳转到程序数组 map 中索引为 0 的程序，然后执行流量抽样（traffic sampling），然后跳转到索引为 1 的程序，在那个 程序中应用防火墙策略，然后就可以决定是丢包还是将其送到索引为 2 的程序中继续处理，在后者中，可能可能会被 mangle 然后再次通过某个接口发送出去。在程序数据 map 之中是可以随意跳转的。当达到尾调用的最大调用深度时，内核最终会执行 fall-through path。</p><p>一个使用尾调用的最小程序示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __stringify</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __stringify(X)   #X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section_tail</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section_tail(ID, KEY) __section(__stringify(ID) <span class="meta-string">&quot;/&quot;</span> __stringify(KEY))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BPF_FUNC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> BPF_FUNC(NAME, ...) (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_MAP_ID   1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BPF_FUNC</span><span class="params">(tail_call, struct __sk_buff *skb, <span class="keyword">void</span> *<span class="built_in">map</span>, <span class="keyword">uint32_t</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_elf_map</span> <span class="title">jmp_map</span> __<span class="title">section</span>(&quot;<span class="title">maps</span>&quot;) =</span> &#123;</span><br><span class="line">    .type           = BPF_MAP_TYPE_PROG_ARRAY,</span><br><span class="line">    .id             = BPF_JMP_MAP_ID,</span><br><span class="line">    .size_key       = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">    .size_value     = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">    .pinning        = PIN_GLOBAL_NS,</span><br><span class="line">    .max_elem       = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__section_tail(JMP_MAP_ID, <span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">looper</span><span class="params">(struct __sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;skb cb: %u\n&quot;</span>, skb-&gt;cb[<span class="number">0</span>]++);</span><br><span class="line">    tail_call(skb, &amp;jmp_map, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">entry</span><span class="params">(struct __sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    skb-&gt;cb[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    tail_call(skb, &amp;jmp_map, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>加载这个示例程序时，tc 会创建其中的程序数组（jmp_map 变量），并将其固定到 BPF 文件系统中全局命名空间下名为的 jump_map 位置。而且，iproute2 中的 BPF ELF 加载器也会识别出标记为 __section_tail() 的 section。 jmp_map 的 id 字段会 跟__section_tail() 中的 id 字段（这里初始化为常量 <code>JMP_MAP_ID</code>）做匹配，因此程 序能加载到用户指定的索引（位置），在上面的例子中这个索引是 0。然后，所有的尾调用 section 将会被 iproute2 加载器处理，关联到 map 中。这个机制并不是 tc 特有的， iproute2 支持的其他 BPF 程序类型（例如 XDP、lwt）也适用。</p><p>生成的 elf 包含 section headers，描述 map id 和 map 内的条目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-objdump -S --no-show-raw-insn prog_array.o | less</span><br><span class="line">prog_array.o:   file format ELF64-BPF</span><br><span class="line"></span><br><span class="line">Disassembly of section 1/0:</span><br><span class="line">looper:</span><br><span class="line">       0:       r6 = r1</span><br><span class="line">       1:       r2 = *(u32 *)(r6 + 48)</span><br><span class="line">       2:       r1 = r2</span><br><span class="line">       3:       r1 += 1</span><br><span class="line">       4:       *(u32 *)(r6 + 48) = r1</span><br><span class="line">       5:       r1 = 0 ll</span><br><span class="line">       7:       call -1</span><br><span class="line">       8:       r1 = r6</span><br><span class="line">       9:       r2 = 0 ll</span><br><span class="line">      11:       r3 = 0</span><br><span class="line">      12:       call 12</span><br><span class="line">      13:       r0 = 0</span><br><span class="line">      14:       <span class="built_in">exit</span></span><br><span class="line">Disassembly of section prog:</span><br><span class="line">entry:</span><br><span class="line">       0:       r2 = 0</span><br><span class="line">       1:       *(u32 *)(r1 + 48) = r2</span><br><span class="line">       2:       r2 = 0 ll</span><br><span class="line">       4:       r3 = 0</span><br><span class="line">       5:       call 12</span><br><span class="line">       6:       r0 = 0</span><br><span class="line">       7:       exi</span><br></pre></td></tr></table></figure><p>在这个例子中，section 1/0 表示 looper() 函数位于 map 1 中，在 map 1 内的 位置是 0。</p><p>被固定住的 map 可以被用户空间应用（例如 Cilium daemon）读取，也可以被 tc 本身读取，因为 tc 可能会用新的程序替换原来的程序，此时可能需要读取 map 内容。 更新是原子的。</p><p><strong>tc 执行尾调用 map 更新（tail call map updates）的例子：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tc <span class="built_in">exec</span> bpf graft m:globals/jmp_map key 0 obj new.o sec foo</span><br></pre></td></tr></table></figure><p>如果 iproute2 需要更新被固定的程序数组，可以使用 graft 命令。上面的 例子中指向的是 globals/jmp_map，那 tc 将会用一个新程序更新位于 index/key 为 0 的 map， 这个新程序位于对象文件 new.o 中的 foo section。</p><hr><h2 id="8-BPF-最大栈空间-512-字节">8. BPF 最大栈空间 512 字节</h2><p>BPF 程序的最大栈空间是 512 字节，在使用 C 语言实现 BPF 程序时需要考虑到这一点。 但正如在第 3 点中提到的，可以通过一个只有一条记录（single entry）的 BPF_MAP_TYPE_PERCPU_ARRAY map 来绕过这限制，增大 （暂存空间）scratch buffer 空间。</p><hr><h2 id="9-尝试使用-BPF-内联汇编">9. 尝试使用 BPF 内联汇编</h2><p>LLVM 6.0 以后支持 BPF 内联汇编，在某些场景下可能会用到。下面这个玩具示例程序（ 没有实际意义）展示了一个 64 位原子加操作。<br>由于文档不足，要获取更多信息和例子，目前可能只能参考 LLVM 源码中的 <code>lib/Target/BPF/BPFInstrInfo.td</code> 以及 <code>test/CodeGen/BPF/</code>。测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME)                  \</span></span><br><span class="line">   __attribute__((section(NAME), used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_test</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u64 a = <span class="number">2</span>, b = <span class="number">3</span>, *c = &amp;a;</span><br><span class="line">    <span class="comment">/* just a toy xadd example to show the syntax */</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock *(u64 *)(%0+0) += %1&quot;</span> : <span class="string">&quot;=r&quot;</span>(c) : <span class="string">&quot;r&quot;</span>(b), <span class="string">&quot;0&quot;</span>(c))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面的程序会被编译成下面的 BPF 指令序列：</p><h2 id="code￼10"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Verifier analysis:</span><br><span class="line"></span><br><span class="line">0: (b7) r1 = 2</span><br><span class="line">1: (7b) *(u64 *)(r10 -8) = r1</span><br><span class="line">2: (b7) r1 = 3</span><br><span class="line">3: (bf) r2 = r10</span><br><span class="line">4: (07) r2 += -8</span><br><span class="line">5: (db) lock *(u64 *)(r2 +0) += r1</span><br><span class="line">6: (79) r0 = *(u64 *)(r10 -8)</span><br><span class="line">7: (95) <span class="built_in">exit</span></span><br><span class="line">processed 8 insns (<span class="built_in">limit</span> 131072), stack depth 8</span><br></pre></td></tr></table></figure></h2><h2 id="10-用-pragma-pack-禁止结构体填充（struct-padding）">10. 用 #pragma pack 禁止结构体填充（struct padding）</h2><p>现代编译器默认会对数据结构进行 <strong>内存对齐（align）</strong>，以实现更加高效的访问。结构 体成员会被对齐到数倍于其自身大小的内存位置，不足的部分会进行填充（padding），因 此结构体最终的大小可能会比预想中大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">called_info</span> &#123;</span></span><br><span class="line">    u64 start;  <span class="comment">// 8-byte</span></span><br><span class="line">    u64 end;    <span class="comment">// 8-byte</span></span><br><span class="line">    u32 sector; <span class="comment">// 4-byte</span></span><br><span class="line">&#125;; <span class="comment">// size of 20-byte ?</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of %d-byte\n&quot;</span>, <span class="keyword">sizeof</span>(struct called_info)); <span class="comment">// size of 24-byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际编译后的 struct called_info</span></span><br><span class="line"><span class="comment">// 0x0(0)                   0x8(8)</span></span><br><span class="line"><span class="comment">//  ↓________________________↓</span></span><br><span class="line"><span class="comment">//  |        start (8)       |</span></span><br><span class="line"><span class="comment">//  |________________________|</span></span><br><span class="line"><span class="comment">//  |         end  (8)       |</span></span><br><span class="line"><span class="comment">//  |________________________|</span></span><br><span class="line"><span class="comment">//  |  sector(4) |  PADDING  | &lt;= 地址 8 位对齐</span></span><br><span class="line"><span class="comment">//  |____________|___________|     会填充 4-byte.</span></span><br></pre></td></tr></table></figure><p>内核中的 BPF 校验器会检查栈边界（stack boundary），BPF 程序不会访问栈边界外的空 间，或者是未初始化的栈空间。如果<strong>将结构体中<code>填充</code>出来的内存区域作为一个 map 值进行访问</strong>，那调用 bpf_prog_load() 时就会报 invalid indirect read from stack 错误。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">called_info</span> &#123;</span></span><br><span class="line">    u64 start;</span><br><span class="line">    u64 end;</span><br><span class="line">    u32 sector;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">&quot;maps&quot;</span>)</span> called_info_map </span>= &#123;</span><br><span class="line">    .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(<span class="keyword">long</span>),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(struct called_info),</span><br><span class="line">    .max_entries = <span class="number">4096</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;kprobe/submit_bio&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">submit_bio_entry</span><span class="params">(struct pt_regs *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fmt[] = <span class="string">&quot;submit_bio(bio=0x%lx) called: %llu\n&quot;</span>;</span><br><span class="line">    u64 start_time = bpf_ktime_get_ns();</span><br><span class="line">    <span class="keyword">long</span> bio_ptr = PT_REGS_PARM1(ctx);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">called_info</span> <span class="title">called_info</span> =</span> &#123;</span><br><span class="line">            .start = start_time,</span><br><span class="line">            .end = <span class="number">0</span>,</span><br><span class="line">            .bi_sector = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bpf_map_update_elem(&amp;called_info_map, &amp;bio_ptr, &amp;called_info, BPF_ANY);</span><br><span class="line">    bpf_trace_printk(fmt, <span class="keyword">sizeof</span>(fmt), bio_ptr, start_time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On bpf_load_program</span></span><br><span class="line">bpf_load_program() err=<span class="number">13</span></span><br><span class="line"><span class="number">0</span>: (bf) r6 = r1</span><br><span class="line">...</span><br><span class="line"><span class="number">19</span>: (b7) r1 = <span class="number">0</span></span><br><span class="line"><span class="number">20</span>: (<span class="number">7b</span>) *(u64 *)(r10 <span class="number">-72</span>) = r1</span><br><span class="line"><span class="number">21</span>: (<span class="number">7b</span>) *(u64 *)(r10 <span class="number">-80</span>) = r7</span><br><span class="line"><span class="number">22</span>: (<span class="number">63</span>) *(u32 *)(r10 <span class="number">-64</span>) = r1</span><br><span class="line">...</span><br><span class="line"><span class="number">30</span>: (<span class="number">85</span>) call bpf_map_update_elem#<span class="number">2</span></span><br><span class="line">invalid indirect read from <span class="built_in">stack</span> off <span class="number">-80</span>+<span class="number">20</span> size <span class="number">24</span></span><br></pre></td></tr></table></figure><p>在 bpf_prog_load() 中会调用 BPF 校验器的 bpf_check() 函数，后者会调用 check_func_arg() -&gt; check_stack_boundary() 来检查栈边界。从上面的错误可以看出 ，struct called_info 被编译成 24 字节，错误信息提示从 +20 位置读取数据是“非 法的间接读取”（invalid indirect read）。从我们更前面给出的内存布局图中可以看到， 地址 0x14(20) 是填充（PADDING ）开始的地方。这里再次画出内存布局图以方便对比：</p><pre><code>// Actual compiled composition of struct called_info// 0x10(16)    0x14(20)    0x18(24)//  ↓____________↓___________↓//  |  sector(4) |  PADDING  | &lt;= address aligned to 8//  |____________|___________|     with 4-byte PADDING.</code></pre><p><code>check_stack_boundary()</code> 会遍历每一个从开始指针出发的 <code>access_size (24)</code> 字节， 确保它们位于栈边界内部，并且栈内的所有元素都初始化了。因此填充的部分是不允许使用 的，所以报了 “invalid indirect read from stack” 错误。要避免这种错误，需要将结 构体中的填充去掉。这是通过 <code>#pragma pack(n)</code> 原语实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">called_info</span> &#123;</span></span><br><span class="line">    u64 start;  <span class="comment">// 8-byte</span></span><br><span class="line">    u64 end;    <span class="comment">// 8-byte</span></span><br><span class="line">    u32 sector; <span class="comment">// 4-byte</span></span><br><span class="line">&#125;; <span class="comment">// size of 20-byte ?</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of %d-byte\n&quot;</span>, <span class="keyword">sizeof</span>(struct called_info)); <span class="comment">// size of 20-byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Actual compiled composition of packed struct called_info</span></span><br><span class="line"><span class="comment">// 0x0(0)                   0x8(8)</span></span><br><span class="line"><span class="comment">//  ↓________________________↓</span></span><br><span class="line"><span class="comment">//  |        start (8)       |</span></span><br><span class="line"><span class="comment">//  |________________________|</span></span><br><span class="line"><span class="comment">//  |         end  (8)       |</span></span><br><span class="line"><span class="comment">//  |________________________|</span></span><br><span class="line"><span class="comment">//  |  sector(4) |             &lt;= address aligned to 4</span></span><br><span class="line"><span class="comment">//  |____________|                 with no PADDING.</span></span><br></pre></td></tr></table></figure><p>在 struct called_info 前面加上 #pragma pack(4) 之后，编译器会以 4 字节为单位 进行对齐。上面的图可以看到，这个结构体现在已经变成 20 字节大小，没有填充了。</p><p>但是，去掉填充也是有弊端的。例如，编译器产生的代码没有原来优化的好。去掉填充之后 ，处理器访问结构体时触发的是非对齐访问（unaligned access），可能会导致性能下降。 并且，某些架构上的校验器可能会直接拒绝非对齐访问。</p><p>不过，我们也有一种方式可以避免产生自动填充：手动填充。我们简单地在结构体中加入一 个 <code>u32 pad </code>成员来显式填充，这样既<strong>避免了自动填充</strong>的问题，又<strong>解决了非对齐访问</strong>的问题。</p><h2 id="code￼14"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">called_info</span> &#123;</span></span><br><span class="line">    u64 start;  <span class="comment">// 8-byte</span></span><br><span class="line">    u64 end;    <span class="comment">// 8-byte</span></span><br><span class="line">    u32 sector; <span class="comment">// 4-byte</span></span><br><span class="line">    u32 pad;    <span class="comment">// 4-byte</span></span><br><span class="line">&#125;; <span class="comment">// size of 24-byte ?</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of %d-byte\n&quot;</span>, <span class="keyword">sizeof</span>(struct called_info)); <span class="comment">// size of 24-byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Actual compiled composition of struct called_info with explicit padding</span></span><br><span class="line"><span class="comment">// 0x0(0)                   0x8(8)</span></span><br><span class="line"><span class="comment">//  ↓________________________↓</span></span><br><span class="line"><span class="comment">//  |        start (8)       |</span></span><br><span class="line"><span class="comment">//  |________________________|</span></span><br><span class="line"><span class="comment">//  |         end  (8)       |</span></span><br><span class="line"><span class="comment">//  |________________________|</span></span><br><span class="line"><span class="comment">//  |  sector(4) |  pad (4)  | &lt;= address aligned to 8</span></span><br><span class="line"><span class="comment">//  |____________|___________|     with explicit PADDING.</span></span><br></pre></td></tr></table></figure></h2><h2 id="11-通过未验证的引用（invalidated-references）访问包数据">11. 通过未验证的引用（invalidated references）访问包数据</h2><p>某些网络相关的 BPF 辅助函数，例如 <code>bpf_skb_store_bytes</code>，可能会修改包的大小。校验器无法跟踪这类改动，因此它会将所有之前对包数据的引用都视为过期的（未验证的） 。因此，为避免程序被校验器拒绝，在访问数据之外需要先更新相应的引用。<br>来看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip4</span> =</span> (struct iphdr *) skb-&gt;data + ETH_HLEN;</span><br><span class="line"></span><br><span class="line">skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &amp;new_saddr, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip4-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验器会拒绝这段代码，因为它认为在 <code>skb_store_bytes</code> 执行之后，引用 <code>ip4-&gt;protocol</code> 是未验证的（invalidated）:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">R1=pkt_end(id=<span class="number">0</span>,off=<span class="number">0</span>,imm=<span class="number">0</span>) R2=pkt(id=<span class="number">0</span>,off=<span class="number">34</span>,r=<span class="number">34</span>,imm=<span class="number">0</span>) R3=inv0</span><br><span class="line">R6=ctx(id=<span class="number">0</span>,off=<span class="number">0</span>,imm=<span class="number">0</span>) R7=inv(id=<span class="number">0</span>,umax_value=<span class="number">4294967295</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff</span>))</span><br><span class="line">R8=inv4294967162 R9=pkt(id=<span class="number">0</span>,off=<span class="number">0</span>,r=<span class="number">34</span>,imm=<span class="number">0</span>) R10=fp0,call_<span class="number">-1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">18</span>: (<span class="number">85</span>) call bpf_skb_store_bytes#<span class="number">9</span></span><br><span class="line"><span class="number">19</span>: (<span class="number">7b</span>) *(u64 *)(r10 <span class="number">-56</span>) = r7</span><br><span class="line">R0=inv(id=<span class="number">0</span>) R6=ctx(id=<span class="number">0</span>,off=<span class="number">0</span>,imm=<span class="number">0</span>) R7=inv(id=<span class="number">0</span>,umax_value=<span class="number">2</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x3</span>))</span><br><span class="line">R8=inv4294967162 R9=inv(id=<span class="number">0</span>) R10=fp0,call_<span class="number">-1</span> fp<span class="number">-48</span>=mmmm???? fp<span class="number">-56</span>=mmmmmmmm</span><br><span class="line"><span class="number">21</span>: (<span class="number">61</span>) r1 = *(u32 *)(r9 +<span class="number">23</span>)</span><br><span class="line">R9 invalid mem access &#x27;inv&#x27;</span><br></pre></td></tr></table></figure><p>要解决这个问题，必须更新（重新计算） ip4 的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip4</span> =</span> (struct iphdr *) skb-&gt;data + ETH_HLEN;</span><br><span class="line"></span><br><span class="line">skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &amp;new_saddr, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ip4 = (struct iphdr *) skb-&gt;data + ETH_HLEN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip4-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>文档连接</h1><p><a href="https://www.dazhuanlan.com/2019/12/10/5dee76b007da0/">Linux BPF 3.2、BPF and XDP Reference Guide</a><br><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">[译] Cilium：BPF 和 XDP 参考指南（2019）</a><br><a href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">BPF 辅助函数</a><br><a href="https://man7.org/linux/man-pages/man2/bpf.2.html">BPF man 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. eBPF 工具链</title>
      <link href="/jony.github.io/e83139ad9bf1/"/>
      <url>/jony.github.io/e83139ad9bf1/</url>
      
        <content type="html"><![CDATA[<h1>工具链</h1><hr><p>本节介绍 BPF 相关的用户态工具、内省设施（introspection facilities）和内核控制选项。 注意，围绕 BPF 的工具和基础设施还在快速发展当中，因此本文提供的内容可能只覆 盖了其中一部分。</p><h3 id="Ubuntu">Ubuntu</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev \</span><br><span class="line">  clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex \</span><br><span class="line">  graphviz</span><br></pre></td></tr></table></figure><h1>2.2 LLVM</h1><p>写作本文时，LLVM 是唯一提供 BPF 后端的编译器套件。gcc 目前还不支持。</p><p>主流的发行版在对 LLVM 打包的时候就默认启用了 BPF 后端，因此，在大部分发行版上安 装 clang 和 llvm 就可以将 C 代码编译为 BPF 对象文件了。</p><p>典型的工作流是：</p><ol><li>用 C 编写 BPF 程序</li><li>用 LLVM 将 C 程序编译成对象文件（ELF）</li><li>用户空间 BPF ELF 加载器（例如 iproute2）解析对象文件</li><li>加载器通过 bpf() 系统调用将解析后的对象文件注入内核</li><li>内核验证 BPF 指令，然后对其执行即时编译（JIT），返回程序的一个新文件描述符</li><li>利用文件描述符 attach 到内核子系统（例如网络子系统）</li></ol><p>某些子系统还支持将 BPF 程序 offload 到硬件（例如网卡）。</p><h2 id="2-2-1-BPF-Target（目标平台）">2.2.1 BPF Target（目标平台）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ llc --version</span><br><span class="line">LLVM (http://llvm.org/):</span><br><span class="line">LLVM version 3.8.1</span><br><span class="line">Optimized build.</span><br><span class="line">Default target: x86_64-unknown-linux-gnu</span><br><span class="line">Host CPU: skylake</span><br><span class="line"></span><br><span class="line">Registered Targets:</span><br><span class="line">  [...]</span><br><span class="line">  bpf        - BPF (host endian)</span><br><span class="line">  bpfeb      - BPF (big endian)</span><br><span class="line">  bpfel      - BPF (little endian)</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure><p><strong>默认情况下，bpf target 使用编译时所在的 CPU 的大小端格式</strong> ，即，如果 CPU 是小 端，BPF 程序就会用小端表示；如果 CPU 是大端，BPF 程序就是大端。这也和 BPF 的运 行时行为相匹配，这样的行为比较通用，而且大小端格式一致可以避免一些因为格式导致的 架构劣势。</p><p>BPF 程序可以在大端节点上编译，在小端节点上运行，或者相反，因此对于 <strong>交叉编译</strong> ， 引入了两个新目标 <code>bpfeb</code> 和 <code>bpfel</code>。注意前端也需要以相应的大小端方式运行。</p><p>在不存在大小端混用的场景下，建议使用 bpf target。例如，在 x86_64 平台上（小端 ），指定 bpf 和 bpfel 会产生相同的结果，因此触发编译的脚本不需要感知到大小端 。</p><p>下面是一个最小的完整 XDP 程序，实现丢弃包的功能（xdp-example.c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME)                  \</span></span><br><span class="line">   __attribute__((section(NAME), used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_drop</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>用下面的命令编译并加载到内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -Wall -target bpf -c xdp-example.c -o xdp-example.o</span><br><span class="line">$ ip link <span class="built_in">set</span> dev em1 xdp obj xdp-example.o</span><br></pre></td></tr></table></figure><pre><code># 注意以上命令将一个 XDP 程序 attach 到一个网络设备，需要是 Linux 4.11 内核中支持 XDP 的设备，或者 4.12+ 版本的内核。</code></pre><p>LLVM（&gt;= 3.9） 使用正式的 BPF 机器值（machine value），即 EM_BPF（十进制 247 ，十六进制 0xf7），来生成对象文件。在这个例子中，程序是用 bpf target 在 x86_64 平台上编译的，因此下面显示的大小端标识是 LSB (和 MSB 相反)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file xdp-example.o</span><br><span class="line">xdp-example.o: ELF 64-bit LSB relocatable, *unknown arch 0xf7* version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure><p><code>readelf -a xdp-example.o</code> 能够打印 ELF 文件的更详细信息，有时在检查生成的 section header、relocation entries 和符号表时会比较有用。</p><hr><h1>2.2.2 调试信息（<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a>、BTF）</h1><p>若是要 debug，clang 可以生成下面这样的汇编器输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -S -Wall -target bpf -c xdp-example.c -o xdp-example.S</span><br><span class="line">$ cat xdp-example.S</span><br><span class="line">    .text</span><br><span class="line">    .section    prog,<span class="string">&quot;ax&quot;</span>,@progbits</span><br><span class="line">    .globl      xdp_drop</span><br><span class="line">    .p2align    3</span><br><span class="line">xdp_drop:                             <span class="comment"># @xdp_drop</span></span><br><span class="line"><span class="comment"># BB#0:</span></span><br><span class="line">    r0 = 1</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">    .section    license,<span class="string">&quot;aw&quot;</span>,@progbits</span><br><span class="line">    .globl    __license               <span class="comment"># @__license</span></span><br><span class="line">__license:</span><br><span class="line">    .asciz    <span class="string">&quot;GPL&quot;</span></span><br></pre></td></tr></table></figure><p>LLVM 从 6.0 开始，还包括了汇编解析器（assembler parser）的支持。你可以直接使用 BPF 汇编指令编程，然后使用 llvm-mc 将其汇编成一个目标文件。例如，你可以将前面 的 xdp-example.S 重新变回对象文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-mc -triple bpf -filetype=obj -o xdp-example.o xdp-example.S</span><br></pre></td></tr></table></figure><h1><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式和 llvm-objdump</h1><p>另外，较新版本（&gt;= 4.0）的 LLVM 还可以将调试信息以 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a> 格式存储到对象文件中。 只要在编译时加上 -g：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -g -Wall -target bpf -c xdp-example.c -o xdp-example.o</span><br><span class="line">$ llvm-objdump -S -no-show-raw-insn xdp-example.o</span><br><span class="line"></span><br><span class="line">xdp-example.o:        file format ELF64-BPF</span><br><span class="line"></span><br><span class="line">Disassembly of section prog:</span><br><span class="line">xdp_drop:</span><br><span class="line">; &#123;</span><br><span class="line">    0:        r0 = 1</span><br><span class="line">; <span class="built_in">return</span> XDP_DROP;</span><br><span class="line">    1:        <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>llvm-objdump 工具能够用编译的 C 源码对汇编输出添加注解（annotate ）。这里 的例子过于简单，没有几行 C 代码；但注意上面的 0 和 1 行号，这些行号直接对 应到内核的校验器日志（见下面的输出）。这意味着假如 BPF 程序被校验器拒绝了， llvm-objdump能帮助你将 BPF 指令关联到原始的 C 代码，对于分析来说非常有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ip link <span class="built_in">set</span> dev em1 xdp obj xdp-example.o verb</span><br><span class="line"></span><br><span class="line">Prog section <span class="string">&#x27;prog&#x27;</span> loaded (5)!</span><br><span class="line"> - Type:         6</span><br><span class="line"> - Instructions: 2 (0 over <span class="built_in">limit</span>)</span><br><span class="line"> - License:      GPL</span><br><span class="line"></span><br><span class="line">Verifier analysis:</span><br><span class="line"></span><br><span class="line">0: (b7) r0 = 1</span><br><span class="line">1: (95) <span class="built_in">exit</span></span><br><span class="line">processed 2 insns</span><br></pre></td></tr></table></figure><p>从上面的校验器分析可以看出，llvm-objdump 的输出和内核中的 BPF 汇编是相同的。</p><p>去掉 -no-show-raw-insn 选项还可以以十六进制格式在每行汇编代码前面打印原始的 struct bpf_insn：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-objdump -S xdp-example.o</span><br><span class="line"></span><br><span class="line">xdp-example.o:        file format ELF64-BPF</span><br><span class="line"></span><br><span class="line">Disassembly of section prog:</span><br><span class="line">xdp_drop:</span><br><span class="line">; &#123;</span><br><span class="line">   0:       b7 00 00 00 01 00 00 00     r0 = 1</span><br><span class="line">; <span class="built_in">return</span> foo();</span><br><span class="line">   1:       95 00 00 00 00 00 00 00     <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h3 id="LLVM-IR">LLVM IR</h3><p>对于 LLVM IR 调试，BPF 的编译过程可以分为两个步骤：首先生成一个二进制 LLVM IR 临 时文件 xdp-example.bc，然后将其传递给 <code>llc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc</span><br><span class="line">$ llc xdp-example.bc -march=bpf -filetype=obj -o xdp-example.o</span><br></pre></td></tr></table></figure><p>生成的 LLVM IR 还可以 dump 成人类可读的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -Wall -emit-llvm -S -c xdp-example.c -o -</span><br></pre></td></tr></table></figure><h2 id="BTF">BTF</h2><p>LLVM 能将调试信息（例如对程序使用的数据的描述）attach 到 BPF 对象文件。默认情况 下使用 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式。</p><p>BPF 使用了一个高度简化的版本，称为 <strong>BTF</strong> (BPF Type Format)。生成的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 可以 转换成 BTF 格式，然后通过 BPF 对象加载器加载到内核。内核验证 BTF 数据的正确性， 并跟踪 BTF 数据中包含的数据类型。</p><p>这样的话，就可以用键和值对 BPF map 打一些注解（annotation）存储到 BTF 数据中，这 样下次 dump map 时，除了 map 内的数据外还会打印出相关的类型信息。这对内省（ introspection）、调试和格式良好的打印都很有帮助。注意，BTF 是一种通用的调试数据 格式，因此任何从 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 转换成的 BTF 数据都可以被加载（例如，内核 vmlinux <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 数 据可以转换成 BTF 然后加载）。后者对于未来 BPF 的跟踪尤其有用。</p><p>将 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 格式的调试信息转换成 BTF 格式需要用到 <code>elfutils</code> (&gt;= 0.173) 工具。 如果没有这个工具，那需要在 <code>llc</code> 编译时打开 <code>-mattr=[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)ris</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ llc -march=bpf -mattr=<span class="built_in">help</span> |&amp; grep [dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/<span class="comment">#bpf_instruction)ris</span></span><br><span class="line">[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/<span class="comment">#bpf_instruction)ris - Disable MCAsmInfo [Dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction)UsesRelocationsAcrossSections.</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>使用 -mattr=<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 是因为 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris (<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a> relocation in section) 选项禁 用了 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 和 ELF 的符号表之间的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> cross-section 重定位，因为 libdw 不支持 BPF 重定位。不打开这个选项的话，pahole 这类工具将无法正确地从对象中 dump 结构。</p><p>elfutils (&gt;= 0.173) 实现了合适的 BPF 重定位，因此没有打开 -mattr=<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选 项也能正常工作。它可以从对象文件中的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 或 BTF 信息 dump 结构。目前 pahole 使用 LLVM 生成的 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 信息，但未来它可能会使用 BTF 信息。</p><h2 id="pahole-注：pahole-一种代码审计工具">pahole (注：pahole 一种代码审计工具)</h2><p>将 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 转换成 BTF 格式需要使用较新的 pahole 版本（&gt;= 1.12），然后指定 -J 选项。 检查所用的 pahole 版本是否支持 BTF（注意，pahole 会用到 llvm-objcopy，因此 也要检查后者是否已安装）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pahole --<span class="built_in">help</span> | grep BTF</span><br><span class="line">-J, --btf_encode           Encode as BTF</span><br></pre></td></tr></table></figure><p>生成调试信息还需要前端的支持，在 clang 编译时指定 -g 选项，生成源码级别的调 试信息。注意，不管 llc 是否指定了 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选项，-g 都是需要指定的。生成目 标文件的完整示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -O2 -g -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc</span><br><span class="line">$ llc xdp-example.bc -march=bpf -mattr=[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/<span class="comment">#bpf_instruction)ris -filetype=obj -o xdp-example.o</span></span><br></pre></td></tr></table></figure><p>或者，只使用 clang 这一个工具来编译带调试信息的 BPF 程序（同样，如果有合适的 elfutils 版本，<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">dwarf</a>ris 选项可以省略）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -target bpf -O2 -g -c -Xclang -target-feature -Xclang +[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/<span class="comment">#bpf_instruction)ris -c xdp-example.c -o xdp-example.o</span></span><br></pre></td></tr></table></figure><p>基于 <a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 信息 dump BPF 程序的数据结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pahole xdp-example.o</span><br><span class="line">struct xdp_md &#123;</span><br><span class="line">        __u32                      data;                 /*     0     4 */</span><br><span class="line">        __u32                      data_end;             /*     4     4 */</span><br><span class="line">        __u32                      data_meta;            /*     8     4 */</span><br><span class="line"></span><br><span class="line">        /* size: 12, cachelines: 1, members: 3 */</span><br><span class="line">        /* last cacheline: 12 bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在对象文件中，<a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">DWARF</a> 数据将仍然伴随着新加入的 BTF 数据一起保留。完整的 clang 和 pahole 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -target bpf -O2 -Wall -g -c -Xclang -target-feature -Xclang +[dwarf](http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/<span class="comment">#bpf_instruction)ris -c xdp-example.c -o xdp-example.o</span></span><br><span class="line">$ pahole -J xdp-example.o</span><br></pre></td></tr></table></figure><h2 id="readelf">readelf</h2><p>通过 readelf 工具可以看到多了一个 .BTF section：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -a xdp-example.o</span><br><span class="line">[...]</span><br><span class="line">  [18] .BTF              PROGBITS         0000000000000000  00000671</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>BPF 加载器（例如 iproute2）会检测和加载 BTF section，因此给 BPF map 注释（ annotate）类型信息。</p><h3 id="2-2-3-BPF-指令集">2.2.3 BPF 指令集</h3><pre><code>根据不同的 CPU 生成不同的汇编指令，用于编译和执行</code></pre><p>LLVM 默认用 BPF 基础指令集（base instruction set）来生成代码，以确保这些生成的对<br>象文件也能够被稍老的 LTS 内核（例如 4.9+）加载。</p><p>但是，LLVM 提供了一个 BPF 后端选项 <code>-mcpu</code>，可以指定不同版本的 BPF 指令集，即<br>BPF 基础指令集之上的指令集扩展（instruction set extensions），以生成更高效和体积<br>更小的代码。</p><p>可用的 <code>-mcpu</code> 类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> llc -march bpf -mcpu=<span class="built_in">help</span></span></span><br><span class="line">Available CPUs for this target:</span><br><span class="line"></span><br><span class="line">  generic - Select the generic processor.</span><br><span class="line">  probe   - Select the probe processor.</span><br><span class="line">  v1      - Select the v1 processor.</span><br><span class="line">  v2      - Select the v2 processor.</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><ul><li><code>generic</code> processor 是默认的 processor，也是 BPF <code>v1</code> 基础指令集。</li><li><code>v1</code> 和 <code>v2</code> processor 通常在交叉编译 BPF 的环境下比较有用，即编译 BPF 的平台<br>和最终执行 BPF 的平台不同（因此 BPF 内核特性可能也会不同）。</li></ul><p><strong>推荐使用 <code>-mcpu=probe</code> ，这也是 Cilium 内部在使用的类型</strong>。使用这种类型时，<br>LLVM BPF 后端会向内核询问可用的 BPF 指令集扩展，如果找到可用的，就会使用相应的指<br>令集来编译 BPF 程序。</p><p>使用 <code>llc</code> 和 <code>-mcpu=probe</code> 的完整示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -O2 -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> llc xdp-example.bc -march=bpf -mcpu=probe -filetype=obj -o xdp-example.o</span></span><br></pre></td></tr></table></figure><p><a name="ch_2.2.4"></a></p><h3 id="2-2-4-指令和寄存器位宽（64-32-位）">2.2.4 指令和寄存器位宽（64/32 位）</h3><p>通常来说，LLVM IR 生成是架构无关的。但使用 <code>clang</code> 编译时是否指定 <code>-target bpf</code><br>是有几点小区别的，取决于不同的平台架构（<code>x86_64</code>、<code>arm64</code> 或其他），<code>-target</code> 的<br>默认配置可能不同。</p><p>引用内核文档 <code>Documentation/bpf/bpf_devel_QA.txt</code>：</p><ul><li><p>BPF 程序可以嵌套 include 头文件，只要头文件中都是文件作用域的内联汇编代码（<br>file scope inline assembly codes）。大部分情况下默认 target 都可以处理这种情况，<br>但如果 BPF 后端汇编器无法理解这些汇编代码，那 <code>bpf</code> target 会失败。</p></li><li><p>如果编译时没有指定 <code>-g</code>，那额外的 elf sections（例如 <code>.eh_frame</code><br>和 <code>.rela.eh_frame</code>）可能会以默认 target 格式出现在对象文件中，但不会是 <code>bpf</code><br>target。</p></li><li><p>默认 target 可能会将一个 C <code>switch</code> 声明转换为一个 <code>switch</code> 表的查找和跳转操作。<br>由于 switch 表位于全局的只读 section，因此 BPF 程序的加载会失败。 <code>bpf</code> target<br>不支持 switch 表优化。clang 的 <code>-fno-jump-tables</code> 选项可以禁止生成 switch 表。</p></li><li><p>如果 clang 指定了 <code>-target bpf</code>，那指针或 <code>long</code>/<code>unsigned long</code> 类型将永远<br>是 64 位的，不管底层的 clang 可执行文件或默认的 target（或内核）是否是 32<br>位。但如果使用的是 native clang target，那 clang 就会根据底层的架构约定（<br>architecture’s conventions）来编译这些类型，这意味着对于 32 位的架构，BPF 上下<br>文中的指针或 <code>long</code>/<code>unsigned long</code> 类型会是 32 位的，但此时的 BPF LLVM 后端仍<br>然工作在 64 位模式。</p></li></ul><p><code>native</code> target 主要用于跟踪（tracing）内核中的 <code>struct pt_regs</code>，这个结构体对<br>CPU 寄存器进行映射，或者是跟踪其他一些能感知 CPU 寄存器位宽（CPU’s register<br>width）的内核结构体。除此之外的其他场景，例如网络场景，都建议使用 <code>clang -target bpf</code>。</p><p>另外，LLVM 从 7.0 开始支持 32 位子寄存器和 BPF ALU32 指令。另外，新加入了一个代<br>码生成属性 <code>alu32</code>。当指定这个参数时，LLVM 会尝试尽可能地使用 32 位子寄存器，例<br>如当涉及到 32 位操作时。32 位子寄存器及相应的 ALU 指令组成了 ALU32 指令。例如，<br>对于下面的示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat 32-bit-example.c</span></span><br><span class="line">void cal(unsigned int *a, unsigned int *b, unsigned int *c)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int sum = *a + *b;</span><br><span class="line">  *c = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用默认的代码生成选项，产生的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ clang -target bpf -emit-llvm -S 32-bit-example.c</span><br><span class="line">$ llc -march&#x3D;bpf 32-bit-example.ll</span><br><span class="line">$ cat 32-bit-example.s</span><br><span class="line">cal:</span><br><span class="line">  r1 &#x3D; *(u32 *)(r1 + 0)</span><br><span class="line">  r2 &#x3D; *(u32 *)(r2 + 0)</span><br><span class="line">  r2 +&#x3D; r1</span><br><span class="line">  *(u32 *)(r3 + 0) &#x3D; r2</span><br><span class="line">  exit</span><br></pre></td></tr></table></figure><p>可以看到默认使用的是 <code>r</code> 系列寄存器，这些都是 64 位寄存器，这意味着其中的加法都<br>是 64 位加法。现在，如果指定 <code>-mattr=+alu32</code> 强制要求使用 32 位，生成的汇编代码<br>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ llc -march&#x3D;bpf -mattr&#x3D;+alu32 32-bit-example.ll</span><br><span class="line">$ cat 32-bit-example.s</span><br><span class="line">cal:</span><br><span class="line">  w1 &#x3D; *(u32 *)(r1 + 0)</span><br><span class="line">  w2 &#x3D; *(u32 *)(r2 + 0)</span><br><span class="line">  w2 +&#x3D; w1</span><br><span class="line">  *(u32 *)(r3 + 0) &#x3D; w2</span><br><span class="line">  exit</span><br></pre></td></tr></table></figure><p>可以看到这次使用的是 <code>w</code> 系列寄存器，这些是 32 位子寄存器。</p><p>使用 32 位子寄存器可能会减小（最终生成的代码中）<strong>类型扩展指令</strong>（type extension<br>instruction）的数量。另外，它对 32 位架构的内核 eBPF JIT 编译器也有所帮助，因为<br>原来这些编译器都是用 32 位模拟 64 位 eBPF 寄存器，其中使用了很多 32 位指令来操作<br>高 32 bit。即使写 32 位子寄存器的操作仍然需要对高 32 位清零，但只要确保从 32 位<br>子寄存器的读操作只会读取低 32 位，那只要 JIT 编译器已经知道某个寄存器的定义只有<br>子寄存器读操作，那对高 32 位的操作指令就可以避免。</p><h1>文档连接</h1><p><a href="https://www.dazhuanlan.com/2019/12/10/5dee76b007da0/">Linux BPF 3.2、BPF and XDP Reference Guide</a><br><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">[译] Cilium：BPF 和 XDP 参考指南（2019）</a><br><a href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">BPF 辅助函数</a><br><a href="https://man7.org/linux/man-pages/man2/bpf.2.html">BPF man 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. eBPF 翻译文档合集</title>
      <link href="/jony.github.io/6b9c54247f6f/"/>
      <url>/jony.github.io/6b9c54247f6f/</url>
      
        <content type="html"><![CDATA[<pre><code>注意：本文档部分针对的是希望深入了解BPF和XDP的开发人员和用户。尽管阅读本参考指南可能有助于拓宽你对Cilium的理解，但使用Cilium并不是必须的。请参考入门指南和概念以获得更高级别的介绍。</code></pre><p>BPF是Linux内核中高度灵活和高效的类似虚拟机的构造，允许以安全的方式在各种挂起点执行字节码。它被用于许多Linux内核子系统，最突出的是networking、tracing和安全(例如沙箱)。</p><p>尽管BPF自1992年以来就存在，但本文介绍了扩展的Berkeley Packet Filter (eBPF)版本，该版本首次出现在内核3.18中，并呈现了最近被称为“classic&quot;BPF (cBPF)的原始版本。cBPF以tcpdump使用的包过滤语言而闻名。现在，Linux内核只运行eBPF，并且在程序执行之前将加载的cBPF字节码透明地转换为内核中的eBPF表示。除非明确指出eBPF和cBPF之间的区别，否则本文档一般将使用BPF这个术语。</p><p>尽管 Berkeley Packet Filter的名称暗示了包过滤的特定用途，但是指令集是通用的，并且非常灵活，除了网络之外，BPF还有很多用例。有关使用BPF的项目列表，请参阅进一步阅读。</p><p>Cilium 在其数据路径中大量使用BPF，有关更多信息，请参阅概念。本章的目标是提供一个BPF参考指南，以了解BPF，它的网络特定用途，包括加载BPF程序与tc((traffic control)和XDP (eXpress Data Path)，并协助开发Cilium的BPF模板。</p><p>BPF不仅仅定义了自己的指令集，还提供了更进一步的框架。包括：maps(高效的key/value存储)、helper functions(调用内核函数)、tail calls(调用其他的BPF程序)、security hardening primitives(安全性加强原语)、一个伪文件系统为了pinning目标(maps、programs)、还允许BPF的offloaded(例如，offload到一个网卡)。</p><p>LLVM提供了一个BPF后端，这样就可以使用像clang这样的工具将C编译成BPF对象文件，然后可以将其加载到内核中。BPF与Linux内核紧密相连，允许在不牺牲本机内核性能的情况下进行完全的编程。</p><p>最后，使用BPF的内核子系统也是BPF基础设施的一部分。本文档中讨论的两个主要子系统是tc和XDP, BPF程序可以附加到这两个子系统中。XDP BPF程序是在最早的网络驱动阶段附加的，在数据包接收时触发BPF程序运行。根据定义，这可以获得最佳的包处理性能，因为包在软件中甚至不能在更早的时候被处理。然而，由于这种处理发生在网络堆栈的早期，堆栈还没有从包中提取元数据。另一方面，tc BPF程序稍后在内核堆栈中执行，因此它们可以访问更多的元数据和核心内核功能。除了tc和XDP程序之外，还有许多其他使用BPF的内核子系统，如trace (kprobes, uprobes, tracepoint等)。</p><p>下面的小节将进一步详细介绍BPF体系结构的各个方面。</p><h1>1.1 Instruction Set</h1><hr><p>BPF是一个通用的RISC指令集，最初的设计目的是可以使用一个C语言的子集写程序并且可以通过一个编译器后端(例如LLVM)编译成BPF指令，这样内核就可以稍后通过内核JIT编译器将它们映射到本机操作码优化内核内部的执行性能。</p><p>将这些指令推入内核的优点包括:</p><ul><li><p>使内核可编程，而不必跨越内核/用户空间边界。例如，networking相关的BPF程序，如Cilium，可以实现灵活的 container policies, load balancing and other means，而无需将包移动到用户空间并返回到内核。当需要时，BPF程序和内核/用户空间之间的状态仍然可以通过映射共享。</p></li><li><p>考虑到可编程数据路径的灵活性，还可以通过编译去掉不需要的特性来大大优化程序的性能。例如，如果一个container不需要IPv4，那么BPF程序可以构建为只处理IPv6，以便在快速通道中节省资源。</p></li><li><p>假设networking应用(例如tc和XDP)， BPF程序可以自动更新，而无需重新启动内核、系统服务或容器，也无需中断数据传输。此外，任何程序状态也可以通过BPF maps在整个更新过程中维护。</p></li><li><p>BPF为用户空间提供了一个稳定的ABI，不需要任何第三方内核模块。BPF是到处发布的Linux内核的核心部分，它保证了现有的BPF程序可以在新的内核版本中继续运行。这种保证与内核为用户空间应用程序的系统调用提供的保证相同。此外，BPF程序可以跨不同的体系结构进行移植。</p></li><li><p>BPF程序与内核协同工作，它们利用现有的内核基础设施(例如drivers, netdevices, tunnels, protocol stack, sockets)和工具(例如iproute2)以及内核提供的安全保证。和内核模块不同,BPF程序验证通过内核校验以确保他们不能崩溃内核,总能终止,等。XDP项目,例如,重用现有的内核驱动程序和操作提供DMA缓冲区包含包数据，不暴露他们或整个驱动到用户空间。此外，XDP程序重用现有的堆栈，而不是绕过它。BPF可以被看作是一种通用的“粘合代码&quot;，用于编写用于解决特定用例的程序。</p></li></ul><p>在内核中执行BPF程序总是由事件驱动的!例如,一个网络设备具有BPF程序附在其入口路径，收到数据包将触发程序的执行一次；内核地址有kprobes附带一个BPF程序，一旦地址的代码被执行,然后调用kprobes回调函数随后触发执行BPF程序。</p><p>BPF由11个64位寄存器(包含32位子寄存器)、PC、512字节的堆栈空间组成。寄存器命名为 r0 - r10。操作模式默认为64位，32位子寄存器只能通过特殊的ALU(算术逻辑单元)操作访问。32位以下的子寄存器在写入时从0扩展到64位。</p><p>寄存器r10是唯一的只读寄存器，它包含堆栈指针地址，以便访问BPF堆栈空间。其余的r0 - r9寄存器是一般用途和读写性质。</p><p>BPF程序可以调用预定义的helper function，这是由核心内核(而不是模块)定义的。BPF调用规范定义如下:</p><pre><code>- r0 存放被调用的辅助函数的返回值- r1 - r5 存放 BPF 调用内核辅助函数时传递的参数- r6 - r9 由被调用方（callee）保存，在函数返回之后调用方（caller）可以读取</code></pre><p>BPF调用规范足够通用，可以直接映射到x86_64、arm64和其他ABIs，因此所有 BPF 寄存器可以一一映射到硬件 CPU 寄存器，这样JIT只需发出一个调用指令，而不需要额外的移动来放置函数参数。这种调用规范的建模是为了涵盖常见的调用情况，而不会造成性能损失。当前不支持带有6个或更多参数的调用。内核中专门用于BPF (BPF_CALL_0()到BPF_CALL_5()函数的helper函数是专门根据这种规范设计的。</p><p>寄存器r0也是包含BPF程序退出值的寄存器。退出值的语义由程序的类型定义。此外，当将执行返回给内核时，退出值作为32位值传递。</p><p>寄存器r1 - r5是暂存寄存器，这意味着BPF程序需要将它们临时转储（spill）到BPF堆栈中，或者将它们移动到被调用方保存的寄存器中，如果这些参数要跨多个辅助函数调用重用的话。spilling意味着寄存器中的变量被移动到BPF堆栈中。将变量从BPF堆栈移到寄存器的反向操作称为filling。spilling/filling的原因是寄存器数量有限。</p><p>在执行BPF程序时，寄存器r1最初包含程序的context。context是程序的输入参数(类似于典型C程序的argc/argv对)。BPF仅限于在单个context中工作。context由程序类型定义，例如，网络程序可以将网络数据包(skb)的内核表示形式作为输入参数。</p><p>BPF的一般操作是64位，遵循64位体系结构的自然模型，以便执行指针算术运算，传递指针，也向helper functions传递64位值，并允许64位原子操作。</p><p>每个程序的最大指令限制限制在4096 BPF指令，这意味着任何程序都会很快终止。虽然指令集包含前向跳转和后向跳转，但是内核中的BPF验证器将禁止循环，保证程序总是能终止。由于BPF程序在内核中运行，verifier的工作是确保这些程序能够安全运行，而不影响系统的稳定性。这意味着从指令集的观点来看，循环是可以实现的，但是verifier会限制它。然而，也有一个tail call的概念，允许一个BPF程序跳转到另一个BPF程序。这也带来了32个调用的嵌套上限。tail call通常用于将程序逻辑的一部分解耦，例如，分解成阶段。</p><p>指令格式建模为两个操作数指令，这有助于在JIT阶段将BPF指令映射到本机指令。指令集是固定大小的，这意味着每条指令都有64位编码。目前，已经实现了87条指令，编码还允许在需要时使用进一步的指令扩展集合。在big-endian机上一条64位指令的指令编码定义为从最有效位(MSB)到最低有效位(LSB)的位序列，<strong><code>“op:8, dst_reg:4, src_reg:4, off:16, imm:32&quot;</code></strong>。off和imm是有符号类型。编码是内核头文件的一部分，在linux/bpf.h头文件中定义。其中还包括linux/bpf_common.h。</p><p>“op&quot;定义要执行的实际操作。大多数用于op的编码都被cBPF重用。操作可以基于寄存器或直接操作数。op本身的编码提供了使用哪种模式的信息<br>- BPF_X分别表示基于寄存器的操作<br>- BPF_K分别表示基于立即的操作</p><p>在后一种情况下，目标操作数总是一个寄存器。dst_reg和src_reg都提供了关于用于操作的寄存器操作数(例如r0 - r9)的附加信息。&quot;off&quot;在一些指令中用于提供相对偏移量，例如，用于处理BPF可用的堆栈或其他缓冲区(例如map value、包数据等)，或跳转指令中的跳转目标。imm包含一个常量/即时值。</p><p>可用的&quot;op&quot;指令可以分为不同的指令类。这些类也编码在op字段中。op字段分为(从MSB到LSB)<code>code:4</code>, <code>source:1</code> 和 <code>class:3</code><br>- class 是指令类型<br>- code 指特定类型的指令中的某种特定操作码（operational code）<br>- source 可以告诉我们源操作数（source operand）是一个寄存器还是一个立即数</p><p>可能的指令类包括:</p><ul><li><p><code>BPF_LD</code>, <code>BPF_LDX</code>：<strong>加载操作（load operations）</strong></p><ul><li><code>BPF_LD</code> 用于加载 <strong>double word 长度的特殊指令</strong>（占两个指令长度，源于 imm:32 的限制），或byte / half-word / word 长度的包数据（packet data ）后者主要是为了保持cBPF转换为BPF的效率，因为他们已经优化了JIT代码。对于 native BPF 来说，这些包加载指令在今天已经 用的很少了。</li><li><code>BPF_LDX</code> 用于从内存中加载 byte / half-word / word / double-word，这里的内存包括栈内存、map value data、packet data 等等。</li></ul></li><li><p><code>BPF_ST</code>, <code>BPF_STX</code>：<strong>存储操作（store operations）</strong></p><ul><li><code>BPF_STX</code> 与 <code>BPF_LDX</code> 相对，将某个寄存器中的值存储到内存中，同样，这里的 内存也可以是栈内存、map value、packet data 等等。BPF_STX 类包含一些 word 和 double-word 相关的原子加操作，例如，可以用于计数器。</li><li><code>BPF_ST类</code> 与 <code>BPF_STX</code> 指令类似，提供了将源操作数（source operand）作为立即值（immediate value）存储到内中。</li></ul></li><li><p>BPF_ALU, BPF_ALU64：逻辑运算操作（ALU operations），BPF_ALU操作是32位模式，BPF_ALU64是64位模式。这两个ALU类的源操作数具有基于寄存器或基于即时操作数的模式。支持<code>add (+), sub (-), and (&amp;), or (|), left shift (&lt;&lt;), right shift (&gt;&gt;), xor (^), mul (*), div (/), mod (%), neg (~) </code>操作。</p><ul><li>&quot;mov ( := )&quot;作为一种特殊的ALU操作添加到这两个类的操作模式中。</li><li>BPF_ALU64包含符号右移位</li><li>BPF_ALU还包含在给定源寄存器中half-word/word/double-word的字节序转换指令</li></ul></li><li><p>BPF_JMP：跳转操作（jump operations）</p><ul><li>跳跃可以是无条件的，也可以是有条件的。<ul><li>无条件跳转只是将程序计数器向前移动，相对于当前指令执行的下一条指令是off + 1，其中off是指令中编码的常量偏移量。因为off是有符号的，所以跳转也可以向后执行，只要它不创建循环并且在程序范围内。</li><li>条件跳转对基于寄存器和基于立即的源操作数都进行操作。如果跳转操作中的条件是true，则执行相对跳转到off + 1，否则执行下一条指令(0 + 1)。</li></ul></li><li>与cBPF相比，这种fall-through跳转逻辑是不同的，并且允许更好的分支预测，因为它更自然地适合CPU分支预测逻辑。可用条件有 <code>jeq (==), jne (!=), jgt (&gt;), jge (&gt;=), jsgt (signed &gt;), jsge (signed &gt;=), jlt (&lt;), jle (&lt;=), jslt (signed &lt;), jsle (signed &lt;=) and jset (jump if DST &amp; SRC)</code> 。除此之外,有三个特殊的跳转操作在这个类:exit 指令,将带通滤波器程序并返回当前值在r0返回代码；call指令,这将发出一个函数调用到一个可用的BPF helper function；和一个隐藏的tail call指令,进入一个不同的BPF程序。</li></ul></li></ul><p><strong>Linux 内核中内置了一个 BPF 解释器</strong>，该解释器能够执行由 BPF 指令组成的程序。即使是 cBPF 程序，也可以在内核中透明地转换成 eBPF 程序，除非该架构仍然内置了 cBPF JIT，还没有迁移到 eBPF JIT。</p><p>目前下列架构都内置了内核 eBPF JIT 编译器：x86_64、arm64、ppc64、s390x 、mips64、sparc64 和 arm。</p><p>所有的 BPF 操作，例如加载程序到内核，或者创建 BPF map，都是通过核心的 bpf() 系统调用完成的。它还用于管理 map 表项（查找/更新/删除），以及通过 pinning（钉住 ）将程序和 map 持久化到 BPF 文件系统。</p><hr><h1>1.2 Helper Functions</h1><p>简单来说就是BPF程序调用kernel的函数。</p><p>辅助函数（Helper functions）使得 BPF 能够通过内核定义的一系列函数调用（function call）从内核中查询数据，或者将数据推送到内核。不同类型的 BPF 程序能够使用的 辅助函数可能是不同的，例如，与连接到 tc 层的 BPF 程序相比，连接到 socket 的 BPF程序只能够调用前者可以调用的辅助函数的一个子集。另外一个例子是，<strong>轻量级隧道</strong>（lightweight tunneling ）的 <strong>封装和解封装（Encapsulation and decapsulation）</strong> 辅助函数，只能被 <strong>更低级 tc 层（lower tc layers）</strong> 使用；而推送通知到 用户态所使用的事件输出辅助函数，既可以被 tc 程序使用也可以被 XDP 程序使用。</p><p>所有的辅助函数都共享同一个通用的、和系统调用类似的函数签名。签名定义如下：<br>u64 fn(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)<br>前一节介绍的调用规范适用于所有的 BPF 辅助函数。</p><p>内核将辅助函数抽象为与系统调用类似的宏BPF_CALL_0()到BPF_CALL_5()。下面的示例是从一个辅助函数中提取的，该函数通过调用相应的回调来更新map elements:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BPF_CALL_4(bpf_map_update_elem, struct bpf_map *, <span class="built_in">map</span>, <span class="keyword">void</span> *, key,</span><br><span class="line">           <span class="keyword">void</span> *, value, u64, flags)</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON_ONCE(!rcu_read_lock_held());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_map_update_elem_proto</span> =</span> &#123;</span><br><span class="line">    .func           = bpf_map_update_elem,</span><br><span class="line">    .gpl_only       = <span class="literal">false</span>,</span><br><span class="line">    .ret_type       = RET_INTEGER,</span><br><span class="line">    .arg1_type      = ARG_CONST_MAP_PTR,</span><br><span class="line">    .arg2_type      = ARG_PTR_TO_MAP_KEY,</span><br><span class="line">    .arg3_type      = ARG_PTR_TO_MAP_VALUE,</span><br><span class="line">    .arg4_type      = ARG_ANYTHING,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 eBPF 中，JIT 编译器会以一种透明和高效的方式编译新加入的辅助函数，这意味着 JIT 编译器只需要发射（emit）一条调用指令（call instruction），因为寄存器映射的方式使得 BPF 排列参数的方式（assignments）已经和底层架构的调用规范相匹配了。这使得基于辅助函数扩展核心内核（core kernel）非常方便。所有的 BPF 辅助函数都是核心内核的一部分，无法通过内核模块（kernel module）来扩展或添加。</p><p>前面提到的函数签名还允许校验器执行类型检测（type check）。例如 struct bpf_func_proto 用于存放<code>校验器</code>必需知道的所有关于该辅助函数的信息，这样校验器才可以确保辅助函数期望的类型和 BPF 程序寄存器中的当前内容是匹配的。</p><p>辅助方法的参数类型范围很广，可以时任意类型，也可以限制为特定类型（例如 BPF 栈缓冲区（stack buffer）的 pointer/size 参数对），辅助函数可以从这个位置读取数据或向其写入数据。 对于这种情况，校验器还可以执行额外的检查，例如，缓冲区是否已经初始化过了。</p><p>当前可用的 BPF 辅助函数已经有几十个，并且数量还在不断增加，例如，写作本文时，tc BPF 程序可以使用38 种不同的 BPF 辅助函数。对于一个给定的 BPF 程序类型，内核的 struct bpf_verifier_ops 包含了 get_func_proto 回调函数，这个函数提供了从某个 特定的enum bpf_func_id 到一个可用的辅助函数的映射。</p><hr><h1>1.3 Maps</h1><p><img src="/jony.github.io/images/bpf_map.png" alt="Maps"><br>map 是驻留在内核空间中的高效键值仓库（key/value store）。map 中的数据可以被 BPF 程序访问，如果想在多个 BPF 程序调用（invoke）之间保存状态，可以将状态信息放到 map。map 还可以从用户空间通过文件描述符访问，可以在任意 BPF 程序以及用户空间应用之间共享。</p><p>共享 map 的 BPF 程序不要求是相同的程序类型，例如 tracing 程序可以和网络程序共享 map。单个 BPF 程序目前最多可直接访问 64 个不同 map。</p><p>map 的实现由核心内核（core kernel）提供。有 per-CPU 及 non-per-CPU 的通用 map，这些 map 可以读/写任意数据，也有一些和辅助函数一起使用的非通用 map。</p><p>当前可用的 通用 map 有：</p><pre><code>- BPF_MAP_TYPE_HASH- BPF_MAP_TYPE_ARRAY- BPF_MAP_TYPE_PERCPU_HASH- BPF_MAP_TYPE_PERCPU_ARRAY- BPF_MAP_TYPE_LRU_HASH- BPF_MAP_TYPE_LRU_PERCPU_HASH- BPF_MAP_TYPE_LPM_TRIE</code></pre><p>以上 map 都使用相同的一组 BPF 辅助函数来执行查找、更新或删除操作，但各自实现了不 同的后端，这些后端各有不同的语义和性能特点。</p><p>当前内核中的 非通用 map 有：</p><pre><code>- BPF_MAP_TYPE_PROG_ARRAY- BPF_MAP_TYPE_PERF_EVENT_ARRAY- BPF_MAP_TYPE_CGROUP_ARRAY- BPF_MAP_TYPE_STACK_TRACE- BPF_MAP_TYPE_ARRAY_OF_MAPS- BPF_MAP_TYPE_HASH_OF_MAPS</code></pre><p>例如，BPF_MAP_TYPE_PROG_ARRAY 是一个数组 map，用于保存其他的 BPF 程序 。BPF_MAP_TYPE_ARRAY_OF_MAPS 和 BPF_MAP_TYPE_HASH_OF_MAPS 都用于保存其他 map 的指针，这样整个 map 就可以在运行时实现原子替换。这些类型的 map 都针对 特定的问题，不适合单单通过一个 BPF 辅助函数实现，因为它们需要在各次 BPF 程序调用 （invoke）之间时保持额外的（非数据）状态。</p><hr><h1>1.4 Object Pinning</h1><p><img src="/jony.github.io/images/bpf_fs.png" alt="Object Pinning"><br>BPF map和程序作为内核资源只能通过由内核中的匿名节点支持的文件描述符访问。有优点，但也伴随着一些缺点:</p><p><strong>用户空间应用程序可以使用大多数与文件描述符相关的api, Unix域套接字传递的文件描述符可以透明地工作</strong>，等等，但是同时，<strong>文件描述符被限制在进程的生命周期内，这使得像map共享这样的选项执行起来相当麻烦</strong>。</p><p>因此，这给某些特定的场景带来了很多复杂性，例如 iproute2，其中的 tc 或 XDP 在准备 环境、加载程序到内核之后最终会<strong>退出</strong>。在这种情况下，从用户空间也无法访问这些 map 了，而本来这些 map 其实是很有用的，例如，在 data path 的 ingress 和 egress 位置共 享的 map（可以统计包数、字节数、PPS 等信息）。另外，第三方应用可能希望在 BPF 程 序运行时监控或更新 map。</p><p>为了解决这个问题，内核实现了一个最小内核空间 BPF 文件系统，BPF map 和 BPF 程序 都可以固定到这个文件系统上，这个过程称为 object pinning。相应地，BPF 系统调用进行了扩展，添加了两个新命令，分别用于固定（BPF_OBJ_PIN）或者获取（BPF_OBJ_GET）以前的固定住的对象（pinned objects）。</p><hr><h1>1.5 Tail Calls</h1><p><img src="/jony.github.io/images/bpf_tailcall.png" alt="Tail Calls"></p><p>BPF 相关的另一个概念是尾调用（tail calls）。尾调用的机制是：一个 BPF 程序可以调 用另一个 BPF 程序，并且调用完成后不用返回到原来的程序。和普通函数调用相比，这种 调用方式开销最小，因为它是用长跳转（long jump）实现的，复用了原来的栈帧 （stack frame）。</p><p>BPF 程序都是独立验证的，因此要传递状态，要么使用 per-CPU map 作为 暂存(scratch) 缓冲区 ，要么如果是 tc 程序的话，还可以使用 skb 的某些字段（例如 cb[]）。</p><p>相同类型的程序才可以尾调用，而且它们还要与 JIT 编译器相匹配，因此要么是 JIT 编译执行，要么是解释器执行（invoke interpreted programs），但只能选其一，不能混合在一起。。</p><p>尾调用执行涉及两个步骤：</p><pre><code>1. 设置一个称为“程序数组”（program array）的特殊 map（BPF_MAP_TYPE_PROG_ARRAY ），这个 map 可以从用户空间通过操作 key/value ，value就是tail calle调用的BPF 程序的文件描述符2. 调用辅助函数 bpf_tail_call()。将上下文、对程序数组的引用和要查找的 key 传递给该辅助函数。内核将这个辅助函数调用内联（ inline）到一个特殊的 BPF 指令内。目前，这样的程序数组在用户空间侧是只写模式。</code></pre><p>内核根据传入的文件描述符查找相关的 BPF 程序，原子性地替换给定的 map slot（槽） 处的程序指针。如果没有找到给定的 key 对应的 value，内核会跳过（fall through）这一步 ，继续执行 bpf_tail_call() 后面的旧程序。尾调用是一个强大的功能，例如，可以通 过尾调用结构化地解析网络头（network headers）。还可以在运行时（runtime）原子地 添加或替换功能，即，动态地改变 BPF 程序的执行行为。</p><hr><h1>1.6 BPF to BPF Calls</h1><p><img src="/jony.github.io/images/bpf_call.png" alt="BPF to BPF Calls"><br>除了 BPF 辅助函数和 BPF 尾调用之外，BPF 核心基础设施最近刚加入了一个新特性：BPF 到 BPF 调用（BPF to BPF calls）。在这个特性引入内核之前，典型的 BPF C 程序必须 将所有需要复用的代码进行特殊处理，例如，在头文件中声明为 always_inline。当 LLVM 编译和生成 BPF 对象文件时，所有这些函数将被内联，因此会在生成的对象文件中重复多次，导致代码尺寸膨胀：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME)                  \</span></span><br><span class="line">   __attribute__((section(NAME), used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __inline</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __inline                         \</span></span><br><span class="line">   <span class="keyword">inline</span> __attribute__((always_inline))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_drop</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>之所以要这样做是因为 BPF 程序的加载器、校验器、解释器和 JIT 中都缺少对函数调用的 支持。从 Linux 4.16 和 LLVM 6.0 开始，这个限制得到了解决，BPF 程序不再需 要到处使用 always_inline 声明了。因此，上面的代码可以更自然地重写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME)                  \</span></span><br><span class="line">   __attribute__((section(NAME), used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">&quot;prog&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_drop</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>BPF 到 BPF 调用是一个重要的性能优化，极大减小了生成的 BPF 代码大小，因此对 CPU 指令缓存更友好。<br><strong>BPF 辅助函数的调用约定也适用于 BPF 函数间调用，这意味着r1到r5是用来向被调用方传递参数的，<code>结果在r0中返回</code>。</strong><br>r1 - r5 是 暂存寄存器(scratch registers)，r6 - r9 像往常一样是保留寄存器。最大嵌套调用深度是 8。调用方可以传递指针（例如，指向调用方的栈帧的指针） 给被调用方，但反过来不行。</p><p><s>当前，BPF 函数间调用和 BPF 尾调用是不兼容的，因为后者需要复用当前的栈设置（ stack setup），而前者会增加一个额外的栈帧，因此不符合尾调用期望的布局。</s></p><p>BPF JIT 编译器为每个函数体发出单独的镜像，随后在最后的 JIT 处理（final JIT pass）中再修改镜像中函数调用的地址 。事实证明，这种方式需要对 JIT 做最少的改动，因为它们可以将BPF到BPF的调用当作传统的BPF辅助调用。</p><p>直到kernel5.9，BPF 函数间调用和 BPF 尾调用是不兼容的。利用尾调用的BPF程序不能获得减少程序映像大小和更快加载时间的好处。Linux Kernel 5.10 终于允许用户两全其美，并增加了将BPF子程序与尾调用相结合的能力。</p><p>不过，这种改进也有一些限制。混合使用这两种特性可能会导致内核堆栈溢出。为了了解可能发生的情况，请看下面的图片，说明了bpf2bpf调用和尾部调用的组合：<br><img src="/jony.github.io/images/bpf_tailcall_subprograms.png" alt="bpf_tailcall_subprograms.png"></p><p>尾调用，在实际跳转到目标程序之前，只会释放其当前的栈帧。在上面的例子中我们可以看到，如果从子函数内部发生尾部调用，当程序执行到func2时，函数（func1）的栈帧将存在于栈中。一旦最后一个函数（func3）函数终止，之前所有的栈帧将被释放，控制权将回到BPF程序的调用者手中。</p><p>内核引入了额外的逻辑来检测这种功能组合。对整个调用链的堆栈大小有一个限制，每个子程序的最大为256字节（注意，如果验证器检测到bpf2bpf调用，那么主函数也会被当作一个子函数）。总的来说，在这种限制下，bpf程序的调用链最多可以消耗8KB的栈空间。这个限制来自于每个栈帧256字节乘以尾部调用次数限制(32)。如果没有这个限制，BPF程序将在512字节的堆栈大小上运行，产生的尾部调用的最大计数总计为16KB，这将在某些架构上溢出堆栈。</p><p>还要提到的一点是，目前仅在x86-64架构上支持此特性组合。</p><hr><h1>1.7 JIT</h1><p><img src="/jony.github.io/images/bpf_jit.png" alt="bpf_jit.png"></p><p>64 位的 x86_64、arm64、ppc64、s390x、mips64、sparc64 和 32 位的 arm 、x86_32 架构都内置了 in-kernel eBPF JIT 编译器，它们的功能都是一样的，可 以用如下方式打开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /proc/sys/net/core/bpf_jit_enable</span><br></pre></td></tr></table></figure><p>32 位的 mips、ppc 和 sparc 架构目前内置的是一个 cBPF JIT 编译器。这些只有 cBPF JIT 编译器的架构，以及那些甚至完全没有 BPF JIT 编译器的架构，需要通过内核中的解释器（in-kernel interpreter）执行 eBPF 程序。</p><p>要判断哪些平台支持 eBPF JIT，可以在内核源文件中 grep HAVE_EBPF_JIT：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git grep HAVE_EBPF_JIT arch/</span><br><span class="line">arch/arm/Kconfig:       select HAVE_EBPF_JIT   <span class="keyword">if</span> !CPU_ENDIAN_BE32</span><br><span class="line">arch/arm64/Kconfig:     select HAVE_EBPF_JIT</span><br><span class="line">arch/powerpc/Kconfig:   select HAVE_EBPF_JIT   <span class="keyword">if</span> PPC64</span><br><span class="line">arch/mips/Kconfig:      select HAVE_EBPF_JIT   <span class="keyword">if</span> (64BIT &amp;&amp; !CPU_MICROMIPS)</span><br><span class="line">arch/s390/Kconfig:      select HAVE_EBPF_JIT   <span class="keyword">if</span> PACK_STACK &amp;&amp; HAVE_MARCH_Z196_FEATURES</span><br><span class="line">arch/sparc/Kconfig:     select HAVE_EBPF_JIT   <span class="keyword">if</span> SPARC64</span><br><span class="line">arch/x86/Kconfig:       select HAVE_EBPF_JIT   <span class="keyword">if</span> X86_64</span><br></pre></td></tr></table></figure><p>JIT 编译器可以极大加速 BPF 程序的执行，因为与解释器相比，它们可以降低每个指令的 开销（reduce the per instruction cost）。通常，指令可以 1:1 映射到底层架构的原生 指令。另外，这也会减少生成的可执行镜像的大小，因此对 CPU 的指令缓存更友好。特别 地，对于 CISC 指令集（例如 x86），JIT 做了很多特殊优化，目的是为给定的指令产生 可能的最短操作码（emitting the shortest possible opcodes），以降低程序翻译过程所 需的空间。</p><hr><h1>1.8 Hardening</h1><p>为了避免代码被损坏，BPF 会在程序的生命周期内，在内核中将 BPF 解释器解释后的整个镜像（struct bpf_prog）和 JIT 编译之后的镜像（struct bpf_binary_header）锁定为只读的（read-only）。在这些位置发生的任何数据损坏（例 如由于某些内核 bug 导致的）会触发通用的保护机制，因此会造成内核崩溃（crash）而不是允许损坏静默地发生。</p><p>查看哪些平台支持将镜像内存（image memory）设置为只读的，可以通过下面的搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git grep ARCH_HAS_SET_MEMORY | grep select</span><br><span class="line">arch/arm/Kconfig:    select ARCH_HAS_SET_MEMORY</span><br><span class="line">arch/arm64/Kconfig:  select ARCH_HAS_SET_MEMORY</span><br><span class="line">arch/s390/Kconfig:   select ARCH_HAS_SET_MEMORY</span><br><span class="line">arch/x86/Kconfig:    select ARCH_HAS_SET_MEMORY</span><br></pre></td></tr></table></figure><p><code>CONFIG_ARCH_HAS_SET_MEMORY</code> 选项是不可配置的，因此平台要么内置支持，要么不支持 。那些目前还不支持的架构未来可能也会支持。</p><p>对于 <code>x86_64</code> JIT 编译器，如果设置了 <code>CONFIG_RETPOLINE</code>，尾调用的间接跳转就会用 retpoline 实现。写作本文时，在大部分现代 Linux 发行版上 这个配置都是打开的。</p><p>将 <code>/proc/sys/net/core/bpf_jit_harden</code> 设置为 <code>1</code> 会为非特权用户的 JIT 编译做一些额外的强化工作。这些额外强化会稍微降低程序 的性能，但在有非受信用户在系统上进行操作的情况下，能够有效地减小（潜在的）受攻击 面。但与完全切换到解释器相比，这些性能损失还是比较小的。</p><p>当前，启用 hardening 会在 JIT 编译时 <strong>模糊（blind）</strong> BPF 程序中用户提供的所有 32 位和 64 位常量，以防御 JIT spraying（喷射）攻击，这些攻击会将原生操作码（native opcodes）作为立即数（immediate values）注入到内核。这种攻击有效是因为： <strong>立即数</strong> 驻留在可执行内核内存（executable kernel memory）中，因此某些内核 bug 可能会触 发一个跳转动作，如果跳转到立即数的开始位置，就会把它们当做原生指令开始执行。</p><p>模糊 JIT 常量通过对真实指令进行随机化实现 。在这种方式中，通过对指令进行重写，将原来基于 <strong>立即数</strong> 的操作转换成基于寄存器的操作。指令重写将加载值的过程分解为两部分：</p><pre><code>1.加载一个模糊后的（blinded）立即数 rnd ^ imm 到寄存器2.将寄存器和 rnd 进行异或操作（xor）</code></pre><p>这样原始的 imm 立即数就驻留在寄存器中，可以用于真实的操作了。这里介绍的只是加载操作的模糊过程，实际上所有的通用操作都被模糊了。</p><p>下面是强化关闭的情况下，某个程序的 JIT 编译结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="number">0</span> &gt; /proc/sys/net/core/bpf_jit_harden</span><br><span class="line"></span><br><span class="line">  ffffffffa034f5e9 + &lt;x&gt;:</span><br><span class="line">  [...]</span><br><span class="line">  <span class="number">39</span>:   mov    $<span class="number">0xa8909090</span>,%eax</span><br><span class="line">  <span class="number">3</span>e:   mov    $<span class="number">0xa8909090</span>,%eax</span><br><span class="line">  <span class="number">43</span>:   mov    $<span class="number">0xa8ff3148</span>,%eax</span><br><span class="line">  <span class="number">48</span>:   mov    $<span class="number">0xa89081b4</span>,%eax</span><br><span class="line">  <span class="number">4</span>d:   mov    $<span class="number">0xa8900bb0</span>,%eax</span><br><span class="line">  <span class="number">52</span>:   mov    $<span class="number">0xa810e0c1</span>,%eax</span><br><span class="line">  <span class="number">57</span>:   mov    $<span class="number">0xa8908eb4</span>,%eax</span><br><span class="line">  <span class="number">5</span>c:   mov    $<span class="number">0xa89020b0</span>,%eax</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure><p>强化打开之后，以上程序被某个非特权用户通过 BPF 加载的结果（这里已经进行了常量模糊）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="number">1</span> &gt; /proc/sys/net/core/bpf_jit_harden</span><br><span class="line"></span><br><span class="line">  ffffffffa034f1e5 + &lt;x&gt;:</span><br><span class="line">  [...]</span><br><span class="line">  <span class="number">39</span>:   mov    $<span class="number">0xe1192563</span>,%r10d</span><br><span class="line">  <span class="number">3f</span>:   <span class="keyword">xor</span>    $<span class="number">0x4989b5f3</span>,%r10d</span><br><span class="line">  <span class="number">46</span>:   mov    %r10d,%eax</span><br><span class="line">  <span class="number">49</span>:   mov    $<span class="number">0xb8296d93</span>,%r10d</span><br><span class="line">  <span class="number">4f</span>:   <span class="keyword">xor</span>    $<span class="number">0x10b9fd03</span>,%r10d</span><br><span class="line">  <span class="number">56</span>:   mov    %r10d,%eax</span><br><span class="line">  <span class="number">59</span>:   mov    $<span class="number">0x8c381146</span>,%r10d</span><br><span class="line">  <span class="number">5f</span>:   <span class="keyword">xor</span>    $<span class="number">0x24c7200e</span>,%r10d</span><br><span class="line">  <span class="number">66</span>:   mov    %r10d,%eax</span><br><span class="line">  <span class="number">69</span>:   mov    $<span class="number">0xeb2a830e</span>,%r10d</span><br><span class="line">  <span class="number">6f</span>:   <span class="keyword">xor</span>    $<span class="number">0x43ba02ba</span>,%r10d</span><br><span class="line">  <span class="number">76</span>:   mov    %r10d,%eax</span><br><span class="line">  <span class="number">79</span>:   mov    $<span class="number">0xd9730af</span>,%r10d</span><br><span class="line">  <span class="number">7f</span>:   <span class="keyword">xor</span>    $<span class="number">0xa5073b1f</span>,%r10d</span><br><span class="line">  <span class="number">86</span>:   mov    %r10d,%eax</span><br><span class="line">  <span class="number">89</span>:   mov    $<span class="number">0x9a45662b</span>,%r10d</span><br><span class="line">  <span class="number">8f</span>:   <span class="keyword">xor</span>    $<span class="number">0x325586ea</span>,%r10d</span><br><span class="line">  <span class="number">96</span>:   mov    %r10d,%eax</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure><p>两个程序在语义上是一样的，但在第二种方式中，原来的立即数在反汇编之后的程序中不再 可见。</p><p>同时，强化还会禁止任何 JIT 内核符合（kallsyms）暴露给特权用户，JIT 镜像地址不再 出现在 /proc/kallsyms 中。</p><p>另外，Linux 内核提供了 CONFIG_BPF_JIT_ALWAYS_ON 选项，打开这个开关后 BPF 解释器将会从内核中完全移除，永远启用 JIT 编译器。此功能部分是为防御 Spectre v2 攻击开发的，如果应用在一个基于虚拟机的环境，客户机内核（guest kernel）将不会复用 内核的 BPF 解释器，因此可以避免某些相关的攻击。如果是基于容器的环境，这个配置是可选的，如果 JIT 功能打开了，解释器仍然可能会在编译时被去掉，以降低内核的复杂度 。因此，对于主流架构（例如 x86_64 和 arm64）上的 JIT 通常都建议打开这个开关 。</p><p>另外，内核提供了一个配置项 /proc/sys/kernel/unprivileged_bpf_disabled 来禁止非 特权用户使用 bpf(2) 系统调用，可以通过 sysctl 命令修改。 比较特殊的一点是，这个配置项特意设计为“一次性开关”（one-time kill switch）， 这意味着一旦将它设为 1，就没有办法再改为 0 了，除非重启内核。一旦设置为 1 之后，只有初始命名空间中有 CAP_SYS_ADMIN 特权的进程才可以调用 bpf(2) 系统调用 。 Cilium 启动后也会将这个配置项设为 1：</p><h2 id="code￼8"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled</span><br></pre></td></tr></table></figure></h2><h1>1.9 Offloads</h1><p><img src="/jony.github.io/images/bpf_offload.png" alt="bpf_offload.png"></p><p>BPF 网络程序，尤其是 tc 和 XDP BPF 程序在内核中都有一个 offload 到硬件的接口，这 样就可以直接在网卡上执行 BPF 程序。</p><p>当前，Netronome 公司的 nfp 驱动支持通过 JIT 编译器 offload BPF，它会将 BPF 指令 翻译成网卡实现的指令集。另外，它还支持将 BPF maps offload 到网卡，因此 offloaded BPF 程序可以执行 map 查找、更新和删除操作。</p><h1>文档连接</h1><p><a href="https://www.dazhuanlan.com/2019/12/10/5dee76b007da0/">Linux BPF 3.2、BPF and XDP Reference Guide</a><br><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_instruction">[译] Cilium：BPF 和 XDP 参考指南（2019）</a><br><a href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">BPF 辅助函数</a><br><a href="https://man7.org/linux/man-pages/man2/bpf.2.html">BPF man 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eBPF 相关文档阅读笔记</title>
      <link href="/jony.github.io/b6c56cf840fb/"/>
      <url>/jony.github.io/b6c56cf840fb/</url>
      
        <content type="html"><![CDATA[<p>BPF 是 <strong>Linux 内核中</strong> 一个高度灵活与高效的<strong>类虚拟机（<code>virtual machine-like</code>）</strong> 组件，它以一种安全的方式在许多 hook 点执行字节码（bytecode ）。很多 <strong>内核子系统</strong> 都已经使用了 BPF，比如常见的<strong>网络（networking）</strong>、<strong>跟踪（tracing）<strong>与</strong>安全 （security ，例如沙盒）</strong>。<br><strong>BPF（cBPF）</strong> 1992 年就出现了，但本文介绍的是<strong>扩展的 BPF（extended Berkeley Packet Filter，eBPF</strong>）。eBPF 最早出现在 3.18 内核中，此后原来的 BPF 就被称为 <strong>“经典” BPF（classic BPF, cBPF）</strong>，cBPF 现在基本已经废弃了。</p><h1>1.1 指令集</h1><hr><p>BPF 是一个通用目的 RISC 指令集，其最初的设计目标是：用 C 语言的一个子集编 写程序，然后用一个编译器后端（例如 LLVM）将其 <strong>编译</strong> 成 BPF 指令，然后内核再通 过一个位于内核中的（in-kernel）<strong>即时编译器（JIT Compiler）</strong> 将 BPF 指令映射成处 理器的 <strong>原生指令（opcode ）</strong> ，以取得在内核中的最佳执行性能。<br>将这些指令下放到内核中可以带来如下好处：</p><ul><li><p><strong>无需在内核/用户空间切换就可以实现内核的可编程。</strong></p></li><li><p><strong>可编程 datapath 具有很大的灵活性，因此程序能在编译时将不需要的特性禁用掉， 从而极大地优化程序的性能。</strong></p></li><li><p>对于网络场景（例如 tc 和 XDP），BPF 程序可以在 <strong>无需重启内核、系统服务或容器的 情况下实现原子更新，并且不会导致网络中断</strong>。</p></li><li><p>BPF 给用户空间 <strong>提供了一个稳定的 ABI</strong>，而且<strong>不依赖</strong>任何第三方内核模块。</p></li><li><p>BPF 程序与内核协同工作，复用已有的内核基础设施和工具以及内核提供的安全保证。</p><h1>注意</h1><p><strong>BPF 程序在内核中的执行总是事件驱动的</strong></p></li></ul><hr><p>BPF 组成部分：</p><ul><li><p>11 个64位寄存器<br>寄存器从 <strong><code>r0-r10</code></strong> 。默认运行 64 位，兼容 32 位。</p><ul><li><code>r10</code> 是唯一的只读寄存器。</li><li><code>r1 - r5</code> 存储 BPF 调用内核辅助函数是传递的参数</li><li><code>r6 - r9</code> 由 <strong>被调用方（callee）保存</strong>，在函数返回之后<strong>调用方</strong>可以读取</li><li><code>r0</code>  存放被调用的 <strong>辅助函数</strong> 的返回值。注：辅助函数概念参考下面解释</li></ul></li><li><p>一个程序计数器（Program Counter，PC）</p></li><li><p>一个 512 字节大小的 BPF 栈空间</p><h1>注意</h1><ul><li>每个 BPF 程序的最大指令数限制在 4096 条以内。</li><li>BPF 校验器禁止 程序中有循环</li><li>BPF 中有尾调用的概念，允许一 个 BPF 程序调用另一个 BPF 程序。限制 32 层。</li><li>BUG：可以使用尾调用实现循环概念</li></ul></li></ul><hr><h1>指令格式</h1><p>BPF 指令格式（instruction format）建模为两操作数指令（two operand instructions）， 这种格式可以在 JIT 阶段将 BPF 指令映射（mapping）为原生指令。</p><ul><li>指令集长度固定为 64 bit 编码</li><li>目前已经实现 87 条指令，并且可扩展</li></ul><p>指令格式：<strong><code>op:8, dst_reg:4, src_reg:4, off:16, imm:32</code></strong></p><ul><li><p><strong><code>op</code></strong>：指定将要执行的操作。操作可以基于寄存器，也可以基于立即数。</p><h3 id="op-指令分类（MSB（高比特）-到-LSB（最低比特））：">op 指令分类（<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%AB%98%E6%9C%89%E6%95%88%E4%BD%8D">MSB</a>（高比特） 到 <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D">LSB</a>（最低比特））：</h3><ul><li><code>class</code>：指令类型</li><li><code>code</code>：指定类型的指令中的某种特定操作码</li><li><code>source</code>：告诉源操作数是一个寄存器还是一个立即数</li></ul><h3 id="指令类别包括：">指令类别包括：</h3><ul><li>BPF_LD, BPF_LDX：加载操作（load operations）</li><li>BPF_ST, BPF_STX：存储操作（store operations）</li><li>BPF_ALU, BPF_ALU64：逻辑运算操作（ALU operations）</li><li>BPF_JMP：跳转操作（jump operations）</li></ul></li><li><p><strong><code>dst_reg</code></strong> 和 <strong><code>src_reg</code></strong>：提供了一个寄存器操作数的额外信息</p></li><li><p><strong><code>off</code></strong>: 有符号类型。编码信息定义在内核头文件中 <code>linux/bpf.h</code> 和 <code>linux/bpf_common.h</code> 中</p><ul><li>某些指令中，off 用于表示一个相对偏移量（offset）</li></ul></li><li><p><strong><code>imm</code></strong>: 有符号类型。编码信息定义在内核头文件中 <code>linux/bpf.h</code> 和 <code>linux/bpf_common.h</code> 中</p><ul><li>某些指令中，imm 存储一个常量值或者立即值</li></ul><p>所有的 BPF 操作，例如加载程序到内核，或者创建 BPF map，都是通过核心的 bpf() 系 统调用完成的。它还用于管理 map 表项（查找/更新/删除），以及通过 pinning（钉住 ）将程序和 map 持久化到 BPF 文件系统。</p></li></ul><h1>辅助函数、BPF Maps、Object Pinning</h1><p>问题，Process 通过文件描述符访问 BFP Maps ，是否需要经过系统调用，还是 Direct Memory，</p><h1>参考文档</h1><p><a href="https://www.kernel.org/doc/html/latest/bpf/bpf_devel_QA.html">官方文档如何与BPF子系统交互</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">bpf-helpers</a><br><a href="https://www.kernel.org/doc/html/latest/bpf/bpf_design_QA.html#questions-and-answers">bpf常见的设计问题</a><br><a href="http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/#bpf_arch">[译] Cilium：BPF 和 XDP 参考指南（2019）</a><br><a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git">bpf 内核源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. eBPF 基本了解和入门</title>
      <link href="/jony.github.io/9a44115ea383/"/>
      <url>/jony.github.io/9a44115ea383/</url>
      
        <content type="html"><![CDATA[<p>eBPF 的 <strong><code>e</code></strong> 就是 extended 的缩写。所以 eBPF 就是，BPF 字节码过滤器的增强版。</p><p>学习建议方式</p><ul><li>初学会用 <code>bcc</code> 工具</li><li>中级会用 <code>bpftrace</code> 开发</li><li>高级开发  <code>bcc</code> 工具，并贡献</li></ul><p>Ubuntu 安装 bcc ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bpfcc-tools linux-headers-$(uname -r)</span><br></pre></td></tr></table></figure><p>其他系统安装 bcc 参考：<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary">https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu—binary</a></p><p>手动抄一个 bcc 的 Hello World</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Copyright (c) PLUMgrid, Inc.</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run in project examples directory with:</span></span><br><span class="line"><span class="comment"># sudo ./hello_world.py&quot;</span></span><br><span class="line"><span class="comment"># see trace_fields.py for a longer example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># This may not work for 4.17 on x64, you need replace kprobe__sys_clone with kprobe____x64_sys_clone</span></span><br><span class="line">BPF(text=<span class="string">&#x27;int kprobe__sys_clone(void *ctx) &#123; bpf_trace_printk(&quot;Hello, World!\\n&quot;); return 0; &#125;&#x27;</span>).trace_print()</span><br></pre></td></tr></table></figure><p>成功运行，输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b&#39; IPDL Background-5703    [003] ....  5087.572783: 0: Hello, World!&#39;</span><br><span class="line">b&#39;     Web Content-13466   [003] ....  5087.634894: 0: Hello, World!&#39;</span><br><span class="line">b&#39; gnome-session-b-1181    [000] ....  5128.625994: 0: Hello, World!&#39;</span><br><span class="line">b&#39;           Timer-5685    [000] ....  5140.509352: 0: Hello, World!&#39;</span><br><span class="line">b&#39; IPDL Background-5703    [003] ....  5140.966663: 0: Hello, World!&#39;</span><br><span class="line">b&#39; Privileged Cont-5797    [001] ....  5140.968354: 0: Hello, World!&#39;</span><br></pre></td></tr></table></figure><p>在抄一个最关心的 network：<a href="https://github.com/iovisor/bcc/blob/master/examples/networking/http_filter/http-parse-simple.py">http-parse-simple.py</a></p><h1>目录</h1><ul><li><a href="/jony.github.io/9a44115ea383/">1. eBPF 基本了解和入门</a></li><li><a href="/jony.github.io/6b9c54247f6f/">2. eBPF 翻译文档合集</a></li><li><a href="/jony.github.io/e83139ad9bf1/">3. eBPF 工具链</a></li><li><a href="/jony.github.io/3006e0a225f3/">4. C BPF 编程规范</a></li><li><a href="/jony.github.io/ada1626fa032/">5. iproute2</a></li><li><a href="/jony.github.io/4b2ecddadcc3/">6. Program_Types</a></li><li><a href="/jony.github.io/99a44d212429/">7. eBPF 应用案例</a></li></ul><p>扩展阅读</p><ul><li><a href="/jony.github.io/6ee15c371963/">流量控制：令牌和桶算法</a></li></ul><h1>参考文档</h1><p><a href="https://www.kernel.org/doc/html/latest/bpf/bpf_devel_QA.html">官方文档如何与BPF子系统交互</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">bpf-helpers</a><br><a href="https://www.kernel.org/doc/html/latest/bpf/bpf_design_QA.html#questions-and-answers">bpf常见的设计问题</a><br><a href="http://sniffer.site/2019/11/07/BPF%E4%B8%8EeBPF/">BPF与eBPF</a><br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html#NAME">bpf-helpers(7) — Linux manual page</a><br><a href="https://www.cnblogs.com/charlieroro/p/13403672.html">全面介绍eBPF-概念</a></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
          <category> 导航 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Submission</title>
      <link href="/jony.github.io/b74dca1de80f/"/>
      <url>/jony.github.io/b74dca1de80f/</url>
      
        <content type="html"><![CDATA[<h1>介绍</h1><p>提交I/O请求的顺序通常是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取一个 SQE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line"><span class="comment">/* 设置一个 readv 操作 */</span></span><br><span class="line">io_uring_prep_readv(sqe, file_fd, fi-&gt;iovecs, blocks, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 设置用户数据 */</span></span><br><span class="line">io_uring_sqe_set_data(sqe, fi);</span><br><span class="line"><span class="comment">/* 最后提交请i去 */</span></span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure><p>上面的代码使用的是：<a href="https://unixism.net/loti/tutorial/cat_liburing.html#cat-liburing">cat 使用 liburing 实现</a></p><p>你调用 <strong>io_ring_get_sqe()</strong> 来获取一个提交队列条目或SQE，使用一个提交辅助器来处理你想要完成的I/O类型，比如 <strong>io_uring_prep_readv()</strong> 或 <strong>io_uring_prep_accept()</strong>。调用 <strong>io_uring_set_sqe_data()</strong> 以获取指向唯一标识该请求的数据结构的指针(在完成端获得相同的用户数据)，最后调用io_uring_submit()提交请求。</p><p>TODO：您还可以设置轮询以避免调用 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a></strong> 系统调用。</p><hr><p>struct io_uring_sqe <strong>*io_uring_get_sqe</strong>(struct 【io_uring](<a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring</a>) *ring)</p><blockquote><p>这个函数返回一个提交队列条目，可以用来提交一个I/O操作。在调用<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a>提交内核处理你的请求队列之前，你可以多次调用这个函数来提交I/O请求队列。</p><p><strong>参数</strong></p><ul><li>ring:  <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a> 设置的 <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">uring</a> 结构</li></ul><p>返回值： 一个指向 <strong>io_uring_sqe</strong> 的指针，表示一个空的SQE。如果提交队列已满，则返回NULL。</p><p>请看<a href="https://unixism.net/loti/ref-liburing/submission.html#submission-intro-snippet">提交介绍代码片段</a>的使用实例。</p><h1>参考</h1><ul><li><a href="https://unixism.net/loti/low_level.html#low-level">io_uring 底层接口编程</a></li><li><a href="https://unixism.net/loti/tutorial/cp_liburing.html#cp-liburing">cp 使用 liburing 实现</a></li></ul></blockquote><hr><p>void <strong>io_uring_sqe_set_data</strong>(<em>struct</em> io_uring_sqe *sqe, void *data)<br>这是一个内联方便函数，用于设置传入的SQE实例的用户数据字段。</p><blockquote><p><strong>参数</strong></p><ul><li>SQE：要为其设置用户数据的SQE实例。</li><li>data：一个指向用户数据的指针</li></ul></blockquote><hr><p>void <strong>io_uring_sqe_set_flags</strong>(<em>struct</em> io_uring_sqe *sqe, unsigned flags)<br>这是一个内联方便函数，用于设置传入的SQE实例的 flags 字段。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe: 要为其设置用户数据的SQE实例。</li><li>flags:你要设置的标志。这是个 bitmap 字段，请参见<a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#io-uring-enter">io_uring_enter</a>参考页面，了解各种SQE标志及其含义。</li></ul></blockquote><hr><p>int <strong>io_uring_submit</strong>(struct io_uring *ring)<br>将通过io_uring_get_sqe()获取的SQE提交给内核。当你多次调用io_uring_get_sqe()来设置多个I/O请求后，你可以调用一次。</p><blockquote><p><strong>参数</strong></p><ul><li>ring：<a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a> 设置的 <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">uring</a> 结构</li></ul><p><strong>返回值</strong>：返回提交的sqe数量。</p><h1>参考</h1><ul><li><a href="https://unixism.net/loti/low_level.html#low-level">io_uring 底层接口编程</a></li><li><a href="https://unixism.net/loti/tutorial/cp_liburing.html#cp-liburing">cp 使用 liburing 实现</a></li></ul></blockquote><hr><p>int <strong>io_uring_submit_and_wait</strong>(struct io_uring *ring, unsigned wait_nr)<br>和**io_uring_submit()**一样，但是需要一个额外的参数wait_nr，让你指定要等待多少个完成。这个调用将阻塞，直到内核处理wait_nr个提交请求，并将它们的详细信息放入完成队列。</p><blockquote><p><strong>参数</strong></p><ul><li>wait_nr： 等待完成的数量。<br><strong>返回值</strong>：返回提交的sqe数量。</li></ul></blockquote><h1>Submission 辅助器</h1><p>提交辅助器是方便的函数，它可以轻松地指定你想通过SQE请求的I/O操作。每个支持的I/O类型都有一个函数。<br>关于**io_uring_prep_readv()**函数的使用实例，请参见<a href="https://unixism.net/loti/ref-liburing/submission.html#submission-intro-snippet">提交介绍代码</a>片段。</p><p>void <strong>io_uring_prep_nop</strong>(struct io_uring_sqe *sqe)<br>此函数用于设置SQE通过读取操作指向的提交队列条目。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要读取的文件描述符</li><li>buf：用于将读取数据复制到其中的缓冲区</li><li>nbytes：要读取的字节数</li><li>offset：要读取的文件的绝对偏移量</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li><li><a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_write</strong>(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset)<br>这个函数通过写操作设置sqe所指向的提交队列条目。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要读取的文件描述符</li><li>buf：用于将读取数据复制到其中的缓冲区</li><li>nbytes：要读取的字节数</li><li>offset：要读取的文件的绝对偏移量</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/write.2.html">write(2)</a></li><li><a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_readv</strong>(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned nr_vecs, off_t offset)<br>这个函数用 “scatter” 读操作设置sqe指向的提交队列条目，很像<a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a>或<a href="http://man7.org/linux/man-pages/man2/preadv.2.html">preadv(2)</a>，它们是Linux的 scatter/gather I/O 系列系统调用的一部分。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要读取的文件描述符</li><li>iovecs：指向iovec结构数组的指针</li><li>nr_vecs：由iovecs参数指向的数组中iovec实例的数目</li><li>offset：要读取的文件的绝对偏移量</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a></li><li><a href="https://unixism.net/loti/tutorial/cat_liburing.html#cat-liburing">使用liburing实现cat程序</a>示例使用了这个函数</li></ul></blockquote><hr><p>void <strong>io_uring_prep_read_fixed</strong>(struct io_uring_sqe *sqe, int fd, void *buf, unsigned nbytes, off_t offset, int buf_index)<br>与io_uring_prep_read()非常类似，该函数通过读取操作设置SQE指向的提交队列条目。主要区别在于，这个函数被设计用来处理通过io_uring_register()注册的一组固定的预分配缓冲区。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要读取的文件描述符</li><li>buf：用于将读取数据复制到其中的缓冲区</li><li>nbytes：要读取的字节数</li><li>offset：要读取的文件的绝对偏移量</li><li>buf_index：要使用的预分配缓冲区集的索引。</li></ul><h1>参考</h1><ul><li><a href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a></li><li><a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li><li><a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_writev</strong>(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned nr_vecs, off_t offset)<br>这个函数使用“gather”写操作来设置sqe所指向的提交队列条目，类似于<a href="http://man7.org/linux/man-pages/man2/writev.2.html">writev(2)</a>或<a href="http://man7.org/linux/man-pages/man2/pwritev.2.html">pwritev(2)</a>，它们是Linux的 scatter/gather I/O 系列系统调用的一部分。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要写入的文件描述符</li><li>iovecs：指向iovec结构数组的指针</li><li>nr_vecs：由iovecs参数指向的数组中iovec实例的数目</li><li>offset：要读取的文件的绝对偏移量</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/writev.2.html">writev(2)</a></li><li><a href="https://unixism.net/loti/tutorial/cat_liburing.html#cat-liburing">使用liburing实现cat程序</a>示例使用了这个函数</li></ul></blockquote><hr><p>void <strong>io_uring_prep_write_fixed</strong>(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned nbytes, off_t offset, int buf_index)<br>TODO：补丁缓冲区案例添加</p><blockquote><p>与<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a>非常类似，这个函数通过一个read操作设置sqe所指向的提交队列条目。主要区别在于，这个函数被设计用来处理通过<a href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a>注册的一组固定的预分配缓冲区。</p><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要写入的文件描述符</li><li>buf：用于将读取数据复制到其中的缓冲区</li><li>nbytes：要读取的字节数</li><li>offset：要读取的文件的绝对偏移量</li><li>buf_index：要使用的预分配缓冲区集的索引。</li></ul><h1>参考</h1><ul><li><a href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a></li><li><a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li><li><a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_fsync</strong>(struct io_uring_sqe *sqe, int fd, unsigned fsync_flags)<br>此函数使用类似fsync(2)的操作设置<code>SQE</code>指向的提交队列条目。这会导致磁盘缓存中文件数据和任何缓冲区“脏”数据都同步到磁盘。</p><blockquote><h1>注意</h1><pre><code>  请务必注意，将此操作排队并不能保证在此操作之前排队的任何写入操作都会将它们写入文件的数据同步到磁盘。这是因为提交队列中的操作可以由内核并行获取和执行。此同步操作可以在其前面排队的其他写入操作之前完成。它真正起到的作用是，在执行此操作时，文件的任何现有“脏”缓冲区数据都会同步到磁盘。</code></pre><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要读取的文件描述符</li><li>fsync_flags: 这个值可以是0，也可以是 <code>IORING_FSYNC_DATASYNC</code>，这使得它像<a href="http://man7.org/linux/man-pages/man2/fdatasync.2.html">fdatasync(2)</a>一样。</li></ul><h1>参考</h1><ul><li><a href="https://unixism.net/loti/ref-iouring/io_uring_register.html#c.io_uring_register">io_uring_register()</a></li><li><a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a></li><li><a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a></li></ul></blockquote><p>void <strong>io_uring_prep_close</strong>(struct io_uring_sqe *sqe, int fd)<br>这个函数使用类似close(2)的操作设置sqe所指向的提交队列条目。这将导致fd所指向的文件描述符被关闭。</p><blockquote><p>参数：</p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要读取的文件描述符</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/close.2.html">close(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_openat</strong>(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode)<br>此函数使用类似openat(2)的操作设置SQE指向的提交队列条目。这会导致PATH指向的文件在相对于由DFD目录文件描述符表示的目录的路径中打开。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>dfd: 目录文件描述符，代表要打开文件的相对目录。</li><li>path: 要打开的文件的路径名</li><li>flags: 标志。这些是访问模式的标志。与<a href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a>相同</li><li>mode: 模式。创建新文件时应用的文件权限位。与 <a href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a> 中的相同</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/openat.2.html">openat(2)</a></li><li><a href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_openat2</strong>(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how)<br>这个函数用类似<a href="http://man7.org/linux/man-pages/man2/openat2.2.html">openat2(2)</a>的操作来设置sqe所指向的提交队列条目。这将导致path指向的文件在相对于dfd目录文件描述符所代表的目录的路径中被打开。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>dfd: 目录文件描述符，代表要打开文件的相对目录。</li><li>path: 要打开的文件的路径名</li><li>flags: 标志。这些是访问模式的标志。与<a href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a>相同</li><li>how: 一个指向<code>open_how</code>结构的指针，该结构可以让你控制打开文件的方式。参见<a href="http://man7.org/linux/man-pages/man2/openat2.2.html">openat2(2)</a>了解更多细节。</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/openat2.2.html">openat2(2)</a></li><li><a href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_fallocate</strong>(struct io_uring_sqe *sqe, int fd, int mode, off_t offset, off_t len)<br>这个函数使用类似<a href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a>的操作设置sqe所指向的提交队列条目。<a href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a>系统调用用于为文件描述符fd表示的文件分配、释放、折叠、置零或增加文件空间。请参阅<a href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a>了解更多细节。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要读取的文件描述符</li><li>mode:描述了对文件进行的操作。详情请参见fallocate(2)。</li><li>offset：要读取的文件的绝对偏移量</li><li>len：操作长度</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/fallocate.2.html">fallocate(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_statx</strong>(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, unsigned mask, struct statx *statxbuf)<br>这个函数用类似 statx(2) 的操作设置了 sqe 所指向的提交队列条目。statx(2) 系统调用会获取 path 指向的文件的元信息，这些元信息会被填入 statxbuf 指向的 statx 结构中。详见 statx(2) 。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>dfd: 根据this和path的值，path所指向的文件可以被解释为绝对路径文件，相对于process或相对于dfd中的目录描述符引用的目录，以及其他类型的解释都是可能的。详见 <a href="http://man7.org/linux/man-pages/man2/statx.2.html">statx(2)。</a></li><li>path: 文件路径。结合dfd中的值进行解释。详见statx（2）</li><li>flags：这用来影响路径名的查询方式，也可以影响内核在查询远程文件系统上的文件时做什么样的同步。详见 <a href="http://man7.org/linux/man-pages/man2/statx.2.html">statx(2) 。</a></li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/statx.2.html">statx(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_fadvise</strong>(struct io_uring_sqe *sqe, int fd, off_t offset, off_t len, int advice)<br>此函数使用类似<a href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a>的操作用于设置SQE指向的提交队列条目。<a href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a>系统调用允许应用程序通知操作系统它计划如何访问由文件描述符FD表示的文件中的数据-顺序、随机或其他方式。这是为了提高应用程序的性能。有关更多详细信息，请参见<a href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a>。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd：要提供 advise 文件的文件描述符</li><li>offset：应用 advise 文件的偏移量</li><li>len：advise 文件的长度</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html">posix_fadvise(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_madvise</strong>(struct io_uring_sqe *sqe, void *addr, off_t length, int advice)<br>这个函数使用类似于<a href="http://man7.org/linux/man-pages/man2/madvise.2.html">madvise(2)</a>的操作设置sqe所指向的提交队列条目。<a href="http://man7.org/linux/man-pages/man2/madvise.2.html">madvise(2)</a>系统调用让应用程序就addr所指向的内存(长度为字节)通知操作系统。建议包括:应用程序计划如何访问该范围内的内存(顺序、随机或其他方式)，或者当进程产生子进程时，操作系统是否不应该共享该范围内的内存等等。这样做的目的是提高应用程序的性能。详情请参见mdavise(2)。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>addr：advice应用的内存范围的起始地址。</li><li>len： advice 的长度</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/madvise.2.html">madvise(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_splice</strong>(struct io_uring_sqe *sqe, int fd_in, loff_t off_in, int fd_out, loff_t off_out, unsigned int nbytes, unsigned int splice_flags)<br>这个函数用类似[splice(2)的操作来设置<code>sqe</code>所指向的提交队列条目。<a href="">splice(2)系统调用在两个文件描述符(<code>fd_in</code>和<code>fd_out</code>)</a>之间复制数据，而不在内核地址空间和用户地址空间之间复制数据。然而，其中一个文件描述符必须代表一个管道。详见 <a href="">splice(2) 。</a></p><blockquote><p><strong>参数</strong></p><ul><li><p>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</p></li><li><p><code>fd_in</code>：要读取文件的描述符</p></li><li><p><code>off_in</code>：如果<code>fd_in</code>是指一个管道，则必须为NULL。如果<code>fd_in</code>不是一个管道，且：</p><ul><li><code>off_in</code>为NULL，则从<code>fd_in</code>的文件偏移量中读取数据，并相应调整文件偏移量。</li><li><code>off_in</code>是非NULL，那么<code>off_in</code>必须指向一个缓冲区，这个缓冲区指定了从<code>fd_in</code>读取字节的起始偏移量。在这种情况下，<code>fd_in</code>的文件偏移量是不变的。</li></ul></li><li><p><code>fd_out</code> 和 <code>off_out</code>： 类似于<code>fd_in</code>和<code>off_in</code>的语句适用于这些参数。</p></li><li><p>nbytes：要 copy 的字节数量</p></li><li><p>flags： 影响复制的位掩码。详见 <a href="">splice(2)。</a></p></li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/splice.2.html">splice(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_recvmsg</strong>(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned flags)<br>这个函数用类似splice(2)的操作来设置sqe所指向的提交队列条目。splice(2)系统调用在两个文件描述符(fd_in和fd_out)之间复制数据，而不在内核地址空间和用户地址空间之间复制数据。然而，其中一个文件描述符必须代表一个管道。详见 splice(2) 。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd:要读取的socket。</li><li>msg:指向msghdr结构体的指针。</li><li>flag:影响读取的位掩码。详见recvmsg(2)。</li></ul><h1>参考</h1><ul><li>recvmsg(2)</li></ul></blockquote><hr><p>void <strong>io_uring_prep_sendmsg</strong>(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned flags)<br>与io_uring_prep_recvmsg()相同，但用于写入套接字。</p><blockquote><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/sendmsg.2.html">sendmsg(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_recv</strong>(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)<br>这个函数使用类似<a href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>的操作设置sqe所指向的提交队列条目。<a href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>系统调用用于从套接字读取数据。它使用<code>msghdr</code>结构来减少参数的数量。此调用同时适用于面向连接(如TCP)和无连接(如UDP)套接字。如果没有<code>flags</code>参数，它完全等同于read(2)，除了在处理长度为零数据报时有一个小区别。请参阅<a href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>了解更多细节。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd:要读取的socket。</li><li>buf：指向读取数据的缓冲区的指针</li><li>len：要读取的字节数</li><li>flags：影响读取的位掩码。请参见 <a href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a></li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a></li></ul></blockquote><hr><p>void io_uring_prep_send(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags)<br>与<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_recv">io_uring_prep_recv()</a>相同，但用于写入套接字。</p><blockquote><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/send.2.html">send(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_accept</strong>(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)<br>这个函数使用类似于[accept4(2)的操作设置sqe所指向的提交队列条目。<a href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)系统调用与面向连接的套接字类型(SOCK_STREAM, SOCK_SEQPACKE</a>T)一起使用。它为侦听套接字fd提取挂起连接队列上的第一个连接请求。当flags参数设置为0时，[accept4(2)就相当于accept(2)。请参阅<a href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)了解更多细</a>节。</p><blockquote><h1>参数</h1><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd:要监听的socket。</li><li>addr：指向sockaddr结构的指针。这将由对等方的地址填充</li><li>addrlen：socklen_t指针。value-result参数，必须用调用的sockaddr结构的大小填充，并将其设置为对等地址的大小。</li><li>flags：影响系统调用的位掩码。详见 <a href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)</a> 。</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/accept4.2.html">accept4(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_connect</strong>(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t addrlen)<br>这个函数通过类似<a href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>的操作设置sqe所指向的提交队列条目。<a href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>系统调用用于将fd中引用的套接字连接到addr中指定的地址。请参阅<a href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>了解更多细节。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd:要监听的socket。</li><li>addr：指向sockaddr结构的指针。这将由对等方的地址填充</li><li>addrlen：socklen_t指针。value-result参数，必须用调用的sockaddr结构的大小填充，并将其设置为对等地址的大小。</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_epoll_ctl</strong>(struct io_uring_sqe *sqe, int epfd, int fd, int op, struct epoll_event *ev)<br>这个函数使用类似于<a href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a>的操作设置sqe所指向的提交队列条目。<a href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a>系统调用用于在epfd引用的<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>实例的列表中添加或删除修改条目。op指定的添加、删除或修改操作应用于文件描述符fd。请参阅<a href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a>了解更多细节。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>epfd：文件描述符表和epoll实例。</li><li>fd:要添加、删除或修改的文件描述符。</li><li>op: 要执行的epoll操作(EPOLL_CTL_ADD、EPOLL_CTL_DEL或EPOLL_CTL_MOD)</li><li>ev: 指向epoll_event结构的指针</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">epoll_ctl(2)</a></li><li><a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_poll_add</strong>(struct io_uring_sqe *sqe, int fd, short poll_mask)<br>这个函数使用类似 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> 操作设置sqe所指向的提交队列条目，将文件描述符添加到poll的列表，并侦听poll_mask中指定的事件。与不带EPOLLONESHOT的poll或epoll不同，此接口始终以单次模式工作。也就是说，一旦轮询操作完成，就必须重新提交它。参见<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>了解更多细节。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>fd:用于轮询事件的文件描述符。</li><li>poll_mask: 包含要侦听的事件的位掩码</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a></li></ul></blockquote><hr><p>void <strong>io_uring_prep_poll_remove</strong>(struct io_uring_sqe *sqe, void *user_data)<br>从通过<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>监视请求中删除。</p><blockquote><p><strong>参数</strong></p><ul><li>sqe：SQE的指针，通常由<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a>返回。</li><li>user_data:用户数据指针。与此用户数据关联的请求将从进一步的监视中删除。</li></ul><h1>参考</h1><ul><li><a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置和删除</title>
      <link href="/jony.github.io/50174ef713ea/"/>
      <url>/jony.github.io/50174ef713ea/</url>
      
        <content type="html"><![CDATA[<p>本节将介绍一些函数，帮助您在程序中设置和删除io_uring。</p><p><em>struct</em> <strong>io_uring</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> <span class="title">sq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cq</span> <span class="title">cq</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ring_fd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TODO：下面两个结构真的是必需的吗?如果它们只在内部使用，请删除它们。</p><p><em>struct</em> <strong>io_uring_sq</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> *khead;</span><br><span class="line">    <span class="keyword">unsigned</span> *ktail;</span><br><span class="line">    <span class="keyword">unsigned</span> *kring_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> *kring_entries;</span><br><span class="line">    <span class="keyword">unsigned</span> *kflags;</span><br><span class="line">    <span class="keyword">unsigned</span> *kdropped;</span><br><span class="line">    <span class="keyword">unsigned</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> sqe_head;</span><br><span class="line">    <span class="keyword">unsigned</span> sqe_tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> ring_sz;</span><br><span class="line">    <span class="keyword">void</span> *ring_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><em>struct</em> <strong>io_uring_cq</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cq</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> *khead;</span><br><span class="line">    <span class="keyword">unsigned</span> *ktail;</span><br><span class="line">    <span class="keyword">unsigned</span> *kring_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> *kring_entries;</span><br><span class="line">    <span class="keyword">unsigned</span> *koverflow;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqes</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> ring_sz;</span><br><span class="line">    <span class="keyword">void</span> *ring_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>int <strong>io_uring_queue_init</strong>(unsigned <em>entries</em>, struct <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">io_uring</a> *ring, unsigned <em>flags</em>)</p><blockquote><p>初始化 io_uring 以便在你的程序中使用. 在你使用 io_uring 做任何事情之前，你应该先调用这个函数。<br><strong>参数</strong><br>entries：您要为提交队列请求的条目数。每一个请求包含一个I/O操作的细节。<br>ring：指向将由内核填充的 <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">io_uring</a> 结构的指针。<br><em>flags</em>： 您要传递的 flags 。有关详细信息，请参阅 <a href="https://unixism.net/loti/ref-iouring/io_uring_setup.html#io-uring-setup">io_uring_setup</a>。</p></blockquote><p><strong>返回值</strong>:成功返回0，失败返回<code>-errono</code>。您可以使用<a href="http://man7.org/linux/man-pages/man3/strerror.3.html">strerror(3)</a>来获得可读的失败原因版本。</p><pre><code># 参考[cat 使用 liburing 实现的Demo](https://unixism.net/loti/tutorial/cat_liburing.html#eg-cat-uring)</code></pre><hr><p>int <strong>io_uring_queue_init_params</strong>(unsigned entries, struct <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">io_uring</a> *ring, struct io_uring_params *p)<br>在功能上等同于io_uring_queue_init()，但另外还带有指向io_uring_params结构的指针，允许您指定自己的io_uring_params结构。</p><pre><code>  在 **io_uring_params** 结构中，您只能指定可以用于设置[各种 flags](https://unixism.net/loti/ref-iouring/io_uring_setup.html#io-uring-setup)和 `sq_thread_cpu` 和 `sq_thread_idle` 字段的 flags，这些字段用于设置CPU的亲和性和提交队列空闲时间。结构的其他字段在返回时由内核填充。当使用[io_uring_queue_init()](https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init)时，不需要指定这些值。这个函数的存在为你解决了这个问题。</code></pre><hr><p>int <strong>io_uring_queue_mmap</strong>(int <em>fd</em>, struct io_uring_params *p, struct io_uring *ring)</p><blockquote><p>这是一个底层函数，只有当你想控制<code>io_uring</code>初始化的很多方面时才会用到。在调用这个函数之前，你应该已经调用了底层的<a href="https://unixism.net/loti/ref-iouring/io_uring_setup.html#c.io_uring_setup">io_uring_setup()</a>。然后，你可以使用这个函数来为你<a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a> 映射到 ring。</p><h1>参数</h1><ul><li>fd: <a href="https://unixism.net/loti/ref-iouring/io_uring_setup.html#c.io_uring_setup">io_uring_setup()</a>返回的文件描述符</li><li>p: 指向 io_uring_params 的指针</li><li>ring: 指向 <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">io_uring</a> 的指针</li></ul></blockquote><pre><code>#  参考[底层 io_uring 接口使用](https://unixism.net/loti/low_level.html#low-level)</code></pre><hr><p>int <strong>io_uring_ring_dontfork</strong>(struct io_uring *ring)<br>如果你不想让你的进程的子进程继承环形映射，请使用此调用。</p><pre><code># 参数- ring: 由**[io_uring_queue_init()](https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init)**设置的 **[io_uring](https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring)** 结构返回值：成功返回0，失败返回-errono。您可以使用strerror(3)来获得人类可读的失败原因版本。# 参考[madvice(2)](http://man7.org/linux/man-pages/man2/madvice.2.html),尤其是MADV_DONTFORK。</code></pre><p>void io_uring_queue_exit(struct io_uring *ring)</p><pre><code>io_uring的删除函数。删除所有设置共享环缓冲区的映射，并关闭内核返回的低级io_uring文件描述符。# 参数- ring: 由io_uring_queue_init()设置的io_uring结构。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持的功能</title>
      <link href="/jony.github.io/df6e31d86020/"/>
      <url>/jony.github.io/df6e31d86020/</url>
      
        <content type="html"><![CDATA[<p>允许您检查支持的操作和功能的函数。</p><p><em>struct</em> <em><strong>io_uring_probe</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_probe</span> &#123;</span></span><br><span class="line">    __u8 last_op;   <span class="comment">/* last opcode supported */</span></span><br><span class="line">    __u8 ops_len;   <span class="comment">/* length of ops[] array below */</span></span><br><span class="line">    __u16 resv;</span><br><span class="line">    __u32 resv2[<span class="number">3</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_probe_op</span> <span class="title">ops</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct io_uring_probe_op</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_probe_op</span> &#123;</span></span><br><span class="line">__u8 op;</span><br><span class="line">__u8 resv;</span><br><span class="line">__u16 flags;        <span class="comment">/* IO_URING_OP_* flags */</span></span><br><span class="line">__u32 resv2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>struct</em> <a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a> *<em><strong>io_uring_get_probe_ring</strong></em>(<em>struct</em> <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">io_uring</a> *<em>ring</em>)</p><blockquote><p><strong>参数</strong></p></blockquote><blockquote><ul><li>ring: uring 结构通过 <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a> 设置</li></ul></blockquote><blockquote><p><strong>返回值</strong>：成功时，返回指向 <a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a>的指针，该指针用于探测正在运行的内核的<code>io_uring</code>子系统的能力。<a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a>包含了支持的操作列表。如果失败，则返回NULL。</p></blockquote><pre><code>&gt; # 注意&gt; 这个函数分配内存来保存io_uring_probe结构。一旦你完成了任务，你在安全的时刻需要释放它。</code></pre><p>struct <a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a> <em><strong>*io_uring_get_probe</strong></em>(void)</p><blockquote><p>返回指向 <a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a> 的指针，该指针用于探测运行中内核的io_uring子系统的能力。<a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a> 包含支持的操作列表。</p></blockquote><blockquote><p>这个函数和 <a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_get_probe_ring">io_uring_get_probe_ring()</a> 差不多，除了不需要你设置一个 ring 或者有一个 ring 的引用。它设置了一个临时的 ring ，这样它就可以为你获取支持的操作的细节。然后它在返回之前销毁了这个 ring 。</p></blockquote><blockquote><h1>参考</h1><p>在运行中的内核中打印支持的io_uring操作的<a href="https://unixism.net/loti/tutorial/probe_liburing.html#probing-liburing">示例程序</a>。</p></blockquote><hr><p>int <strong>io_uring_opcode_supported</strong>(struct <a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a> *p, int op)</p><blockquote><p>用于确定内核是否支持io_uring操作的函数。如果不支持该操作，则返回0，如果支持则返回非零值。请看一下支持的操作示例程序来了解这个函数的作用。</p><p><strong>参数</strong><br>p: 指向 io_uring_probe 结构体<br>op: 要检查支持的操作。一个IO_URING_OP_*宏。<br><strong>返回值</strong><br>如果不支持，则为0，否则为1。</p></blockquote><hr><p>int <strong>io_uring_register_probe</strong>(struct <a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">io_uring</a> *ring, struct <a href="https://unixism.net/loti/ref-liburing/supported_caps.html#c.io_uring_probe">io_uring_probe</a> *p, unsigned nr)</p><blockquote><p>让你获得 <code>io_uring</code> 功能的底层接口。<br><strong>参数</strong><br>ring: <strong><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a></strong> 设置的 <strong><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring">io_uring</a></strong> 结构<br>p: 指向 <code>io_uring_probe</code> 结构的指针<br>nr: 指向的<code>p</code>数组结构的数目<br><strong>返回值</strong>: 成功时返回0，失败时返回 <code>-errono</code> 。你可以使用 <a href="http://man7.org/linux/man-pages/man3/strerror.3.html">strerror(3)</a> 来获得一个可读的失败原因版本。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CQE:完成队列条目</title>
      <link href="/jony.github.io/201d74132273/"/>
      <url>/jony.github.io/201d74132273/</url>
      
        <content type="html"><![CDATA[<p>内核为每个提交的队列条目添加了一个完成队列事件(CQE)。CQE 包含作为 SQE 的一部分提交的操作的状态。作为内核处理 SQE 的结果，只有一个 CQE 添加到完成队列中。这两者之间存在一一对应的关系。</p><pre><code># 注意这个结构是原始输入输出接口的一部分，在输入输出接口中定义。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">    __u64   user_data;      <span class="comment">/* sqe-&gt;data 提交内容已传回 */</span></span><br><span class="line">    __s32   res;            <span class="comment">/* 此事件的结果代码 */</span></span><br><span class="line">    __u32   flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQE:提交队列条目</title>
      <link href="/jony.github.io/1f47a91ce33a/"/>
      <url>/jony.github.io/1f47a91ce33a/</url>
      
        <content type="html"><![CDATA[<p>提交队列条目(SQE)是用来告诉 <strong><code>io_uring</code></strong> 你想要做什么，比如读取一个文件，写一个文件，监听一个 socket 上的连接等等。</p><pre><code># 注意这个结构是原始 io_uring 接口的一部分，在 io_uring.h 中定义。</code></pre><h2 id="struct-io-uring-sqe">struct io_uring_sqe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">    __u8    opcode;         <span class="comment">/* 此sqe的操作类型 */</span></span><br><span class="line">    __u8    flags;          <span class="comment">/* IOSQE_ 标记 */</span></span><br><span class="line">    __u16   ioprio;         <span class="comment">/* 请求的ioprio */</span></span><br><span class="line">    __s32   fd;             <span class="comment">/* 要执行IO的文件描述符 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        __u64       off;    <span class="comment">/* offset into file */</span></span><br><span class="line">        __u64       addr2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        __u64       addr;   <span class="comment">/* 指向缓冲区或iovecs的指针 */</span></span><br><span class="line">        __u64       splice_off_in;</span><br><span class="line">    &#125;;</span><br><span class="line">    __u32   len;            <span class="comment">/* 缓冲区大小或iovec的数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">__kernel_rwf_t</span>      rw_flags;</span><br><span class="line">        __u32               fsync_flags;</span><br><span class="line">        __u16               poll_events;</span><br><span class="line">        __u32               sync_range_flags;</span><br><span class="line">        __u32               msg_flags;</span><br><span class="line">        __u32               timeout_flags;</span><br><span class="line">        __u32               accept_flags;</span><br><span class="line">        __u32               cancel_flags;</span><br><span class="line">        __u32               open_flags;</span><br><span class="line">        __u32               statx_flags;</span><br><span class="line">        __u32               fadvise_advice;</span><br><span class="line">        __u32               splice_flags;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 在完成时传回的数据 */</span></span><br><span class="line">    __u64   user_data;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="comment">/* 索引到固定缓冲区（如果使用 */</span></span><br><span class="line">                __u16       buf_index;</span><br><span class="line">                <span class="comment">/* 用于分组缓冲区选择 */</span></span><br><span class="line">                __u16       buf_group;</span><br><span class="line">            &#125; __attribute__((packed));</span><br><span class="line">            <span class="comment">/* personality to use, if used */</span></span><br><span class="line">            __u16   personality;</span><br><span class="line">            __s32   splice_fd_in;</span><br><span class="line">        &#125;;</span><br><span class="line">        __u64       __pad2[<span class="number">3</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册一个eventfd</title>
      <link href="/jony.github.io/304bb0ffee1d/"/>
      <url>/jony.github.io/304bb0ffee1d/</url>
      
        <content type="html"><![CDATA[<p>关于 <a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a> 系统调用的细节不在讨论范围内。你可能需要查看 <a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a> man 页面来了解该系统调用的描述。 <a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a> 是一个 Linux 特有的同步机制。</p><p><code>io_uring</code> 能够在事件完成时在eventfd实例上发布事件。该功能允许使用 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> 或 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> 复用I/O的进程将 <code>io_uring</code> 注册的eventfd实例文件描述符添加到兴趣列表中，以便 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> 或 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> 在完成时通过 <code>io_uring</code> 通知它们。这允许这样的程序忙于处理它们现有的事件循环，而不是在调用 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">io_uring_wait_cqe()</a> 时被阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SZ   512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buff[BUFF_SZ + <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_exit</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    perror(message);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">listener_thread</span><span class="params">(<span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">int</span> efd = (<span class="keyword">int</span>) data;</span><br><span class="line">    <span class="keyword">eventfd_t</span> v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting for completion event...\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = eventfd_read(efd, &amp;v);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) error_exit(<span class="string">&quot;eventfd_read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got completion event.\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 现在我们有了CQE，让我们来处理它 */</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n%s\n&quot;</span>, buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_io_uring</span><span class="params">(<span class="keyword">int</span> efd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_register_eventfd(&amp;ring, efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_file_with_io_uring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    io_uring_prep_read(sqe, fd, buff, BUFF_SZ, <span class="number">0</span>);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">int</span> efd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个eventfd实例 */</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (efd &lt; <span class="number">0</span>)</span><br><span class="line">        error_exit(<span class="string">&quot;eventfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建监听线程 */</span></span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, listener_thread, (<span class="keyword">void</span> *)efd);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 io_uring 实例和注册eventfd */</span></span><br><span class="line">    setup_io_uring(efd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化读 io_uring */</span></span><br><span class="line">    read_file_with_io_uring();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待监听线程完成 */</span></span><br><span class="line">    pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 所有完成，清空和退出 */</span></span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>它是如何工作的</h1><p>在主线程中，我们创建了一个<a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a>实例。然后创建一个线程，将 <code>eventfd</code> 文件描述符传递给它。在线程中，我们打印一条消息并立即从 <code>eventfd</code> 文件描述符中读取。这将导致线程阻塞，因为在 <code>eventfd</code> 实例上还没有发布任何事件。</p><p>当子线程在读取 <code>eventfd</code> 文件描述符时阻塞，我们在父线程中休眠2秒以清楚地感知这个序列。接下来，在 <code>setup_io_uring()</code> 中，我们创建一个 <code>io_uring</code> 实例，并向它注册 <code>eventfd</code> 文件描述符。这将导致 <code>io_uring</code> 在每一次完成事件时，都会在这个 <code>eventfd</code> 上 post 一个事件。</p><p>然后从main调用 <code>read_file_with_io_uring()</code> 。在这里，我们提交一个读取文件的请求。这将导致io_uring在注册的eventfd实例上发布一个事件。这现在应该会导致 <code>[read(2)](http://man7.org/linux/man-pages/man2/read.2.html)</code> 调用，在该调用中 <code>listener_thread()</code> 被阻塞，以解除阻塞并继续执行。在这个线程中，我们获取完成并打印出数据。</p><pre><code># 注意请注意，`eventfd_read()` 是glibc提供的一个库函数。它本质上是在eventfd上调用read。</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轮询提交队列</title>
      <link href="/jony.github.io/973aa4b46332/"/>
      <url>/jony.github.io/973aa4b46332/</url>
      
        <content type="html"><![CDATA[<p>减少系统调用的次数是 <code>io_uring</code> 的一个主要目的。为此， <code>io_uring</code> 允许你提交I/O请求，而不需要进行一次系统调用。这是通过 <code>io_uring</code> 支持的一个特殊的提交队列轮询功能实现的。在这种模式下，当你的程序设置了轮询模式后， <code>io_uring</code> 就会启动一个特殊的内核线程，轮询共享的提交队列，查看你的程序可能添加的条目。这样一来，你只需要向共享队列提交条目，内核线程就会看到它，并获取提交队列条目，而不需要你的程序进行 <a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a> 系统调用，这通常由<code>liburing</code> 来处理。这是在用户空间和内核之间共享队列的一个好处。</p><p>如何使用这种模式？这个想法很简单。你通过在 <code>io_uring_params</code> 结构的 <code>flags</code> 成员中设置 <code>IORING_SETUP_SQPOLL</code> 标志来告诉 <code>io_uring</code> 你想使用这个模式。如果和你的进程一起启动的内核线程在一段时间内没有看到任何提交，它就会退出，你的程序需要再调用一次 <a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a>系统调用来唤醒它。这个时间段可以通过 :c:struct`io_uring_params` 结构的 <code>sq_thread_idle</code> 成员来配置。但是，如果不断收到提交，内核轮询器线程应该永远不会休眠</p><pre><code> # 注意： 当使用 liburing 时，你永远不会直接调用 [io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter) 系统调用。这通常由liburing的 [io_uring_submit()](https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit) 函数来处理。它能自动判断你是否使用轮询模式，并处理你的程序何时需要调用 [io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)，而不需要你判断。 # 注意 内核的轮询线程会占用大量的CPU。你需要小心使用这个功能。设置一个非常大的sq_thread_idle值会导致内核线程在你的程序没有提交时继续消耗CPU。如果你真的期望处理大量的I/O，那么使用这个特性是个好主意。而即使你这样做，也最好将轮询线程的空闲值设置为最多几秒钟。</code></pre><p>但是，如果您需要使用此功能，则还需要将其与 <a href="https://unixism.net/loti/ref-liburing/advanced_usage.html#c.io_uring_register_files">io_uring_register_files()</a>结合使用。使用它，您可以预先告诉内核有关文件描述符数组的信息。这只是您在启动I/O之前打开的常规文件描述符的数组。在提交期间，您需要在SQE的 <code>flags</code> 字段中设置 <code>IOSQE_FIXED_FILE</code> 标志，并传递您之前设置的文件描述符数组中的文件描述符的索引，而不是像通常那样将文件描述符传递给<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a>或 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a> 等调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME1  <span class="meta-string">&quot;/tmp/io_uring_sq_test.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR1        <span class="meta-string">&quot;What is this life if, full of care,\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR2        <span class="meta-string">&quot;We have no time to stand and stare.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sq_poll_kernel_thread_status</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (system(<span class="string">&quot;ps --ppid 2 | grep io_uring-sq&quot;</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Kernel thread io_uring-sq found running...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Kernel thread io_uring-sq is not running.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_sq_polling_ops</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buff1[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> buff2[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> buff3[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> buff4[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">int</span> str1_sz = <span class="built_in">strlen</span>(STR1);</span><br><span class="line">    <span class="keyword">int</span> str2_sz = <span class="built_in">strlen</span>(STR2);</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>] = open(FILE_NAME1, O_RDWR | O_TRUNC | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>] &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buff1, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buff2, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buff3, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buff4, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">strncpy</span>(buff1, STR1, str1_sz);</span><br><span class="line">    <span class="built_in">strncpy</span>(buff2, STR2, str2_sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_register_files(ring, fds, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error registering buffers: %s&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_write(sqe, <span class="number">0</span>, buff1, str1_sz, <span class="number">0</span>);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_write(sqe, <span class="number">0</span>, buff2, str2_sz, str1_sz);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_sq_poll_kernel_thread_status();</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_read(sqe, <span class="number">0</span>, buff3, str1_sz, <span class="number">0</span>);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_read(sqe, <span class="number">0</span>, buff4, str2_sz, str1_sz);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s&quot;</span>, buff3, buff4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (geteuid()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;You need root privileges to run this program.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_sq_poll_kernel_thread_status();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">    params.flags |= IORING_SETUP_SQPOLL;</span><br><span class="line">    params.sq_thread_idle = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init_params(<span class="number">8</span>, &amp;ring, &amp;params);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    start_sq_polling_ops(&amp;ring);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>它是如何工作的</h1><p>这个示例程序很像我们之前看到的固定缓冲区示例。虽然我们使用 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read_fixed">io_uring_prep_read_fixed()</a></strong> 和 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write_fixed">io_uring_prep_write_fixed()</a></strong> 等专门函数来处理固定缓冲区，但我们使用了 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a></strong>、<strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_readv">io_uring_prep_readv()</a></strong>、**<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a><strong>或</strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_writev">io_uring_prep_writev()</a><strong>等常规函数。然而，在使用描述提交的SQE中，设置 <code>IOSQE_FIXED_FILE</code> 标志时，在文件描述符数组中使用文件描述符的索引，而不是在调用</strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_readv">io_uring_prep_readv()</a>**和 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_writev">io_uring_prep_writev()</a></strong> 等调用中使用文件描述符本身。</p><p>当程序启动时，在我们设置 <code>io_uring</code> 实例之前，我们打印执行提交队列轮询的内核线程的运行状态。此线程的名称为 <code>io_uring-sq</code> 。函数 <code>print_sq_poll_kernel_thread_status()</code> 负责打印此状态。当然，如果有任何其他进程使用提交队列轮询，您将看到该内核线程确实在运行。所有内核线程的父线是 <code>kthreadd</code> 内核线程，这个线程是在 <code>init</code>之后马上启动的，众所周知，它的进程ID为1。因此，<code>kthreadd</code> 的PID为2，我们可以利用这一事实作为一种简单的优化来只过滤内核线程。</p><p>为了初始化<code>io_uring</code>，我们使用 <strong><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init_params">io_uring_queue_init_params()</a></strong> 而不是常用的 <strong><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a></strong> ，因为这需要一个指向 <strong>io_uring_params</strong> 结构的指针作为参数。正是在这个参数中，我们指定了 <code>IORING_SETUP_SQPOLL</code> 作为 <code>flags</code> 字段的一部分，并将 <code>sq_thread_idle</code> 设置为2000，这是提交队列轮询器内核线程的空闲时间。如果在这许多毫秒内没有提交，线程就会退出，需要通过 <code>liburing</code> 在内部进行 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a></strong> 系统调用，让内核线程再次启动。</p><p>由于提交队列轮询只能与固定文件结合使用，因此我们首先要注册处理的唯一文件描述符。如果要处理更多的文件，这时你要用 <strong><a href="https://unixism.net/loti/ref-liburing/advanced_usage.html#c.io_uring_register_files">io_uring_register_files()</a></strong> 函数打开并注册它们。对于每次提交，您需要使用 <code>io_sqe_set_flag()</code> 辅助函数设置 <code>IOSQE_FIXED_FILE</code> 标志，并将注册文件数组中打开文件的索引(而不是实际文件描述符本身)提供给 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a></strong> 或 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a></strong> 等函数。</p><p>在这个例子中，我们有4个缓冲区。前2个缓冲区被2个写操作用来向文件中各写一行。之后，我们用第3个和第4个缓冲区再进行2次读操作，读取这2行写入的内容并打印出来。写操作结束后，我们打印 <code>io_uring-sq</code> 内核线程的状态，现在我们应该发现它正在运行。</p><pre><code>➜  sudo ./sq_poll[sudo] password for shuveb:Kernel thread io_uring-sq is not running.Result of the operation: 36Result of the operation: 35   1750 ?        00:00:00 io_uring-sqKernel thread io_uring-sq found running...Result of the operation: 36Result of the operation: 35Contents read from file:What is this life if, full of care,We have no time to stand and stare.%    </code></pre><h1>通过内核验证轮询</h1><p>但是，您需要调用 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a></strong>。我们在前面的示例中看到，这会导致发出 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a></strong> 系统调用。但是，在已经设置了 <code>IORING_SETUP_SQPOLL</code> 标志的情况下不是这样。 <code>liburing</code> 完全隐藏了这一点，同时保持了程序的持续接口。但是，我们能证实这一点吗?当然，我们可以通过使用eBPF的 <code>bpftrace</code> 程序来窥探系统。这里，我们将在 <code>io_uring</code> 设置的内核中使用跟踪点来证明，当我们设置 <code>IORING_SETUP_SQPOLL</code> 并提交I/O请求时，尽管我们调用了 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_submit()</a></strong> 函数，但我们的程序不会执行 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a></strong> 系统调用。如前所述，对于高吞吐量的程序，我们的想法是尽可能地避免系统调用。</p><p>在下面的程序中，我们添加一个 tracepoint 到 <code>io_uring</code> 的 <code>io_uring_submit_sqe</code> 。每当一个SQE被提交给内核时，这个tracepoint就会被触发。每次这个tracepoint被触发，我们使用 <code>bpftrace</code> 来打印命令的名称和它的PID。首先，让我们在一个终端上运行 <code>bpftrace</code> 命令，同时在另一个终端上运行<a href="https://unixism.net/loti/tutorial/fixed_buffers.html#fixed-buffers">固定缓冲区</a>的例子。下面是我机器上的输出示例。你可以看到 <code>fixed_buffers</code> 是提交SQE的那个。</p><pre><code>➜  sudo bpftrace -e 'tracepoint:io_uring:io_uring_submit_sqe &#123;printf(&quot;%s(%d)\n&quot;, comm, pid);&#125;'Attaching 1 probe...fixed_buffers(30336)fixed_buffers(30336)fixed_buffers(30336)fixed_buffers(30336)</code></pre><p>让我们重复前面的练习，但现在运行当前的例子。你可以看到，SQE的提交是通过 <code>io_uring_sq</code> 内核线程进行的。因此我们避免了系统调用。</p><pre><code>➜  sudo bpftrace -e 'tracepoint:io_uring:io_uring_submit_sqe &#123;printf(&quot;%s(%d)\n&quot;, comm, pid);&#125;'io_uring-sq(30429)io_uring-sq(30429)io_uring-sq(30429)io_uring-sq(30429)</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>固定缓冲区</title>
      <link href="/jony.github.io/48d3d8aca367/"/>
      <url>/jony.github.io/48d3d8aca367/</url>
      
        <content type="html"><![CDATA[<p>使用固定缓冲区的思想是这样的:您提供一组用<code>iovec</code>结构体数组描述的缓冲区，并使用 <code>[io_uring_register_buffers()](https://unixism.net/loti/ref-liburing/advanced_usage.html#c.io_uring_register_buffers)</code> 将它们注册到内核。这将导致内核将这些缓冲区映射到内存中，从而避免将来在用户空间中来回复制。然后可以使用像<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write_fixed">io_uring_prep_write_fixed()</a>和<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read_fixed">io_uring_prep_read_fixed()</a>这样的“固定缓冲区”函数来指定要使用的缓冲区的索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;liburing.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME   <span class="meta-string">&quot;/tmp/io_uring_test.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR1        <span class="meta-string">&quot;What is this life if, full of care,\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR2        <span class="meta-string">&quot;We have no time to stand and stare.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fixed_buffers</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[4];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        iov[i].iov_base = <span class="built_in">malloc</span>(BUF_SIZE);</span><br><span class="line">        iov[i].iov_len = BUF_SIZE;</span><br><span class="line">        <span class="built_in">memset</span>(iov[i].iov_base, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_register_buffers(ring, iov, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error registering buffers: %s&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> str1_sz = <span class="built_in">strlen</span>(STR1);</span><br><span class="line">    <span class="keyword">int</span> str2_sz = <span class="built_in">strlen</span>(STR2);</span><br><span class="line">    <span class="built_in">strncpy</span>(iov[<span class="number">0</span>].iov_base, STR1, str1_sz);</span><br><span class="line">    <span class="built_in">strncpy</span>(iov[<span class="number">1</span>].iov_base, STR2, str2_sz);</span><br><span class="line">    io_uring_prep_write_fixed(sqe, fd, iov[<span class="number">0</span>].iov_base, str1_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_write_fixed(sqe, fd, iov[<span class="number">1</span>].iov_base, str2_sz, str1_sz, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read_fixed(sqe, fd, iov[<span class="number">2</span>].iov_base, str1_sz, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read_fixed(sqe, fd, iov[<span class="number">3</span>].iov_base, str2_sz, str1_sz, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s&quot;</span>, iov[<span class="number">2</span>].iov_base, iov[<span class="number">3</span>].iov_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed_buffers(&amp;ring);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>它是如何工作的</h1><p>我们通过malloc(3)分配4个缓冲区，然后用io_uring_register_buffers()函数向内核注册它们。iovec结构通过持有一个基地址和分配的缓冲区大小来描述每个数组。我们使用一个4个元素长的iovec结构数组来保存我们需要的4个数组的详细信息。</p><p>这个程序只是简单的演示了如何使用固定缓冲区，除此之外并没有更多有用的东西。使用两个固定的写操作(io_uring_prep_write_fixed())将两个字符串写入写入到一个使用索引为0和1的缓冲区的文件。 之后，我们使用两个固定的读操作(io_uring_prep_read_fixed())读取文件，这次使用的是2和3的缓冲区。然后我们打印这些读取的结果。</p><p>你可以看到这个程序的输出如下所示:</p><pre><code>Result of the operation: 36Result of the operation: 35Result of the operation: 36Result of the operation: 35Contents read from file:What is this life if, full of care,We have no time to stand and stare.</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求链</title>
      <link href="/jony.github.io/6629bb792093/"/>
      <url>/jony.github.io/6629bb792093/</url>
      
        <content type="html"><![CDATA[<p>在<code>io_uring</code>中，完成没有按照提交的问题所在的顺序到达。这在<a href="https://unixism.net/loti/low_level.html#low-level">底层io_uring接口</a>一章中讨论过。如果您想要强制某些操作按顺序进行，该怎么办?这可以通过将请求链实现。这里的示例向您展示了如何实现这一点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;liburing.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME   <span class="meta-string">&quot;/tmp/io_uring_test.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR         <span class="meta-string">&quot;Hello, io_uring!&quot;</span></span></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link_operations</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_write(sqe, fd, STR, <span class="built_in">strlen</span>(STR), <span class="number">0</span> );</span><br><span class="line">    sqe-&gt;flags |= IOSQE_IO_LINK;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read(sqe, fd, buff, <span class="built_in">strlen</span>(STR),<span class="number">0</span>);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_IO_LINK;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_close(sqe, fd);</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                                                            strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buffer contents: %s\n&quot;</span>, buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    link_operations(&amp;ring);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个相当简单的程序。我们打开一个空文件，向它写入一个字符串，从文件中读取字符串，然后关闭它。由于 <code>io_uring</code> 并不能保证提交的操作会按顺序执行，这可能会给我们的程序带来问题。因为它是一个空文件，在程序的每一次运行中都会被截断，如果如果在读取之前没有完成写操作，那么将没有任何东西可以读。另外，如果关闭操作在读取或写入操作或这两个操作之前完成，这些操作也可能失败。为此，本程序用 <code>IOSQE_IO_LINK</code> 标志来链接操作。这样可以保证操作串行地执行。</p><p>这个程序理解起来相当简单。在 <code>link_operations()</code> 函数中，我们调用 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a>，但是在它上面设置 <code>IOSQE_IO_LINK</code>标志，这样下一个操作就会和这个操作链接起来。接下来，我们调用 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a>，现在它已经链接到了之前的写操作。我们还在此操作上设置了 <code>IOSQE_IO_LINK</code> 标志，这样我们用 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_close">io_uring_prep_close()</a>设置的后续关闭操作就会与这个操作链接起来。这样就会使 <code>io_uring</code> 接连执行写、读和关闭操作。</p><h1>请求链中的故障</h1><p>当涉及到链操作时，一个操作的失败会导致所有后续的链接操作失败，并出现错误 “Operation cancelled.”。一般情况下，如果你在内核5.6以上版本上运行这个程序，应该会有这个输出。</p><pre><code>→  cmake-build-debug ./linkResult of the operation: 16Result of the operation: 16Result of the operation: 0Buffer contents: Hello, io_uring!</code></pre><p>如果我们切换它们的open()语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>以只写模式打开文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(FILE_NAME, O_WRONLY|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>我们的写操作应该会通过，但是我们的读操作会失败，因为文件现在是以只写模式打开的。由于后续的close操作链接到read操作。现在这个有缺陷的程序的输出将是。</p><pre><code>→  cmake-build-debug ./linkError in async operation: Bad file descriptorResult of the operation: -9Error in async operation: Operation canceledResult of the operation: -125</code></pre><p>你看到的第一个错误(“Bad file descriptor”)是来自于失败的读取操作。你看到的下一个错误(“Operation cancelled”)是io_uring取消了链接关闭操作。</p><pre><code># 注意请注意，你需要内核5.6或更高版本的内核才能工作，因为在早期版本中不支持读、写和关闭操作。</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探测支持功能</title>
      <link href="/jony.github.io/4aa7709cef2f/"/>
      <url>/jony.github.io/4aa7709cef2f/</url>
      
        <content type="html"><![CDATA[<p>下面的程序演示了如何使用 <code>io_uring_get_probe()</code> 。它打印出是否支持某个操作。</p><blockquote><p>A program to print details about supported and unsupported operations</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing/io_uring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *op_strs[] = &#123;</span><br><span class="line">        <span class="string">&quot;IORING_OP_NOP&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_READV&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_WRITEV&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FSYNC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_READ_FIXED&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_WRITE_FIXED&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_POLL_ADD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_POLL_REMOVE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SYNC_FILE_RANGE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SENDMSG&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_RECVMSG&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_TIMEOUT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_TIMEOUT_REMOVE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_ACCEPT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_ASYNC_CANCEL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_LINK_TIMEOUT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_CONNECT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FALLOCATE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_OPENAT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_CLOSE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FILES_UPDATE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_STATX&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_READ&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_WRITE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FADVISE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_MADVISE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SEND&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_RECV&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_OPENAT2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_EPOLL_CTL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SPLICE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_PROVIDE_BUFFERS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_REMOVE_BUFFERS&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">u</span>;</span></span><br><span class="line">    uname(&amp;u);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You are running kernel version: %s\n&quot;</span>, u.release);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_probe</span> *<span class="title">probe</span> =</span> io_uring_get_probe();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Report of your kernel&#x27;s list of supported io_uring operations:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; IORING_OP_LAST; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, op_strs[i]);</span><br><span class="line">        <span class="keyword">if</span>(io_uring_opcode_supported(probe, i))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;yes.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(probe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是程序在Linux内核5.6.4上运行时的输出<br>You are running kernel version: 5.6.4-arch1-1<br>Report of your kernel’s list of supported io_uring operations:<br>IORING_OP_NOP: yes.<br>IORING_OP_READV: yes.<br>IORING_OP_WRITEV: yes.<br>IORING_OP_FSYNC: yes.<br>IORING_OP_READ_FIXED: yes.<br>IORING_OP_WRITE_FIXED: yes.<br>IORING_OP_POLL_ADD: yes.<br>IORING_OP_POLL_REMOVE: yes.<br>IORING_OP_SYNC_FILE_RANGE: yes.<br>IORING_OP_SENDMSG: yes.<br>IORING_OP_RECVMSG: yes.<br>IORING_OP_TIMEOUT: yes.<br>IORING_OP_TIMEOUT_REMOVE: yes.<br>IORING_OP_ACCEPT: yes.<br>IORING_OP_ASYNC_CANCEL: yes.<br>IORING_OP_LINK_TIMEOUT: yes.<br>IORING_OP_CONNECT: yes.<br>IORING_OP_FALLOCATE: yes.<br>IORING_OP_OPENAT: yes.<br>IORING_OP_CLOSE: yes.<br>IORING_OP_FILES_UPDATE: yes.<br>IORING_OP_STATX: yes.<br>IORING_OP_READ: yes.<br>IORING_OP_WRITE: yes.<br>IORING_OP_FADVISE: yes.<br>IORING_OP_MADVISE: yes.<br>IORING_OP_SEND: yes.<br>IORING_OP_RECV: yes.<br>IORING_OP_OPENAT2: yes.<br>IORING_OP_EPOLL_CTL: yes.<br>IORING_OP_SPLICE: no.<br>IORING_OP_PROVIDE_BUFFERS: no.<br>IORING_OP_REMOVE_BUFFERS: no.</p><h1>源码</h1><p>源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a>上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liburing 实现 web 服务器</title>
      <link href="/jony.github.io/90d9c32a425c/"/>
      <url>/jony.github.io/90d9c32a425c/</url>
      
        <content type="html"><![CDATA[<h1>liburing 实现 web 服务器</h1><p>我们在<a href="https://unixism.net/loti/async_intro.html#async-intro">介绍</a>中讨论过，因为 <a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>和 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>报告对本地/常规文件的操作始终处于就绪状态，<br>所以像 libuv (这个 NodeJS 底层实现)这样的库使用单独的线程池来处理文件 i/o。<br><code>io_uring</code> 的一个巨大优势是，它为多种类型的I/O提供了一个单一的、干净的统一的、最重要的是高效的接口。</p><p>在这个示例中，我们将研究一个额外的操作 accept()以及如何使用 io_uring 来实现它。加上 readv()和 writev()的操作，<br>您就有能力编写一个简单的 web 服务器了！这个web服务器是基于我为ZeroHTTPd写的代码，<br>这个程序的特点是在我写的一系列文章中探索各种 Linux 进程模型以及它们相互之间的性能比较。<br>已经重写了 ZeroHTTPd 来专门使用 io/uring 接口。</p><p>下面是通过 ZeroHTTPd 提供的index页面:</p><p><img src="/jony.github.io/images/ZeroHTTPd_static.png" alt="index页面" title="index 页面"></p><p>现在让我们进入代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_STRING <span class="meta-string">&quot;Server: zerohttpd/0.1\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_DEPTH 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_SZ 8192</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_ACCEPT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_READ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_WRITE 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> event_type;</span><br><span class="line">    <span class="keyword">int</span> iovec_count;</span><br><span class="line">    <span class="keyword">int</span> client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *unimplemented_content =</span><br><span class="line">    <span class="string">&quot;HTTP/1.0 400 Bad Request\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Content-type: text/html\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;html&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;title&gt;ZeroHTTPd: Unimplemented&lt;/title&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;h1&gt;Bad Request (Unimplemented)&lt;/h1&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;p&gt;Your client sent a request ZeroHTTPd did not understand and it is probably not your fault.&lt;/p&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *http_404_content =</span><br><span class="line">    <span class="string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Content-type: text/html\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;html&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;title&gt;ZeroHTTPd: Not Found&lt;/title&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;h1&gt;Not Found (404)&lt;/h1&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;p&gt;Your client is asking for an object that was not found on this server.&lt;/p&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用于将字符串转换为小写的实用函数。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strtolower</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; *str; ++str)</span><br><span class="line">        *str = (<span class="keyword">char</span>)<span class="built_in">tolower</span>(*str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 一个打印系统调用和错误详情的函数</span></span><br><span class="line"><span class="comment"> 然后以错误代码1退出。非零的意思是事情不顺利。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fatal_error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *syscall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(syscall);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为使代码看起来更干净的辅助功能。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zh_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *buf = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (!buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fatal error: unable to allocate memory.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数负责设置web服务器使用的主监听套接字。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_listening_socket</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock,</span><br><span class="line">                   SOL_SOCKET, SO_REUSEADDR,</span><br><span class="line">                   &amp;enable, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;setsockopt(SO_REUSEADDR)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">    srv_addr.sin_family = AF_INET;</span><br><span class="line">    srv_addr.sin_port = htons(port);</span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们绑定到一个端口，将这个套接字变成一个监听套接字。</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sock,</span><br><span class="line">             (<span class="keyword">const</span> struct sockaddr *)&amp;srv_addr,</span><br><span class="line">             <span class="keyword">sizeof</span>(srv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(sock, <span class="number">10</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_accept_request</span><span class="params">(<span class="keyword">int</span> server_socket, struct sockaddr_in *client_addr, <span class="keyword">socklen_t</span> *client_addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    io_uring_prep_accept(sqe, server_socket, (struct sockaddr *)client_addr, client_addr_len, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req));</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_ACCEPT;</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_read_request</span><span class="params">(<span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req) + <span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_base = <span class="built_in">malloc</span>(READ_SZ);</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_len = READ_SZ;</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_READ;</span><br><span class="line">    req-&gt;client_socket = client_socket;</span><br><span class="line">    <span class="built_in">memset</span>(req-&gt;iov[<span class="number">0</span>].iov_base, <span class="number">0</span>, READ_SZ);</span><br><span class="line">    <span class="comment">/* Linux内核5.5支持readv，但不支持recv()或read() */</span></span><br><span class="line">    io_uring_prep_readv(sqe, client_socket, &amp;req-&gt;iov[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_write_request</span><span class="params">(struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_WRITE;</span><br><span class="line">    io_uring_prep_writev(sqe, req-&gt;client_socket, req-&gt;iov, req-&gt;iovec_count, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _send_static_string_content(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> client_socket)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> zh_malloc(<span class="keyword">sizeof</span>(*req) + <span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slen = <span class="built_in">strlen</span>(str);</span><br><span class="line">    req-&gt;iovec_count = <span class="number">1</span>;</span><br><span class="line">    req-&gt;client_socket = client_socket;</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(req-&gt;iov[<span class="number">0</span>].iov_base, str, slen);</span><br><span class="line">    add_write_request(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当ZeroHTTPd遇到除GET或POST以外的其他HTTP方法时，这个函数用来通知客户端。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_unimplemented_method</span><span class="params">(<span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _send_static_string_content(unimplemented_content, client_socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数用于在请求的文件未找到时，向客户端发送 &quot;HTTP Not Found &quot;代码和消息。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_http_404</span><span class="params">(<span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _send_static_string_content(http_404_content, client_socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一旦确定了要服务的静态文件，这个函数就会被用来读取文件，</span></span><br><span class="line"><span class="comment"> * 并使用Linux的sendfile()系统调用在客户端套接字上写入。</span></span><br><span class="line"><span class="comment"> * 这样我们就省去了将文件缓冲区从内核传送到用户空间再传送回来的麻烦。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_file_contents</span><span class="params">(<span class="keyword">char</span> *file_path, <span class="keyword">off_t</span> file_size, struct iovec *iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = zh_malloc(file_size);</span><br><span class="line">    fd = open(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We should really check for short reads here */</span></span><br><span class="line">    <span class="keyword">int</span> ret = read(fd, buf, file_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; file_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Encountered a short read.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    iov-&gt;iov_base = buf;</span><br><span class="line">    iov-&gt;iov_len = file_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 简单的函数，获取我们要服务的文件的文件扩展名。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">get_filename_ext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dot = <span class="built_in">strrchr</span>(filename, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dot || dot == filename)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> dot + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送HTTP 200 OK头，即服务器字符串，对于一些类型的文件，</span></span><br><span class="line"><span class="comment"> * 它还可以根据文件扩展名发送内容类型。它还会发送内容长度头。</span></span><br><span class="line"><span class="comment"> * 最后，它在一行中发送一个&#x27;\r\n&#x27;，表示头的结束和任何内容的开始。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_headers</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> len, struct iovec *iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> small_case_path[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> send_buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(small_case_path, path);</span><br><span class="line">    strtolower(small_case_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slen = <span class="built_in">strlen</span>(str);</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">0</span>].iov_base, str, slen);</span><br><span class="line"></span><br><span class="line">    slen = <span class="built_in">strlen</span>(SERVER_STRING);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">1</span>].iov_base, SERVER_STRING, slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 检查网页上某些常见类型文件的文件扩展名，并发送适当的内容类型头。</span></span><br><span class="line"><span class="comment">                 * 由于扩展名可以混合大小写，如JPG、jpg或Jpg，所以我们在检查前将扩展名变成小写。</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file_ext = get_filename_ext(small_case_path);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;jpg&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/jpeg\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;jpeg&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/jpeg\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;png&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/png\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;gif&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/gif\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;htm&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;html&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;js&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: application/javascript\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;css&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/css\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;txt&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/plain\r\n&quot;</span>);</span><br><span class="line">    slen = <span class="built_in">strlen</span>(send_buffer);</span><br><span class="line">    iov[<span class="number">2</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">2</span>].iov_base, send_buffer, slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送内容长度头，也就是本例中的文件大小。 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(send_buffer, <span class="string">&quot;content-length: %ld\r\n&quot;</span>, len);</span><br><span class="line">    slen = <span class="built_in">strlen</span>(send_buffer);</span><br><span class="line">    iov[<span class="number">3</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">3</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">3</span>].iov_base, send_buffer, slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 当浏览器看到一行中的&#x27;\r\n&#x27;序列时，它就会明白没有更多的标题了。内容可能随之而来。</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    slen = <span class="built_in">strlen</span>(send_buffer);</span><br><span class="line">    iov[<span class="number">4</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">4</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">4</span>].iov_base, send_buffer, slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_get_method</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> final_path[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 如果一个路径以尾部的斜杠结束，客户端可能希望索引文件在该目录内。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(final_path, <span class="string">&quot;public&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(final_path, path);</span><br><span class="line">        <span class="built_in">strcat</span>(final_path, <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(final_path, <span class="string">&quot;public&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(final_path, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stat()系统调用会给出文件的信息，如类型（普通文件、目录等）、大小等。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">path_stat</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(final_path, &amp;path_stat) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;404 Not Found: %s (%s)\n&quot;</span>, final_path, path);</span><br><span class="line">        handle_http_404(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*检查这是否是一个正常的/常规的文件，而不是一个目录或其他东西。*/</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(path_stat.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            struct request *req = zh_malloc(<span class="keyword">sizeof</span>(*req) + (<span class="keyword">sizeof</span>(struct iovec) * <span class="number">6</span>));</span><br><span class="line">            req-&gt;iovec_count = <span class="number">6</span>;</span><br><span class="line">            req-&gt;client_socket = client_socket;</span><br><span class="line">            send_headers(final_path, path_stat.st_size, req-&gt;iov);</span><br><span class="line">            copy_file_contents(final_path, path_stat.st_size, &amp;req-&gt;iov[<span class="number">5</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;200 %s %ld bytes\n&quot;</span>, final_path, path_stat.st_size);</span><br><span class="line">            add_write_request(req);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            handle_http_404(client_socket);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;404 Not Found: %s\n&quot;</span>, final_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个函数查看所使用的方法，并调用相应的处理函数。因为我们只实现了GET和POST方法，</span></span><br><span class="line"><span class="comment"> * 所以它调用handle_unimplemented_method()，以防这两个方法不匹配。这将向客户发送一个错误。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_http_method</span><span class="params">(<span class="keyword">char</span> *method_buffer, <span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *method, *path, *saveptr;</span><br><span class="line"></span><br><span class="line">    method = strtok_r(method_buffer, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line">    strtolower(method);</span><br><span class="line">    path = strtok_r(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(method, <span class="string">&quot;get&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        handle_get_method(path, client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        handle_unimplemented_method(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">char</span> *dest, <span class="keyword">int</span> dest_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dest_sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">        <span class="keyword">if</span> (src[i] == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; src[i + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_client_request</span><span class="params">(struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> http_request[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">/* 获取第一行，这将是请求的内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (get_line(req-&gt;iov[<span class="number">0</span>].iov_base, http_request, <span class="keyword">sizeof</span>(http_request)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Malformed request\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    handle_http_method(http_request, req-&gt;client_socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server_loop</span><span class="params">(<span class="keyword">int</span> server_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> (struct request *)cqe-&gt;user_data;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            fatal_error(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Async request failed: %s for event: %d\n&quot;</span>,</span><br><span class="line">                    strerror(-cqe-&gt;res), req-&gt;event_type);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (req-&gt;event_type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> EVENT_TYPE_ACCEPT:</span><br><span class="line">            add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">            add_read_request(cqe-&gt;res);</span><br><span class="line">            <span class="built_in">free</span>(req);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EVENT_TYPE_READ:</span><br><span class="line">            <span class="keyword">if</span> (!cqe-&gt;res)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Empty request!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            handle_client_request(req);</span><br><span class="line">            <span class="built_in">free</span>(req-&gt;iov[<span class="number">0</span>].iov_base);</span><br><span class="line">            <span class="built_in">free</span>(req);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EVENT_TYPE_WRITE:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req-&gt;iovec_count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(req-&gt;iov[i].iov_base);</span><br><span class="line">            &#125;</span><br><span class="line">            close(req-&gt;client_socket);</span><br><span class="line">            <span class="built_in">free</span>(req);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将此请求标记为已处理 */</span></span><br><span class="line">        io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;^C pressed. Shutting down.\n&quot;</span>);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_socket = setup_listening_socket(DEFAULT_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    server_loop(server_socket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>运行这个程序</h1><p>这个程序要求您从包含“ public”文件夹的目录中运行它，该文件夹中有一个 <code>index.html</code> 文件和一个图像。<br>如果您按照<a href="https://github.com/shuveb/loti-examples">构建指令</a>到示例程序，那么您新构建的二进制文件应该位于 <code>build</code> 目录中。<br>你需要换到git repo的根目录下，&quot;public &quot;文件夹就在那里，然后运行它。<br>构建所有示例并运行这个 webserver 示例的示例会话如下所示:</p><pre><code>$ mkdir build$ cd build$ cmake ..$ cmake --build .$ cd ..$ build/webserver_liburingMinimum kernel version required is: 5.5Your kernel version is: 5.6ZeroHTTPd listening on port: 8000</code></pre><h2 id="程序结构"><a class="header-anchor" href="#程序结构">¶</a>程序结构</h2><p>首先，main()函数调用 <strong>setup_listening_socket()</strong> 在指定的端口上监听。但是我们不调用accept()来实际接受连接。<br>我们通过io_uring请求来实现这一点，后面会解释。</p><p>程序的核心是**server_loop()**函数，它向io_uring发送提交(自己和通过其他函数)，<br>等待完成队列条目并处理它们。让我们仔细看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server_loop</span><span class="params">(<span class="keyword">int</span> server_socket)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">        add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> (struct request *) cqe-&gt;user_data;</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                        fatal_error(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Async request failed: %s for event: %d\n&quot;</span>,</span><br><span class="line">                                        strerror(-cqe-&gt;res), req-&gt;event_type);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">switch</span> (req-&gt;event_type) &#123;</span><br><span class="line">                        <span class="keyword">case</span> EVENT_TYPE_ACCEPT:</span><br><span class="line">                                add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">                                add_read_request(cqe-&gt;res);</span><br><span class="line">                                <span class="built_in">free</span>(req);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> EVENT_TYPE_READ:</span><br><span class="line">                                <span class="keyword">if</span> (!cqe-&gt;res) &#123;</span><br><span class="line">                                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Empty request!\n&quot;</span>);</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                handle_client_request(req);</span><br><span class="line">                                <span class="built_in">free</span>(req-&gt;iov[<span class="number">0</span>].iov_base);</span><br><span class="line">                                <span class="built_in">free</span>(req);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> EVENT_TYPE_WRITE:</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req-&gt;iovec_count; i++) &#123;</span><br><span class="line">                                        <span class="built_in">free</span>(req-&gt;iov[i].iov_base);</span><br><span class="line">                                &#125;</span><br><span class="line">                                close(req-&gt;client_socket);</span><br><span class="line">                                <span class="built_in">free</span>(req);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 将此请求标记为已处理 */</span></span><br><span class="line">                io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入while循环之前，我们通过调用 <code>add_accept_request()</code> 来提交一个 <code>accept()</code> 的请求。这样就可以接受任何客户端对服务器的连接。让我们仔细看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_accept_request</span><span class="params">(<span class="keyword">int</span> server_socket, struct sockaddr_in *client_addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">socklen_t</span> *client_addr_len)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">        io_uring_prep_accept(sqe, server_socket, (struct sockaddr *) client_addr,</span><br><span class="line">                                                client_addr_len, <span class="number">0</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req));</span><br><span class="line">        req-&gt;event_type = EVENT_TYPE_ACCEPT;</span><br><span class="line">        io_uring_sqe_set_data(sqe, req);</span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得到一个 SQE，并准备一个 accept ()操作，用liburing的io_uring_prep_accept()提交。我们使用一个request结构体来跟踪我们的每个提交。这些实例具有每个请求从一个状态到下一个状态的上下文。让我们来看一下 request 结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> event_type;</span><br><span class="line">        <span class="keyword">int</span> iovec_count;</span><br><span class="line">        <span class="keyword">int</span> client_socket;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户机请求要经过3个状态，上面的结构体可以容纳足够的信息，能够处理这些状态之间的转换。客户端请求的三种状态是:</p><p>Accepted -&gt; Request read -&gt; Response written</p><p>让我们看看在完成侧大的 switch/case 代码块，一旦 <code>accept ()</code> 操作完成后会发生什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EVENT_TYPE_ACCEPT:</span><br><span class="line">     add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     add_read_request(cqe-&gt;res);</span><br><span class="line">     <span class="built_in">free</span>(req);</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>既然已经处理了前一个请求，我们就在提交队列中添加一个新的<code>accept()</code>请求。否则我们的程序将不会接受任何来自客户端的新连接。<br>然后我们调用<code>add_read_request()</code>函数，它为readv()添加一个提交请求，这样我们就可以从客户端读取HTTP请求。<br>这里有几件事:</p><ol><li>我们本来可以使用<code>read()</code>，但是<code>io_uring</code>中直到内核版本5.6才支持该操作，而在撰写本文时，<br>内核版本5.6是一个非常稳定的版本，至少几个月后才会在许多发行版中出现。</li><li>使用<code>readv()</code>和<code>writev()</code>允许我们内置许多通用逻辑，特别是我们稍后会看到的缓冲区管理。现在，让我们看看<code>add_read_request()</code>:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_read_request</span><span class="params">(<span class="keyword">int</span> client_socket)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req) + <span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">        req-&gt;iov[<span class="number">0</span>].iov_base = <span class="built_in">malloc</span>(READ_SZ);</span><br><span class="line">        req-&gt;iov[<span class="number">0</span>].iov_len = READ_SZ;</span><br><span class="line">        req-&gt;event_type = EVENT_TYPE_READ;</span><br><span class="line">        req-&gt;client_socket = client_socket;</span><br><span class="line">        <span class="built_in">memset</span>(req-&gt;iov[<span class="number">0</span>].iov_base, <span class="number">0</span>, READ_SZ);</span><br><span class="line">        <span class="comment">/* Linux kernel 5.5 has support for readv, but not for recv() or read() */</span></span><br><span class="line">        io_uring_prep_readv(sqe, client_socket, &amp;req-&gt;iov[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        io_uring_sqe_set_data(sqe, req);</span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，这是相当直接的。我们分配一个足够大的缓冲区来容纳客户机请求，<br>并在提交请求之前调用 <code>io_uring_prep_readv ()</code>,该调用处于liburing状态。完成端相应的处理是由switch/case块中的条件来完成的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EVENT_TYPE_READ:</span><br><span class="line">    <span class="keyword">if</span> (!cqe-&gt;res) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Empty request!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    handle_client_request(req);</span><br><span class="line">    <span class="built_in">free</span>(req-&gt;iov[<span class="number">0</span>].iov_base);</span><br><span class="line">    <span class="built_in">free</span>(req);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里，我们实际上调用了 <code>handle_client_request()</code> 函数处理 HTTP 请求。如果一切顺利，客户端要求的是磁盘上的一个文件，这段代码运行如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> zh_malloc(<span class="keyword">sizeof</span>(*req) + (<span class="keyword">sizeof</span>(struct iovec) * <span class="number">6</span>));</span><br><span class="line">req-&gt;iovec_count = <span class="number">6</span>;</span><br><span class="line">req-&gt;client_socket = client_socket;</span><br><span class="line">set_headers(final_path, path_stat.st_size, req-&gt;iov);</span><br><span class="line">copy_file_contents(final_path, path_stat.st_size, &amp;req-&gt;iov[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;200 %s %ld bytes\n&quot;</span>, final_path, path_stat.st_size);</span><br><span class="line">add_write_request( req);</span><br></pre></td></tr></table></figure><p>函数 set_headers() 设置了总共5个小缓冲区，由5个不同的 ivec 结构体表示。<br>最终的 iovec 实例包含正在读取的文件的内容。最后，调用 add_write_request ()来添加一个提交队列条目:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_write_request</span><span class="params">(struct request *req)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_WRITE;</span><br><span class="line">    io_uring_prep_writev(sqe, req-&gt;client_socket, req-&gt;iov, req-&gt;iovec_count, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此提交导致内核在客户端套接字上写出响应头和文件内容，从而完成请求/响应循环。以下是我们在完成方面所做的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EVENT_TYPE_WRITE:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req-&gt;iovec_count; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(req-&gt;iov[i].iov_base);</span><br><span class="line">    &#125;</span><br><span class="line">    close(req-&gt;client_socket);</span><br><span class="line">    <span class="built_in">free</span>(req);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>我们释放我们曾经创建的多个指向缓冲区的iovec，释放了请求结构体实例，还关闭了客户端套接字，从而完成了 HTTP 请求的服务。</p><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liburing 实现 cp 命令</title>
      <link href="/jony.github.io/fbcd2bb270f6/"/>
      <url>/jony.github.io/fbcd2bb270f6/</url>
      
        <content type="html"><![CDATA[<h1>liburing 实现 cp 命令</h1><p>在前面的小节中，我们看到了如何使用liburing提供的高级接口来构建相当于Unix cat的工具。<br>然而，在这两个例子中，我们队列没有同时处理超过一个请求。 io_uring的目标之一是能够通过<br>让用户同时排队几个操作来减少系统调用的数量，这样内核就可以一下子接收并处理这些操作，<br>而不需要程序为每个I/O请求进行一次或多次系统调用。</p><p>为此，在本部分中，我们构建一个复制文件的复制程序。它试图通过队<br>列深度允许的尽可能多的请求进来，这样尽量提高效率。让我们看看一些代码。<br>这在很大程度上是基于 <a href="https://github.com/axboe/fio/blob/master/t/io_uring.c">fio 包</a> 中的一个程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QD  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BS (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> infd, outfd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> read;</span><br><span class="line">    <span class="keyword">off_t</span> first_offset, offset;</span><br><span class="line">    <span class="keyword">size_t</span> first_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setup_context</span><span class="params">(<span class="keyword">unsigned</span> entries, struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = io_uring_queue_init(entries, ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;queue_init: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> *size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(st.st_mode)) &#123;</span><br><span class="line">        *size = st.st_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        *size = bytes;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue_prepped</span><span class="params">(struct io_uring *ring, struct io_data *data)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    assert(sqe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;read)</span><br><span class="line">        io_uring_prep_readv(sqe, infd, &amp;data-&gt;iov, <span class="number">1</span>, data-&gt;offset);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        io_uring_prep_writev(sqe, outfd, &amp;data-&gt;iov, <span class="number">1</span>, data-&gt;offset);</span><br><span class="line"></span><br><span class="line">    io_uring_sqe_set_data(sqe, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_read</span><span class="params">(struct io_uring *ring, <span class="keyword">off_t</span> size, <span class="keyword">off_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(*data));</span><br><span class="line">    <span class="keyword">if</span> (!data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data-&gt;read = <span class="number">1</span>;</span><br><span class="line">    data-&gt;offset = data-&gt;first_offset = offset;</span><br><span class="line"></span><br><span class="line">    data-&gt;iov.iov_base = data + <span class="number">1</span>;</span><br><span class="line">    data-&gt;iov.iov_len = size;</span><br><span class="line">    data-&gt;first_len = size;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_readv(sqe, infd, &amp;data-&gt;iov, <span class="number">1</span>, offset);</span><br><span class="line">    io_uring_sqe_set_data(sqe, data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue_write</span><span class="params">(struct io_uring *ring, struct io_data *data)</span> </span>&#123;</span><br><span class="line">    data-&gt;read = <span class="number">0</span>;</span><br><span class="line">    data-&gt;offset = data-&gt;first_offset;</span><br><span class="line"></span><br><span class="line">    data-&gt;iov.iov_base = data + <span class="number">1</span>;</span><br><span class="line">    data-&gt;iov.iov_len = data-&gt;first_len;</span><br><span class="line"></span><br><span class="line">    queue_prepped(ring, data);</span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_file</span><span class="params">(struct io_uring *ring, <span class="keyword">off_t</span> insize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reads, writes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">off_t</span> write_left, offset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write_left = insize;</span><br><span class="line">    writes = reads = offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (insize || write_left) &#123;</span><br><span class="line">        <span class="keyword">int</span> had_reads, got_comp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 尽可能多地排队读取 */</span></span><br><span class="line">        had_reads = reads;</span><br><span class="line">        <span class="keyword">while</span> (insize) &#123;</span><br><span class="line">            <span class="keyword">off_t</span> this_size = insize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (reads + writes &gt;= QD)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (this_size &gt; BS)</span><br><span class="line">                this_size = BS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!this_size)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (queue_read(ring, this_size, offset))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            insize -= this_size;</span><br><span class="line">            offset += this_size;</span><br><span class="line">            reads++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (had_reads != reads) &#123;</span><br><span class="line">            ret = io_uring_submit(ring);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;io_uring_submit: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 此时队列已满。让我们至少找到一个 completion */</span></span><br><span class="line">        got_comp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (write_left) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!got_comp) &#123;</span><br><span class="line">                ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">                got_comp = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret = io_uring_peek_cqe(ring, &amp;cqe);</span><br><span class="line">                <span class="keyword">if</span> (ret == -EAGAIN) &#123;</span><br><span class="line">                    cqe = <span class="literal">NULL</span>;</span><br><span class="line">                    ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;io_uring_peek_cqe: %s\n&quot;</span>,</span><br><span class="line">                        strerror(-ret));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!cqe)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            data = io_uring_cqe_get_data(cqe);</span><br><span class="line">            <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cqe-&gt;res == -EAGAIN) &#123;</span><br><span class="line">                    queue_prepped(ring, data);</span><br><span class="line">                    io_uring_cqe_seen(ring, cqe);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;cqe failed: %s\n&quot;</span>,</span><br><span class="line">                        strerror(-cqe-&gt;res));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cqe-&gt;res != data-&gt;iov.iov_len) &#123;</span><br><span class="line">                <span class="comment">/*短时间读/写；调整并重新排队 */</span></span><br><span class="line">                data-&gt;iov.iov_base += cqe-&gt;res;</span><br><span class="line">                data-&gt;iov.iov_len -= cqe-&gt;res;</span><br><span class="line">                queue_prepped(ring, data);</span><br><span class="line">                io_uring_cqe_seen(ring, cqe);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 全都做完了。如果写了，就没别的事可做了。如果读取，则将相应的写入排队。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data-&gt;read) &#123;</span><br><span class="line">                queue_write(ring, data);</span><br><span class="line">                write_left -= data-&gt;first_len;</span><br><span class="line">                reads--;</span><br><span class="line">                writes++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">free</span>(data);</span><br><span class="line">                writes--;</span><br><span class="line">            &#125;</span><br><span class="line">            io_uring_cqe_seen(ring, cqe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="keyword">off_t</span> insize;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;infile&gt; &lt;outfile&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (infd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open infile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outfd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open outfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_context(QD, &amp;ring))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (get_file_size(infd, &amp;insize))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ret = copy_file(&amp;ring, insize);</span><br><span class="line"></span><br><span class="line">    close(infd);</span><br><span class="line">    close(outfd);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>程序结构</h1><p>这个复制程序像大多数其他程序一样，将第一个参数指向的文件复制到第二个参数指向的文件中。<br>该程序的核心是 <strong><code>copy_ file()</code></strong> 函数。在这里，我们设置了一个外层的 <code>while</code> 循环，而这个循环又包含了另外2个嵌套在同一层次的 <code>while</code> 循环。虽然外层的 while 循环是为了确保源文件的所有字节都被复制，但是第一个嵌套 <code>while</code> 循环的任务是创建尽可能多的 <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a> 类型请求。事实上，<br>它排队的数量是队列深度允许的数量。</p><p>一旦队列满了，我们就进入第二个嵌套的 <code>while</code> 循环。这个循环收集完成队列条目，<br>并提交写入目标文件的请求，现在数据已经被读取。有几个变量跟踪状态，可能会有点混乱。但异步文件复制程序能有多难呢？:)</p><p>基于 <a href="unixism.net/2020/04/io-uring-by-example-part-2-queuing-multiple-requests/">unixism.net/2020/04/io-uring-by-example-part-2-queuing-multiple-requests/</a></p><h1>源码</h1><p>此示例和其他示例的源代码可在<a href="https://github.com/shuveb/loti-examples">Github</a>上使用。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liburing 实现 cat 命令</title>
      <link href="/jony.github.io/33f4e488c2f3/"/>
      <url>/jony.github.io/33f4e488c2f3/</url>
      
        <content type="html"><![CDATA[<h1>cat 使用 liburing 实现</h1><p>我们看到，用io_uring构建一个读取文件的程序这么简单的东西，可能并不那么简单。事实证明，与读取同步 i/o 文件的程序相比，它的代码更多。但是，如果你分析使用<a href="https://unixism.net/loti/low_level.html#low-level">底层 io _ uring 接口的 cat 实用程序</a>的代码，你会发现大部分代码都是重复代码，可以很容易地隐藏在一个单独的文件中，它应该不会出现在应用逻辑。无论如何，无论如何，我们学习底层的io_uring细节是为了更好地理解它的工作原理。现在，让我们看看如何使用 liburing 实现功能类似的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SZ    1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">off_t</span> file_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovecs</span>[];</span>      <span class="comment">/* Referred by readv/writev */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回传入打开文件描述符的文件的大小。 </span></span><br><span class="line"><span class="comment">* 正确处理常规文件和块设备。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bytes;</span><br><span class="line">        <span class="comment">// 获取文件字节大小64位</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(st.st_mode))</span><br><span class="line">        <span class="keyword">return</span> st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出一串长度为len的字符到stdout。</span></span><br><span class="line"><span class="comment"> * 我们在这里使用缓冲输出是有效的，因为我们需要逐字符输出。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_to_console</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        fputc(*buf++, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 等待完成可用，从readv操作中获取数据并打印到控制台。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_completion_and_print</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="comment">// 等待完成队列</span></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果完成队列的事件代码小于0</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Async readv failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取完成队列的数据返回</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span> =</span> io_uring_cqe_get_data(cqe);</span><br><span class="line">    <span class="comment">// 文件字节大小初一数据块大小，按照 1024 字节切割</span></span><br><span class="line">    <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) fi-&gt;file_sz / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">if</span> (fi-&gt;file_sz % BLOCK_SZ) blocks++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks; i ++)</span><br><span class="line">        output_to_console(fi-&gt;iovecs[i].iov_base, fi-&gt;iovecs[i].iov_len);</span><br><span class="line"></span><br><span class="line">    io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过liburing提交readv请求</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">submit_read_request</span><span class="params">(<span class="keyword">char</span> *file_path, struct io_uring *ring)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">int</span> file_fd = open(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="keyword">off_t</span> file_sz = get_file_size(file_fd);</span><br><span class="line">    <span class="comment">// 文件剩余字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> bytes_remaining = file_sz;</span><br><span class="line">    <span class="comment">// 偏移值</span></span><br><span class="line">    <span class="keyword">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前块大小</span></span><br><span class="line">    <span class="keyword">int</span> current_block = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算文件可以切割多少快</span></span><br><span class="line">    <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) file_sz / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">if</span> (file_sz % BLOCK_SZ) blocks++;</span><br><span class="line">    <span class="comment">// 分配文件大小信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*fi) + (<span class="keyword">sizeof</span>(struct iovec) * blocks));</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">char</span> *buff = <span class="built_in">malloc</span>(file_sz);</span><br><span class="line">    <span class="keyword">if</span> (!buff) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to allocate memory.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对于我们需要读取的文件的每个块，</span></span><br><span class="line"><span class="comment">     * 我们分配一个iovec结构，它被索引到iovecs数组中。 </span></span><br><span class="line"><span class="comment">     * 此数组作为提交的一部分传入。 如果您不明白这一点，</span></span><br><span class="line"><span class="comment">     * 那么您需要查找readv()和writev()系统调用是如何工作的。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span> (bytes_remaining) &#123;</span><br><span class="line">        <span class="keyword">off_t</span> bytes_to_read = bytes_remaining;</span><br><span class="line">        <span class="comment">// 每次最多读 1024 字节</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_read &gt; BLOCK_SZ)</span><br><span class="line">            bytes_to_read = BLOCK_SZ;</span><br><span class="line">        <span class="comment">// 偏移值</span></span><br><span class="line">        offset += bytes_to_read;</span><br><span class="line"></span><br><span class="line">        fi-&gt;iovecs[current_block].iov_len = bytes_to_read;</span><br><span class="line">        <span class="keyword">void</span> *buf;</span><br><span class="line">        <span class="comment">// posix_memalign:https://blog.csdn.net/wallwind/article/details/7461701</span></span><br><span class="line">        <span class="comment">// 动态分配内存，1024 字节对齐</span></span><br><span class="line">        <span class="keyword">if</span>( posix_memalign(&amp;buf, BLOCK_SZ, BLOCK_SZ)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据的基地地址</span></span><br><span class="line">        fi-&gt;iovecs[current_block].iov_base = buf;</span><br><span class="line">        <span class="comment">// 当前块大小加一</span></span><br><span class="line">        current_block++;</span><br><span class="line">        <span class="comment">// 剩余字节数减一</span></span><br><span class="line">        bytes_remaining -= bytes_to_read;</span><br><span class="line">    &#125;</span><br><span class="line">    fi-&gt;file_sz = file_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取一个 SQE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line">    <span class="comment">/* 设置读操作n */</span></span><br><span class="line">    io_uring_prep_readv(sqe, file_fd, fi-&gt;iovecs, blocks, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 设置用户数据 */</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, fi);</span><br><span class="line">    <span class="comment">/* 最后提交请求 */</span></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [file name] &lt;[file name] ...&gt;\n&quot;</span>,</span><br><span class="line">                argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize io_uring */</span></span><br><span class="line">    io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = submit_read_request(argv[i], &amp;ring);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error reading file: %s\n&quot;</span>, argv[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        get_completion_and_print(&amp;ring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the clean-up function. */</span></span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复的代码被提取后。让我们快速浏览一下。我们像这样初始化 io_uring:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在方法 submit_read_request()中，我们得到一个 SQE，准备执行 readv 操作并提交它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取一个 SQE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line"><span class="comment">/* 设置一个 readv 操作 */</span></span><br><span class="line">io_uring_prep_readv(sqe, file_fd, fi-&gt;iovecs, blocks, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 设置 user_data */</span></span><br><span class="line">io_uring_sqe_set_data(sqe, fi);</span><br><span class="line"><span class="comment">/* 最后提交请求 */</span></span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure><p>我们等待一个完成事件，然后得到我们在提交端设置的用户数据，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span> =</span> io_uring_cqe_get_data(cqe);</span><br></pre></td></tr></table></figure><p>当然，与使用原始界面相比，使用这个界面要简单得多。</p><h1>参考</h1><ul><li><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_readv">io_uring_prep_readv()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_sqe_set_data">io_uring_sqe_set_data()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a></li><li><a href="https://unixism.net/loti/ref-liburing/completion.html#c.io_uring_wait_cqe">io_uring_wait_cqe()</a></li><li><a href="https://unixism.net/loti/ref-liburing/completion.html#c.io_uring_cqe_get_data">io_uring_cqe_get_data()</a></li><li><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_exit">io_uring_queue_exit()</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io_uring 底层接口</title>
      <link href="/jony.github.io/3d70b9e6d77f/"/>
      <url>/jony.github.io/3d70b9e6d77f/</url>
      
        <content type="html"><![CDATA[<h1>io_uring 的底层接口</h1><p>正如在前一个文章中所建议的那样，您不太可能在正式的程序中使用 <code>io_uring</code> 底层的 API。但是知道接口真正使用起来是什么样的方式总是一个好主意。为此，您必须通过共享环缓冲区和相关的 <code>io_uring</code> 系统调用来处理 <code>io_uring</code> 直接呈现给程序的接口。一个很好、简单的例子，可以很好地展示这个接口。为此，在这里，我们提供了一个模拟 Unix cat 实用程序的示例。为了保持简单，我们将创建一个程序，一次显示一个操作，等待它完成并显示下一个操作等等。虽然一个真正的程序也可以使用同步/阻塞调用来以这种方式完成工作，但这个程序的主要目的是让您熟悉 i/o 接口，而不会受到其他程序逻辑的干扰。</p><h2 id="熟悉readv（2）系统调用"><a class="header-anchor" href="#熟悉readv（2）系统调用">¶</a>熟悉<a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv（2）</a>系统调用</h2><p>为了更好地理解这个示例，您需要熟悉 <code>[readv（2）](http://man7.org/linux/man-pages/man2/readv.2.html)</code>系统调用。如果你不熟悉它，我建议你读<a href="https://unixism.net/2020/04/io-uring-by-example-part-1-introduction/">一个更通俗的介绍</a>，然后回到这里继续。</p><h2 id="底层接口介绍"><a class="header-anchor" href="#底层接口介绍">¶</a>底层接口介绍</h2><p>它的接口很简单。有一个提交队列和一个完成队列。在提交队列中，您可以提交你想要完成的各种操作的信息。例如，在我们当前的程序中，我们希望使用 <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv（2）</a>读取文件，因此我们放置一个提交队列请求，将其描述为提交队列条目(SQE)的一部分。此外，您可以放置多个请求。根据队列深度(您可以定义)允许的请求数量。这些操作可以是读、写等操作的混合。这些操作可以是读、写等操作的混合。然后，我们调用 <code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code>系统调用，告诉内核我们已经向提交队列添加了请求。一旦它完成了这些请求的处理，它将结果作为 CQE 的一部分放置在完成队列中，或者为每个相应的 SQE 放置一个完成队列条目。这些 CQEs 可以立即从用户空间访问，因为它们被放置在一个由内核和用户空间共享的缓冲区中。</p><p>我们在前面已经讨论了 io_uring 的这个特殊优点，但是聪明的读者会注意到这样一个接口: 用多个 i/o 请求填充到一个队列中，然后进行一次系统调用的接口，而不是对每个I/O请求进行一次系统调用，这样就已经很高效了。为了进一步提高效率，<code>io_uring</code> 支持了一种模式，在这种模式下，内核会对你加入提交队列的条目进行轮询，<br>而你甚至不需要调用 **<code>[io_uring_enter ()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code>**来通知内核更新的提交队列条目。另一点需要注意的是，<br>在 <strong>Specter</strong> 和 <strong>Meltdown</strong> 硬件漏洞被发现并且操作系统为其创建了解决方案之后，系统调用比以往任何时候都要昂贵。因此，对于高性能应用程序来说，减少系统调用的数量确实是一件大事。</p><p>在执行这些操作之前，需要设置队列，它们实际上是具有一定深度/长度的环形缓冲区。<br>您可以调用 **<code>[io_ uring_setup ()](https://unixism.net/loti/ref-iouring/io_uring_setup.html#c.io_uring_setup)</code>**系统调用来完成此操作。我们通过将提交队列条目添加到循环缓冲区并从完成队<br>列循环缓冲区读取完成队列条目来完成真正的工作。这是对这个io_uring接口设计的概述。</p><h2 id="完成队列条目"><a class="header-anchor" href="#完成队列条目">¶</a>完成队列条目</h2><p>现在我们已经有了一个关于如何工作的心智模型，让我们更详细地看看这是如何完成的。与提交队列条目(SQE)相比，<br>完成队列条目(CQE)非常简单。那么，让我们先来看看。SQE 是一个 <strong><code>io_uring_sqe</code></strong> 结构的实例，您可以使用它提交请求。<br>将其添加到提交环缓冲区。CQE 是一个 <strong>io_uring_cqe</strong> 结构的实例，内核对添加到提交队列中的每个 <strong><code>io_uring_sqe</code></strong> 结构实例进行响应。它包含您通过 SQE 实例请求的操作的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">  __u64  user_data;   <span class="comment">/* sqe-&gt;user_data submission passed back */</span></span><br><span class="line">  __s32  res;         <span class="comment">/* 此事件的结果代码 */</span></span><br><span class="line">  __u32  flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="将完成与提交相关联"><a class="header-anchor" href="#将完成与提交相关联">¶</a>将完成与提交相关联</h2><p>正如在代码注释中提到的，<strong>user_data</strong> 字段是按原样从 SQE 传递到 CQE 实例的。假设您在提交队列中提交了一组请求，那么这些请求不一定以相同的顺序完成，<br>也不必以 CQEs 的身份出现在完成队列中。以下面的场景为例: 您的机器上有两个磁盘: 一个是慢速旋转的硬盘驱动器，另一个是超快的 SSD。<br>您在提交队列中提交2个请求。第一个在慢速旋转的硬盘上读取100kB 的文件，第二个在快速固态硬盘上读取同样大小的文件。<br>如果维护排序，即使来自 SSD 文件的数据会更早到达，内核是否应该等待来自旋转硬盘上的文件的数据变得可用？这是个不好的想法，<br>因为这会阻止我们以最快的速度运行。因此，当 CQEs 可用时，它们可以按任意顺序到达。无论哪个操作完成，其结果都会在 CQ 上公布。<br>由于 CQEs 的到达没有特定的顺序，现在你已经知道了从上面的 <strong>io_uring_cqe</strong> 结构中看到的 CQE 是什么样子的，你如何识别一个特定 CQE 对应的 SQE 请求？一种方法是使用 SQEs 和 CQEs 共有的 <strong>user_data</strong> 字段来标识完成情况。并不是说你要设置一个唯一的 ID 或者其他什么，而是你通常会传递一个指针。如果你对此感到困惑，那就等着看后面的例子吧。</p><p>完成队列条目很简单，因为它主要关注系统调用的返回值，这个返回值在 res 字段中返回。例如，如果您读取操作队列成功执行完成，那么它将包含读取的字节数。如果有错误，它将包含一个负的错误号。本质上，**<a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>**系统调用自身的内容将返回。</p><h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2><p>虽然我提到了 CQEs 可以以任何顺序到达，但是您可以强制使用 SQE 排序对某些操作进行排序，实际上是将它们链接起来。有关更多细节，请参见<a href="https://unixism.net/loti/tutorial/link_liburing.html#link-liburing">链接</a>请求教程。</p><h2 id="提交队列条目"><a class="header-anchor" href="#提交队列条目">¶</a>提交队列条目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">     <span class="keyword">void</span>  *iov_base;    <span class="comment">/*开始地址 */</span></span><br><span class="line">     <span class="keyword">size_t</span> iov_len;     <span class="comment">/*要传输的字节数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>iovec 每个结构只指向一个缓冲区。基址和长度。</p><p>submission 队列条目比 completion 队列条目稍微复杂一些，因为它需要足够通用，以表示和处理目前 Linux 可能采用的各种 i/o操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">  __u8  opcode;   <span class="comment">/* 指定操作类型 */</span></span><br><span class="line">  __u8  flags;    <span class="comment">/* IOSQE_ 标记 */</span></span><br><span class="line">  __u16  ioprio;  <span class="comment">/* ioprio 请求 */</span></span><br><span class="line">  __s32  fd;      <span class="comment">/* 要执行 IO 的文件描述符 */</span></span><br><span class="line">  __u64  off;     <span class="comment">/* 文件偏移 */</span></span><br><span class="line">  __u64  addr;    <span class="comment">/* 指向缓冲区或者iovecs */</span></span><br><span class="line">  __u32  len;     <span class="comment">/* 缓冲区大小或者iovecs 数量 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">__kernel_rwf_t</span>  rw_flags;</span><br><span class="line">    __u32    fsync_flags;</span><br><span class="line">    __u16    poll_events;</span><br><span class="line">    __u32    sync_range_flags;</span><br><span class="line">    __u32    msg_flags;</span><br><span class="line">  &#125;;</span><br><span class="line">  __u64  user_data;   <span class="comment">/* 完成时传回的数据  */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    __u16  buf_index; <span class="comment">/* 索引到固定缓冲区（如果使用） */</span></span><br><span class="line">    __u64  __pad2[<span class="number">3</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我知道这个结构看起来很繁杂。通常使用的字段只有少数，这很容易用一个简单的例子来解释，<br>比如我们正在处理的这个字段: cat。当你想使用 <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a>系统调用读取一个文件时:</p><ul><li>opcode 用于指定操作，在这个case 中， <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a> 使用的是 <strong>IORING_OP_READV</strong> 常量</li><li>fd 用于指定表示要从中读取的文件的文件描述符</li><li>addr 用于指向 iovec 结构的数组，这些结构包含我们为 i/o 分配的缓冲区的地址和长度。</li><li>len  用于保存 iovec 结构的数组的长度。</li></ul><p>这并不是很难，不是吗？你填写这些值，让 io_uring 知道该做什么。你可以将多个SQE 加入队列，最后当你想让内核开始处理你 SQE 队列的请求时，调用 <strong><code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code></strong> 。</p><h2 id="使用-io-uring-实现-cat-命令"><a class="header-anchor" href="#使用-io-uring-实现-cat-命令">¶</a>使用 io_uring 实现 cat 命令</h2><p>让我们看看如何通过使用底层 <strong>io_uring</strong> 接口的来实现类似 cat 实用程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果你编译失败缺少这个头文件，那么是因为你得内核版本太低了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SZ    1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  x86规范 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_barrier()  __asm__ __volatile__(<span class="meta-string">&quot;&quot;</span>:::<span class="meta-string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_barrier() __asm__ __volatile__(<span class="meta-string">&quot;&quot;</span>:::<span class="meta-string">&quot;memory&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">struct io_uring_sqe &#123;</span></span><br><span class="line"><span class="comment">  __u8  opcode;   // sqe 操作类型代码</span></span><br><span class="line"><span class="comment">  __u8  flags;    // IOSQE_ flags </span></span><br><span class="line"><span class="comment">  __u16  ioprio;  // 请求ioprio</span></span><br><span class="line"><span class="comment">  __s32  fd;      // 执行IO操作的文件描述符</span></span><br><span class="line"><span class="comment">  __u64  off;     // 文件中的偏移量 </span></span><br><span class="line"><span class="comment">  __u64  addr;    // 指向缓冲区或iovecs的指针</span></span><br><span class="line"><span class="comment">  __u32  len;     // 缓冲区大小或iovecs数量</span></span><br><span class="line"><span class="comment">  union &#123;</span></span><br><span class="line"><span class="comment">    __kernel_rwf_t  rw_flags;</span></span><br><span class="line"><span class="comment">    __u32    fsync_flags;</span></span><br><span class="line"><span class="comment">    __u16    poll_events;</span></span><br><span class="line"><span class="comment">    __u32    sync_range_flags;</span></span><br><span class="line"><span class="comment">    __u32    msg_flags;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">  __u64  user_data;   // 完成时要传回的数据</span></span><br><span class="line"><span class="comment">  union &#123;</span></span><br><span class="line"><span class="comment">    __u16  buf_index; // 索引到固定缓冲区(如果使用)</span></span><br><span class="line"><span class="comment">    __u64  __pad2[3];</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct io_uring_params &#123;</span></span><br><span class="line"><span class="comment">  __u32 sq_entries;</span></span><br><span class="line"><span class="comment">  __u32 cq_entries;</span></span><br><span class="line"><span class="comment">  __u32 flags;</span></span><br><span class="line"><span class="comment">  __u32 sq_thread_cpu;</span></span><br><span class="line"><span class="comment">  __u32 sq_thread_idle;</span></span><br><span class="line"><span class="comment">  __u32 resv[5];</span></span><br><span class="line"><span class="comment">  struct io_sqring_offsets sq_off;</span></span><br><span class="line"><span class="comment">  struct io_cqring_offsets cq_off;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> &#123;</span> <span class="comment">// Submission ring</span></span><br><span class="line">    <span class="keyword">unsigned</span> *head;</span><br><span class="line">    <span class="keyword">unsigned</span> *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_entries;</span><br><span class="line">    <span class="keyword">unsigned</span> *flags;</span><br><span class="line">    <span class="keyword">unsigned</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> &#123;</span> <span class="comment">// completions ring</span></span><br><span class="line">    <span class="keyword">unsigned</span> *head;</span><br><span class="line">    <span class="keyword">unsigned</span> *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_entries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqes</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">submitter</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ring_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> <span class="title">sq_ring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> <span class="title">cq_ring</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">off_t</span> file_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovecs</span>[];</span>      <span class="comment">/* Referred by readv/writev */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这段代码是在io_uring相关的系统调用不属于标准C库的时候编写的。 </span></span><br><span class="line"><span class="comment">* 所以，我们推出了自己的系统调用封装函数。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_setup</span><span class="params">(<span class="keyword">unsigned</span> entries, struct io_uring_params *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) syscall(__NR_io_uring_setup, entries, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_enter</span><span class="params">(<span class="keyword">int</span> ring_fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> to_submit,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> min_complete, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) syscall(__NR_io_uring_enter, ring_fd, to_submit, min_complete,</span><br><span class="line">                flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回传入的打开文件描述符的文件大小。也能正确处理常规文件和驱动设备。很好。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bytes;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(st.st_mode))</span><br><span class="line">        <span class="keyword">return</span> st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* io_uring需要进行大量的设置，这些设置看起来相当复杂，但并不都很难理解。</span></span><br><span class="line"><span class="comment">* 因为所有这些案例代码， 都在 io_uring的作者创建的liburing中，而且 liburing 相对容易使用。</span></span><br><span class="line"><span class="comment">* 但是，您应该花些时间来理解这段代码。</span></span><br><span class="line"><span class="comment">* 了解它的工作原理总是好的。出去好吹牛逼</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">app_setup_uring</span><span class="params">(struct submitter *s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> *<span class="title">sring</span> =</span> &amp;s-&gt;sq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> *<span class="title">cring</span> =</span> &amp;s-&gt;cq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *sq_ptr, *cq_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 我们需要将 io_uring_params 结构传递给的io_uring_setup（）调用并初始化为0。 </span></span><br><span class="line"><span class="comment">    * 如果需要，我们可以设置任何标志，但是对于本示例，我们不需要，因为这里只是做了简单的了解。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// io_uring_setup 返回值将用于调用 mmap 将两个环缓冲区和一组提交队列映射到用户空间</span></span><br><span class="line">    s-&gt;ring_fd = io_uring_setup(QUEUE_DEPTH, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ring_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_setup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * io_uring 通过两个 kernel-user 共享空间形成环形缓冲区通信。在最近的内核中，可以用 mmap() 调用来</span></span><br><span class="line"><span class="comment">    * 联合映射这个环形缓冲区。在直接操作完成队列时，提交队列有一个介于两者之间的间接数组。我们把它也映射进去。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sring_sz = p.sq_off.<span class="built_in">array</span> + p.sq_entries * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>);</span><br><span class="line">    <span class="keyword">int</span> cring_sz = p.cq_off.cqes + p.cq_entries * <span class="keyword">sizeof</span>(struct io_uring_cqe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 在内核版本 5.4 及以上，可能使用一个 mmap()  来映射 completion 缓冲区和 submission缓冲区.</span></span><br><span class="line"><span class="comment">    * 如果去检测内核版本还不如直接使用 io_uring_params 结构的特征字段，这是一个位掩码。如果设置了 IORING_FEAT_SINGLE_MMAP </span></span><br><span class="line"><span class="comment">    * 那么我们就可以不用再调用第二个mmap()来映射 CQ ring。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cring_sz &gt; sring_sz) &#123;</span><br><span class="line">            sring_sz = cring_sz;</span><br><span class="line">        &#125;</span><br><span class="line">        cring_sz = sring_sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * submission 队列和 completion 队列可以映射到 ring 缓冲区，但是老版本的内核只能映射到队列中。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    sq_ptr = mmap(<span class="number">0</span>, sring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">            MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line">    <span class="keyword">if</span> (sq_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">        cq_ptr = sq_ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 在旧的内核中分别映射完成队列环缓冲区 */</span></span><br><span class="line">        cq_ptr = mmap(<span class="number">0</span>, cring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_SHARED | MAP_POPULATE,</span><br><span class="line">                s-&gt;ring_fd, IORING_OFF_CQ_RING);</span><br><span class="line">        <span class="keyword">if</span> (cq_ptr == MAP_FAILED) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  将有用的字段保存在全局app_io_sq_ring结构中，以便以后方便地引用*/</span></span><br><span class="line">    sring-&gt;head = sq_ptr + p.sq_off.head;</span><br><span class="line">    sring-&gt;tail = sq_ptr + p.sq_off.tail;</span><br><span class="line">    sring-&gt;ring_mask = sq_ptr + p.sq_off.ring_mask;</span><br><span class="line">    sring-&gt;ring_entries = sq_ptr + p.sq_off.ring_entries;</span><br><span class="line">    sring-&gt;flags = sq_ptr + p.sq_off.flags;</span><br><span class="line">    sring-&gt;<span class="built_in">array</span> = sq_ptr + p.sq_off.<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射到提交队列条目数组中 */</span></span><br><span class="line">    s-&gt;sqes = mmap(<span class="number">0</span>, p.sq_entries * <span class="keyword">sizeof</span>(struct io_uring_sqe),</span><br><span class="line">            PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_SQES);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;sqes == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将有用的字段保存在全局的app_io_cq_ring结构中，以便以后方便地引用 */</span></span><br><span class="line">    cring-&gt;head = cq_ptr + p.cq_off.head;</span><br><span class="line">    cring-&gt;tail = cq_ptr + p.cq_off.tail;</span><br><span class="line">    cring-&gt;ring_mask = cq_ptr + p.cq_off.ring_mask;</span><br><span class="line">    cring-&gt;ring_entries = cq_ptr + p.cq_off.ring_entries;</span><br><span class="line">    cring-&gt;cqes = cq_ptr + p.cq_off.cqes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将长度为len的字符串输出到标准输出。我们在这里使用缓冲输出以提高效率，因为我们需要逐字符输出。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_to_console</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        fputc(*buf++, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从 completion 队列读取。在这个函数中，我们从 completion 队列中读取完成事件，</span></span><br><span class="line"><span class="comment">* 获取包含文件数据的数据缓冲区，并将其打印到控制台。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_from_cq</span><span class="params">(struct submitter *s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> *<span class="title">cring</span> =</span> &amp;s-&gt;cq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> head, reaped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    head = *cring-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read_barrier();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 记住，这是一个环形缓冲区。如果head == tail，则表示缓冲区为空。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (head == *cring-&gt;tail)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取一个条目 */</span></span><br><span class="line">        cqe = &amp;cring-&gt;cqes[head &amp; *s-&gt;cq_ring.ring_mask];</span><br><span class="line">        fi = (struct file_info*) cqe-&gt;user_data;</span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(<span class="built_in">abs</span>(cqe-&gt;res)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) fi-&gt;file_sz / BLOCK_SZ;</span><br><span class="line">        <span class="keyword">if</span> (fi-&gt;file_sz % BLOCK_SZ) blocks++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks; i++)</span><br><span class="line">            output_to_console(fi-&gt;iovecs[i].iov_base, fi-&gt;iovecs[i].iov_len);</span><br><span class="line"></span><br><span class="line">        head++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *cring-&gt;head = head;</span><br><span class="line">    write_barrier();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 提交到 submission 队列.</span></span><br><span class="line"><span class="comment">* 在这个方法, 我们提交请求到 submission 队列. </span></span><br><span class="line"><span class="comment">* 您可以提交多种类型的请求。我们的将是readv()请求，我们通过IORING_OP_READV来指定。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">submit_to_sq</span><span class="params">(<span class="keyword">char</span> *file_path, struct submitter *s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> file_fd = open(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> *<span class="title">sring</span> =</span> &amp;s-&gt;sq_ring;</span><br><span class="line">    <span class="keyword">unsigned</span> index = <span class="number">0</span>, current_block = <span class="number">0</span>, tail = <span class="number">0</span>, next_tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">off_t</span> file_sz = get_file_size(file_fd);</span><br><span class="line">    <span class="keyword">if</span> (file_sz &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">off_t</span> bytes_remaining = file_sz;</span><br><span class="line">    <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) file_sz / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">if</span> (file_sz % BLOCK_SZ) blocks++;</span><br><span class="line"></span><br><span class="line">    fi = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*fi) + <span class="keyword">sizeof</span>(struct iovec) * blocks);</span><br><span class="line">    <span class="keyword">if</span> (!fi) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to allocate memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fi-&gt;file_sz = file_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对于需要读取的每个文件块，我们分配一个iovec结构体，该结构体被索引到iovecs数组中。</span></span><br><span class="line"><span class="comment">    * 此数组作为提交的一部分传入。如果您不理解这一点，那么您需要查看readv()和writev()系统调用是如何工作的。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">while</span> (bytes_remaining) &#123;</span><br><span class="line">        <span class="keyword">off_t</span> bytes_to_read = bytes_remaining;</span><br><span class="line">        <span class="keyword">if</span> (bytes_to_read &gt; BLOCK_SZ)</span><br><span class="line">            bytes_to_read = BLOCK_SZ;</span><br><span class="line"></span><br><span class="line">        fi-&gt;iovecs[current_block].iov_len = bytes_to_read;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *buf;</span><br><span class="line">        <span class="keyword">if</span>( posix_memalign(&amp;buf, BLOCK_SZ, BLOCK_SZ)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fi-&gt;iovecs[current_block].iov_base = buf;</span><br><span class="line"></span><br><span class="line">        current_block++;</span><br><span class="line">        bytes_remaining -= bytes_to_read;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将我们的 submission 队列条目添加到SQE ring缓冲区的尾部 */</span></span><br><span class="line">    next_tail = tail = *sring-&gt;tail;</span><br><span class="line">    next_tail++;</span><br><span class="line">    read_barrier();</span><br><span class="line">    index = tail &amp; *s-&gt;sq_ring.ring_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> &amp;s-&gt;sqes[index];</span><br><span class="line">    sqe-&gt;fd = file_fd;</span><br><span class="line">    sqe-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    sqe-&gt;opcode = IORING_OP_READV;</span><br><span class="line">    sqe-&gt;addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fi-&gt;iovecs;</span><br><span class="line">    sqe-&gt;len = blocks;</span><br><span class="line">    sqe-&gt;off = <span class="number">0</span>;</span><br><span class="line">    sqe-&gt;user_data = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) fi;</span><br><span class="line">    sring-&gt;<span class="built_in">array</span>[index] = index;</span><br><span class="line">    tail = next_tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新尾部以便内核能够看到它. */</span></span><br><span class="line">    <span class="keyword">if</span>(*sring-&gt;tail != tail) &#123;</span><br><span class="line">        *sring-&gt;tail = tail;</span><br><span class="line">        write_barrier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 用io_uring_enter()系统调用告诉内核我们已经提交了事件。</span></span><br><span class="line"><span class="comment">    * 我们还传递了IOURING_ENTER_GETEVENTS标志，</span></span><br><span class="line"><span class="comment">    * 它使io_uring_enter()调用等到min_complete事件（第3个参数）完成。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">int</span> ret =  io_uring_enter(s-&gt;ring_fd, <span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">            IORING_ENTER_GETEVENTS);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_enter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">submitter</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*s));</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(*s));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(app_setup_uring(s)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup uring!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(submit_to_sq(argv[i], s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error reading file\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        read_from_cq(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释"><a class="header-anchor" href="#解释">¶</a>解释</h2><p>让我们更深入地研究代码中特定的、重要的领域，看看这个示例程序是如何工作的。</p><h2 id="初始化设置"><a class="header-anchor" href="#初始化设置">¶</a>初始化设置</h2><p>在 <strong>main()</strong> 中，我们调用 <strong>app_setup_uring()</strong> ，它完成了我们使用 <strong>io_uring</strong> 所需的初始化工作。首先，我们调用 <strong>io_uring_setup()</strong> 系统调用，将我们需要的队列深度和结构 <strong>io_uring_params</strong> 的实例全部设置为0。当调用返回时，内核将填充这个结构成员中的值。这就是 <strong>io_uring_params</strong> 的样子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">  __u32 sq_entries;</span><br><span class="line">  __u32 cq_entries;</span><br><span class="line">  __u32 flags;</span><br><span class="line">  __u32 sq_thread_cpu;</span><br><span class="line">  __u32 sq_thread_idle;</span><br><span class="line">  __u32 resv[<span class="number">5</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在将这个结构作为 **<code>io_uring_setup ()</code>**系统调用的一部分传递之前，您唯一可以指定的是 flags 结构成员，但是在这个示例中，<br>我们不想传递任何 flag 。此外，在这个示例中，我们一个接一个地处理文件。我们不打算做任何并行 i/o，因为这是一个简单的例子，主要是为了了解 io_uring 的原始接口。为此，我们将队列深度设置为1。</p><p>来自 <strong><code>io_uring_setup ()</code></strong> 的返回值、文件描述符和 <strong>io_uring_param</strong> 结构中的其他字段随后将用于调用 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a>以将两个环缓冲区和一组提交队列条目映射到用户空间。看看吧。我已经删除了一些周围的代码，以便将重点放在 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a> 调用上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* submission 和 completion 队列中映射环形缓冲区.</span></span><br><span class="line"><span class="comment"> * 不过旧的内核只在提交队列中映射。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">sq_ptr = mmap(<span class="number">0</span>, sring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">        MAP_SHARED | MAP_POPULATE,</span><br><span class="line">        s-&gt;ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line"><span class="keyword">if</span> (sq_ptr == MAP_FAILED) &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">    cq_ptr = sq_ptr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 在旧内核中单独映射完成队列环形缓冲区 */</span></span><br><span class="line">    cq_ptr = mmap(<span class="number">0</span>, cring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">            MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_CQ_RING);</span><br><span class="line">    <span class="keyword">if</span> (cq_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 映射到提交队列条目数组中 */</span></span><br><span class="line">s-&gt;sqes = mmap(<span class="number">0</span>, p.sq_entries * <span class="keyword">sizeof</span>(struct io_uring_sqe),</span><br><span class="line">        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">        s-&gt;ring_fd, IORING_OFF_SQES);</span><br></pre></td></tr></table></figure><p>我们将重要的细节保存在 <strong><code>app_io_sq_ring</code></strong> 和 <strong><code>app_io_cq_ring</code></strong> 中，以便以后参考。<br>当我们将两个环缓冲区分别映射为提交和完成时，您可能想知道第三个映射是用来做什么的。<br>完成队列环直接对 CQEs 的共享数组建立索引，而提交环在两者之间有一个间接数组。<br>提交端环形缓冲区是该数组的索引，该数组又包含 SQEs 中的索引。这对于将提交请求嵌入内部数据结构的某些应用程序非常有用。<br>这种设置允许他们一次提交多个提交条目，同时允许他们更容易地采用io_uring。</p><pre><code># 注意在内核版本5.4及以上，单个 mmap (2)映射提交队列和完成队列。然而，在较老的内核中，它们需要单独映射。与检查内核版本不同，您可以通过检查 IORING_FEAT_SINGLE_MMAP  功能标志来检查内核使用一个 mmap (2)映射两个队列的能力，就像我们在上面的代码中所做的那样。# 参考- [io_uring_setup](https://unixism.net/loti/ref-iouring/io_uring_setup.html#io-uring-setup)</code></pre><h2 id="处理共享-ring-缓冲器"><a class="header-anchor" href="#处理共享-ring-缓冲器">¶</a>处理共享 ring 缓冲器</h2><p>在常规编程中，我们习惯于处理用户空间和内核之间非常清晰的接口: 系统调用。然而，<br>系统调用确实有成本，对于像 <strong>io_uring</strong> 这样的高性能接口，希望尽可能去掉系统调用。<br>我们在前面看到，与通常的多个系统调用不同，使用 io_uring<br>允许我们批处理多个 i/o 请求，并对 <strong><code>[io_uring_enter ()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code></strong> 系统调用进行单个调用。或者在<a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">轮询模式</a>下，甚至不需要调用。</p><p>当从用户空间读取或更新共享 ring 缓冲区时，需要注意一些事项，以确保在读取时看到最新的数据，<br>并在更新之后“刷新”或“同步”写操作，以便内核看到您的更新。这是因为 CPU 可以重新安排读写顺序，<br>编译器也可以。当读写操作发生在同一个 CPU 上时，这通常不是问题。但是在 <strong><code>io_uring</code></strong> 的情况下，<br>当一个共享缓冲区涉及到两个不同的上下文: 用户空间和内核，并且它们在上下文<br>切换之后可以在不同的 cpu 上运行。您需要确保从用户空间读取之前，先前的写操作是可见的。<br>或者，当您在 SQE 中填充细节并更新提交缓冲区的尾部时，您希望确保在更新环缓冲区尾部的写入之前，<br>对 SQE 成员进行的写入是有序的。如果这些写操作没有被排序，内核可能会看到尾部被更新，<br>但是当它读取 SQE 时，它可能无法在读取 SQE 时找到所需的所有数据。在轮询模式中，<br>内核正在查找对尾部的更改，这就成了一个真正的问题。<br>这都是因为 cpu 和编译器为了优化而对读写进行重新排序。</p><h2 id="读取完成队列条目"><a class="header-anchor" href="#读取完成队列条目">¶</a>读取完成队列条目</h2><p>一如既往，我们首先处理事情的完成方面，因为它比提交方面更简单。<br>这些解释甚至是必要的，因为我们需要讨论内存的顺序和我们需要如何处理它。<br>否则，我们只想看看如何处理环形缓冲区。对于完成事件，内核将 CQEs 添加到循环缓冲区并更新尾部，<br>而我们在用户空间中从头部读取。在任何环形缓冲区中，如果头部和尾部相等，则表示环形缓冲区为空。看看下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> head;</span><br><span class="line">head = cqring-&gt;head;</span><br><span class="line">read_barrier(); <span class="comment">/* 确保以前的写入可见 */</span></span><br><span class="line"><span class="keyword">if</span> (head != cqring-&gt;tail) &#123;</span><br><span class="line">    <span class="comment">/* 环形缓冲区中有可用的数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> index;</span><br><span class="line">    index = head &amp; (cqring-&gt;mask);</span><br><span class="line">    cqe = &amp;cqring-&gt;cqes[index];</span><br><span class="line">    <span class="comment">/* 在此处完成cqe过程 */</span></span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">/* 我们现在已经消耗了这一项 */</span></span><br><span class="line">    head++;</span><br><span class="line">&#125;</span><br><span class="line">cqring-&gt;head = head;</span><br><span class="line">write_barrier();</span><br></pre></td></tr></table></figure><p>为了得到头部的索引，应用程序需要使用环形缓冲区的大小掩码来掩码头部。请记住，<br>上面代码中的任何一行都可能在上下文切换之后运行。因此，在比较之前，<br>我们有一个 <strong><code>read_barrier()</code></strong> ，这样，如果内核确实更新了尾部，<br>我们可以在 if 语句中将其作为比较的一部分来读取。一旦我们获得了 CQE 并处理它，<br>我们就更新 head，让内核知道我们已经使用了来自 ring 缓冲区的条目。最后一个 **<code>write_barrier()</code>**确保我们的写操作可见，这样内核就可以知道它。</p><h2 id="提交-submission"><a class="header-anchor" href="#提交-submission">¶</a>提交 submission</h2><p>做一个提交和读取一个完成是相反的。在处理 completion 时，内核将条目添加到尾部，<br>我们从循环缓冲区的头部读取条目，当 submission 时，我们添加到尾部，内核从循环缓冲区的头部读取条目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> tail, index;</span><br><span class="line">tail = sqring-&gt;tail;</span><br><span class="line">index = tail &amp; (*sqring-&gt;ring_mask);</span><br><span class="line">sqe = &amp;sqring-&gt;sqes[index];</span><br><span class="line"><span class="comment">/* 此函数调用填写此IO请求的SQE详细信息 */</span></span><br><span class="line">app_init_io(sqe);</span><br><span class="line"><span class="comment">/* 将SQE索引填充到SQ环数组中 */</span></span><br><span class="line">sqring-&gt;<span class="built_in">array</span>[index] = index;</span><br><span class="line">tail++;</span><br><span class="line">write_barrier();</span><br><span class="line">sqring-&gt;tail = tail;</span><br><span class="line">write_barrier();</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，应用程序中的 <strong><code>app_init_io()</code></strong> 函数将填充提交请求的详细信息。在尾部更新之前，<br>我们有一个 <strong><code>write_barrier()</code></strong> 来确保前面的写操作是有序的。然后我们更新 tail 并再次调用 <strong><code>write_barrier()</code></strong> 以确保我们的更新被看到。我们在这里按照正确的顺序处理。</p><h2 id="源代码"><a class="header-anchor" href="#源代码">¶</a>源代码</h2><p>本文档中的代码和其他示例可以在这个 <a href="https://github.com/shuveb/loti-examples">Github</a> 存储库中找到。</p><h2 id="参考文档"><a class="header-anchor" href="#参考文档">¶</a>参考文档</h2><ul><li><a href="https://unixism.net/loti/low_level.html">The Low-level io_uring Interface</a></li><li><a href="https://kernel.dk/io_uring.pdf">Efficient IO with io_uring PDF</a></li><li><a href="https://github.com/axboe/liburing">Efficient IO with io_uring github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io_uring 是什么?</title>
      <link href="/jony.github.io/98b4e846459c/"/>
      <url>/jony.github.io/98b4e846459c/</url>
      
        <content type="html"><![CDATA[<p>io_uring 是一个新的 Linux 异步 I/O API，由 Facebook 的 Jens Axboe 创建。它的目的是提供一个不受当前<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>、<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>系列系统调用限制的API，我们在上一节讨论过。鉴于异步编程模型的用户首先是出于性能的考虑而选择它，因此，拥有一个性能开销非常低的API是有意义的。我们将在后面的章节中看到io_uring是如何实现这一点的。</p><h1>io_uring 接口</h1><p>io_uring这个名字的由来是由于该接口使用环形缓冲区作为内核与用户空间通信的主要接口。虽然涉及到系统调用，但它们被保持在最低限度。并且可以使用轮询模式来尽可能地减少系统调用的需要。</p><blockquote><h2 id="参阅"><a class="header-anchor" href="#参阅">¶</a>参阅</h2><ul><li><a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">提交队列轮询教程</a>与示例程序。</li></ul></blockquote><h3 id="心智模型"><a class="header-anchor" href="#心智模型">¶</a>心智模型</h3><p>为了使用 <code>io_uring</code> 构建异步处理I/O的程序，需要构建的心智模型，但是相当简单。</p><ul><li>有两个环形缓冲区，一个用于提交请求(提交队列或SQ)，另一个用于通知您这些请求已完成(完成队列或CQ)。</li><li>这些环形缓冲区在内核和用户空间之间共享。您可以使用 <code>[io_uring_setup()](https://unixism.net/loti/ref-iouring/io_uring_setup.html#c.io_uring_setup)</code> 设置这些缓冲区，然后通过2个<a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a>调用将它们映射到用户空间。</li><li>你告诉 <code>io_uring</code> 你需要做什么(读或写文件，接受客户端连接，等等)，你把它描述为提交队列条目(SQE)的一部分，并把它添加到提交环缓冲区的尾部。</li><li>然后你通过 <code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code> 系统调用告诉内核你已经在提交队列环形缓冲区中添加了一个SQE。你也可以在进行系统调用之前添加多个SQE。</li><li>另外，<code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code> 也可以在返回之前等待内核处理一些请求，这样你就知道可以从完成队列读取结果了。</li><li>内核处理提交的请求，并将完成队列事件（CQE）添加到完成队列环形缓冲区的尾部。</li><li>您从完成队列环形缓冲区的头部读取CQE。每个SQE对应一个CQE，它包含该特定请求的状态。</li><li>您可以根据需要继续添加SQE和获取CQE。</li><li>有一种<a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">轮询模式可用</a>，内核在该模式下轮询提交队列中的新条目。这避免了每次提交条目进行处理时调用<a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a>的系统调用开销。</li></ul><blockquote><h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3><ul><li><a href="https://unixism.net/loti/low_level.html#low-level">io_uring 底层接口</a></li></ul></blockquote><h1>io_uring 性能</h1><p>由于内核和用户空间之间共享环形缓冲区，因此io_uring可以是零拷贝系统。当涉及在内核和用户空间之间传输数据的系统调用时，需要复制字节。但是，由于io_uring中的大部分通信是通过内核和用户空间之间共享的缓冲区进行的，因此完全避免了这种巨大的性能开销。虽然系统调用(我们习惯于大量调用)可能看起来不是很大的开销，但在高性能应用程序中，大量调用将开始变得重要。此外，系统调用也不像以前那么便宜了。再加上操作系统为应对<a href="https://meltdownattack.com/">Specter和Meltdown</a>而采取的工作方法，我们谈论的不是微不足道的开销。因此，在高性能应用程序中，尽可能避免系统调用确实是一个很棒的想法。</p><p>在使用同步编程接口时，甚至在Linux下使用异步编程接口时，每个请求的提交都至少涉及一个系统调用。在 <code>io_uring</code> 中，您可以添加几个请求，只需添加多个sqe，每个sqe描述您想要的I/O操作，并对io_uring_enter进行一次调用。对于初学者来说，这就是一场胜利。但它会变得更好。</p><p>你可以让内核在你将SQEs添加到提交队列中时，进行轮询并提取它们进行处理，这样可以让你不用调用io_uring_enter()来告诉内核提取SQEs。对于高性能的应用，这意味着更少的系统调用开销。更多细节请参见<a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">提交队列轮询教程</a>。</p><p>通过巧妙地使用共享环形缓冲区，<code>io_uring</code> 的性能其实是受内存限制的，因为在轮询模式下，我们可以完全不使用系统调用。重要的是要记住，性能基准测试是一个相对的过程，需要有某种共同的参考点。根据<a href="https://kernel.dk/io_uring.pdf">io_uring的论文</a>，在一台参考机器上，在轮询模式下，io_uring管理着1.7M 4k IOPS的时钟，而<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>管理着608k。虽然远超过一倍，但这并不是一个公平的比较，因为 <a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a> 并不具备轮询模式。但即使禁用轮询模式，io_uring也达到了1.2M IOPS，接近于 <a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a> 的两倍。</p><p>为了检查 <code>io_uring</code> 接口的原始吞吐量，有一个no-op请求类型。有了这个类型，在参考机器上，<code>io_uring</code> 实现了每秒20M的消息量。更多细节请参见 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_nop">io_uring_prep_nop()</a>。</p><h1>使用底层API的 Demo</h1><p>编写一个小程序来读取文件并将它们打印到控制台，就像Unix的 <code>cat</code> 实用程序一样，这可能是一个很好的起点，可以让你熟悉 <code>io_uring</code> API。请看下一章中的一个例子。</p><h1>只使用 liburing</h1><p>虽然熟悉低级别的 <code>io_uring</code> API肯定是件好事，但在实际的、严肃的程序中，你可能想使用liburing提供的更高级别的接口。像QEMU这样的程序已经在使用它了。如果 <code>liburing</code> 从来没有存在过，你就会在低级的IO接口上构建一些抽象层， <code>liburing</code> 为你做到了这一点，它也是一个经过深思熟虑的接口。简而言之，你可能应该花一些精力去了解底层的 <code>io_uring</code> 接口是如何工作的，但默认情况下，你应该在你的程序中真正使用 <code>liburing</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下异步编程</title>
      <link href="/jony.github.io/493f5652fc23/"/>
      <url>/jony.github.io/493f5652fc23/</url>
      
        <content type="html"><![CDATA[<p>我们生活在这样一个时代，我们使用的大多数应用程序都在云上运行。每当用户连接到基于云的应用程序时，通常编写在某种web框架之上的大多数业务逻辑都会运行。每个请求要么在单独的进程、单独的线程中处理，要么在异步程序中处理，多个请求在同一个进程中处理。今天，基于线程池和异步模型的应用程序框架同样流行。这些应用程序混合了对网络的调用和与文件相关的系统调用，以完成它们的工作。</p><h1>Processes</h1><p>通常，当您调用一个系统调用(如<a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>)时，您的程序会一直阻塞，直到文件被读取并且数据可用。这通常是相当快的，而且您通常没有意识到您的程序正在阻塞。但您可能也没有意识到，您的程序，特别是在繁忙的机器上，可能每秒数百次地从CPU切换到运行其他程序。当系统调用阻塞时，只要在内核模式下运行的系统调用返回并继续运行，您的程序就会解除阻塞。如果它像大多数其他程序一样，每当它需要操作系统的某些东西时，它就会继续这个阻塞和解锁的循环。这种范例很容易理解，因为事件按逻辑顺序一个接一个地发生-即使您的程序可能被抢占以运行其他程序，或者它可能被系统调用阻塞。如果您忽略了您的程序被抢占以运行其他程序这一事实，那么您的程序就好像是按顺序执行其逻辑一样。</p><h1>多线程程序</h1><p>在多线程程序中，这种心智模型可以很好地推断。在你的程序中，有许多执行线程。这些实例可以是相同逻辑的实例(为处理客户端请求而创建的线程的一个实例)，也可以是其他逻辑的实例(一个专门的线程总是在后台运行以清理临时文件)。这些单独的线程被系统调用抢占、阻塞和解除阻塞。有几个或几个在运行，当然这个心智模型也是相当可扩展的。但是，在多线程过程中仍然会遇到锁和互斥等复杂的东西。但为了我们的讨论，我们最好忽略它们。</p><h1>为什么是异步编程</h1><p>如果你要构建一些每小时处理数千甚至数十万个请求的东西，你不需要为异步I/O而烦恼。围绕着基于线程池架构设计的应用框架就能满足你的需求。但如果你想高效地处理每小时数百万次的请求，并且你很关心效率，你可能要更仔细地研究异步编程。异步编程通过在单线程中处理大部分的I/O，避免了操作系统的线程/进程上下文切换开销。操作系统的上下文切换开销看似不大，但当你要处理大量的规模和并发时，它就开始变得重要起来。</p><p>请看下图，它描述了一组请求在一秒钟内发生的事情。线程从阻塞到运行状态。虽然很清楚单线程和多线程应用程序中发生了什么，但异步编程的工作方式可能有点难以理解，尽管它不像造火箭那么难。我希望下图能帮助你理解。</p><p><img src="/jony.github.io/images/Linux_Process_Models.jpg" alt="阻塞到异步" title="阻塞到异步"></p><p>下面是用一个教育网站服务器运行实验的图表，功能上是一样的，但使用不同的Linux进程模型编写。下面是对每种架构名称的解释。</p><ul><li><strong>迭代<code>Iterative</code></strong> ：这种服务器类型为一个又一个请求提供服务。当它在服务一个请求时，其他可能到达的请求必须等待前一个请求处理完毕。操作系统排队的请求数量是有限制的。默认情况下，Linux在5.4以下的内核版本中最多排队128个，新版本中最多排队4,096个。</li><li><strong>Forking</strong> :这种类型的服务器为每个需要服务的请求创建一个新进程。这样，请求就不需要等待以前的请求处理完成。不同的进程处理不同的请求。此外，当有许多进程或线程在工作时，它们往往会利用多个可用的CPU内核。</li><li><strong>Preforked</strong>：这种类型的服务器避免了每次需要处理请求时必须创建一个全新进程的开销。它通过创建一个进程池来实现这一点，这些进程在请求传入时被分配。只有当池中的所有进程都繁忙时，传入的请求才应该等待轮到它们被处理。管理员通常能够根据他们通常遇到的负载来调整池中进程的数量。</li><li><strong>线程化<code>Threaded</code></strong>:这种类型的服务器在每次需要处理请求时都会生成一个新线程。线程与创建它的主进程共享大量数据，因此与创建新进程相比，在创建过程中产生的开销略低 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 。</li><li><strong>预线程<code>Prethreaded</code></strong>:这相当于预分叉架构的线程。在这种风格中，创建了一个线程池，并在收到请求时将池中的线程分配给它们。和预分叉模式一样，只有当所有线程都在忙于处理之前收到的请求时，请求才需要等待。这是一种非常高效的模式，也是大多数Web应用框架所遵循的模式。</li><li><strong>poll</strong>：这种类型的服务器是单线程的，使用<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>系统调用在请求之间进行多路复用。然而 <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>是一个有严重限制的系统调用：当扩展到处理大量文件描述符时，它会产生性能问题。。从下面的图表中可以看出这一点。在这种设计中，每个请求的状态都会被跟踪，并进行一系列函数回调，将该请求的处理带到下一个阶段。</li><li><strong>epoll</strong>：这也是一种单线程的，服务器使用<a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列系统调用代替 <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> ，但除此之外，架构上是一样的。</li></ul><p><img src="/jony.github.io/images/Linux_Performance_upto_1000_users.png" alt="Linux_Performance_upto_1000_users" title="Linux_Performance_upto_1000_users"><br><img src="/jony.github.io/images/Linux_Performance_more_than_1000_users.png" alt="Linux_Performance_more_than_1000_users" title="Linux_Performance_more_than_1000_users"><br><img src="/jony.github.io/images/Linux_Performance_upto_1000_users.png" alt="Linux_Performance_Fulll_Chart-1" title="Linux_Performance_Fulll_Chart-1"></p><p>正如您所看到的，Prethreaded 或基于线程池的Web服务器使基于<a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>的服务器在这个特定的基准测试中达到11,000个用户的并发性之前都是运行非常良好。这是大量的并发用户。只有非常流行的Web服务才会体验到这种并发性。这一点非常重要，因为就复杂性而言，与异步程序相比，基于线程池的程序更容易编码。这也意味着它们也更容易维护，因为它们本质上更容易理解。</p><p>阅读我的<a href="https://unixism.net/2019/04/linux-applications-performance-introduction/">系列文章</a>，深入了解你的应用可以使用的各种Linux进程模型。这是通过基于各种流程架构从头开始构建功能相同的Web服务器来实现的。</p><h1>简化异步编程</h1><p>当你构建一个异步架构的程序时，通常会使用一个高级库，让开发人员的工作更轻松。另一种选择是将你的程序分层，这样你可以在最低层处理异步Linux接口，而更高的层则提供一个更易于使用的接口，在此基础上构建功能。抽象这些低层操作系统接口的库的一个很好的例子是<a href="https://libevent.org/">libevent</a>和<a href="https://libuv.org/">libuv</a>，它们为<a href="https://nodejs.org/en/">NodeJS</a>提供支持。</p><p>除非您正在编写专门的应用程序(如Web框架或高性能网络服务)，否则通常不需要使用这些低级API进行编程。但如果你很好奇，想要了解系统程序是如何工作的，那你就来对地方了。在这个世界上，好奇心永远不会害死猫。很多时候，它会变成一只老虎。</p><p>像<a href="https://www.tornadoweb.org/">Tornado</a>和NodeJS这样的Web应用框架可以让你轻松地编写异步Web应用，并且拥有异步I/O性能优势。如果你正在编写一个Web服务或者<a href="https://www.electronjs.org/">桌面应用程序</a>，你可能想使用这些这些框架，因为它们允许你用高级语言编写你的业务逻辑，同时保留了很多性能优势。</p><h1>io_uring之前的Linux异步api</h1><p>我们看到，在同步编程的情况下，在<a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>的情况下，处理读写或远程连接的系统调用会分别被阻塞，直到数据读取、写入或客户端连接可用。在此之前，上述进程或线程都会被阻塞。如果你需要做其他事情怎么办？可以创建其他线程来处理这些其他任务。例如，主线程可能在<a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>时阻塞，这样新的客户端连接就会被立即处理，而其他线程可能正在处理来自前一个客户端的请求。但是，如果你需要保持活跃来接受客户端连接，同时也试图从客户端套接字中读取，同时也试图在一个线程中读取或写入本地文件呢？FTP服务器在服务(读)和接受(写)文件时，既要处理套接字，又要处理常规的文件描述符，这将是一个很好的例子。如何在一个线程或进程中完成这些工作？这就是<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>和<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列系统调用的作用。</p><p>这些系统调用允许您监视一组文件描述符(套接字也是文件描述符)，并在其中一个或多个准备就绪时通知您。举个例子，FTP服务器正在等待从几个已连接的客户端读取下一个命令，同时还在监听<a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>上是否有任何新的客户端请求。程序将告诉<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列系统调用监视这些文件描述符，并在其中一个或多个文件描述符上有任何活动时让程序知道。为此，与基于进程或线程专门处理每个请求的程序相比，您需要以非常不同的方式构建您的程序。</p><p>Linux的<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>系列系统调用可以异步处理文件和套接字。然而，你需要注意一些限制：</p><ul><li><a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>只支持用O_DIRECT打开的文件或在非缓冲模式下打开的文件。这无疑是它最大的限制。在通常情况下并非所有的应用程序都希望以无缓冲模式打开文件。</li><li>即使在无缓冲模式下，如果文件元数据不可用，io(7) 也会被阻塞。它将等待元数据可用</li><li>有些存储设备有固定数量的槽位用于请求。如果所有的槽都忙，<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>提交可能会阻塞。</li><li>提交和完成总共需要复制104个字节。此外，还需要对I/O进行两个不同的系统调用（提交和完成各一个）。</li></ul><p>上述限制在<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>子系统中引入了大量的不确定性和性能开销</p><h1>常规文件的问题</h1><p>在一个不是很忙的服务器上，读写一个文件可能不需要很长的时间。以上面使用异步设计编写的FTP服务器为例。当它真的很忙的时候，有很多并发用户同时下载和上传很多很大的文件，作为程序员，您需要了解一个问题。在这么繁忙的服务器上，调用 <a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>和<a href="http://man7.org/linux/man-pages/man2/write.2.html">write(2)</a>会开始大量阻塞。但是<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或者<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列的系统调用对我们没有帮助吗？不幸的是没有。这些系统调用只是会告诉常规文件已经准备好进行 I/O。这是他们的致命弱点。我们不会去讨论为什么会这样，但重要的是要明白，虽然它们对套接字工作得很好，但它们只会为常规文件返回“就绪”。</p><p>不幸的是，这使得文件描述符在异步编程下是非统一的。支持常规文件的文件描述符会受到歧视。出于这个原因，像<code>libuv</code>这样的库为常规文件的I/O使用了一个单独的线程池，暴露了一个向用户隐藏这种差异的API。阅读这篇<a href="https://blog.libtorrent.org/2012/10/asynchronous-disk-io/">优秀的文章</a>，调查了各种操作系统上的异步I/O API。</p><h1>io_uring中存在这个问题吗</h1><p>没有。无论是处理套接字还是普通文件，io_uring都提供了一个统一的接口。另外，由于 API 的设计，程序可以直接获取读取或写入文件描述符的数据，而不是像 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或者<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>一样，知道文件描述符何时准备好，然后再开始对其进行 I/O 操作。这并不是 io_uring 与现有 Linux 异步 I/O API 相比的唯一优势。我们将在接下来的章节中讨论更多。</p><h2 id="脚注"><a class="header-anchor" href="#脚注">¶</a>脚注</h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>虽然在Linux下创建线程或进程都是通过clone(2)系统调用来完成的，并且产生的开销也是一样的，但就在创建之后，如果一个共享父进程地址空间的只读副本的子进程向其页面写入，内核就会为子进程创建父进程地址空间的副本，这是真正的开销。进程中的线程共享地址空间，因此不会产生这种复制开销。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
            <tag> 异步 </tag>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到 Lord of the io_uring</title>
      <link href="/jony.github.io/88c499707f04/"/>
      <url>/jony.github.io/88c499707f04/</url>
      
        <content type="html"><![CDATA[<p>io_uring是在Linux下进行异步I/O编程的一种强大的新方法。<code>io_uring</code> 消除了上一代I/O子系统的各种限制，拥有巨大的前景。关于io_uring带来的更多细节，请参阅“<a href="">什么是 <code>io_uring</code></a> ?”</p><p>这本IO指南是由Shuveb Hussain创建的，他也是专注于Linux的博客unixism.net的作者。</p><h1>Contributing</h1><p>本指南的源代码库在Github上。如果你想投稿，请发送我拉请求。如果你在文档或包含的源代码示例中发现任何错误，请在GitHub上提出问题。示例程序的存储库是分开维护的。请看下面的细节。</p><h1>源代码案例</h1><p>本指南中所有示例程序的源代码都可以在 Github 上找到。如果您在示例中发现了 bug，请在 Github 上提出问题。我想让这些例子简单明了。出于这个原因，我很多不会合并添加特性的拉请求。欢迎提出修复 bug 的请求。</p><h1>文档</h1><p>引言</p><ul><li><a href="/jony.github.io/493f5652fc23/">Linux 下的异步编程</a></li><li><a href="/jony.github.io/98b4e846459c/">什么是 <code>io_uring</code>？</a></li><li><a href="/jony.github.io/3d70b9e6d77f/"><code>io_uring</code> 的底层接口</a></li></ul><p>教程</p><ul><li><a href="/jony.github.io/33f4e488c2f3/">cat 使用 <code>liburing</code> 实现</a></li><li><a href="/jony.github.io/fbcd2bb270f6/">cp 使用 <code>liburing</code> 实现</a></li><li><a href="/jony.github.io/90d9c32a425c/">web 服务器使用 <code>liburing</code> 实现</a></li><li><a href="/jony.github.io/4aa7709cef2f/">探测支持功能</a></li><li><a href="/jony.github.io/6629bb792093/">请求链</a></li><li><a href="/jony.github.io/48d3d8aca367/">固定的缓冲区</a></li><li><a href="/jony.github.io/973aa4b46332/">轮询提交队列</a></li><li><a href="/jony.github.io/304bb0ffee1d/">注册一个 <em>eventfd</em> </a></li></ul><p>liburing 参考资料</p><ul><li><a href="/jony.github.io/1f47a91ce33a/">SQE: 提交队列条目</a></li><li><a href="/jony.github.io/201d74132273/">CQE: 完成队列事件</a></li><li><a href="/jony.github.io/df6e31d86020/">支持的功能</a></li><li><a href="/jony.github.io/50174ef713ea/">设置和删除</a></li><li><a href="/jony.github.io/b74dca1de80f/">提交</a></li><li>完成</li><li>高级使用</li></ul><p>io_uring 参考资料</p><ul><li>io_uring_setup</li><li>io_uring_enter</li><li>io_uring_register</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
          <category> 导航 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
