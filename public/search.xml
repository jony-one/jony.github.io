<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CQE:完成队列条目</title>
      <link href="/jony.github.io/201d74132273/"/>
      <url>/jony.github.io/201d74132273/</url>
      
        <content type="html"><![CDATA[<p>内核为每个提交的队列条目添加了一个完成队列事件(CQE)。CQE 包含作为 SQE 的一部分提交的操作的状态。作为内核处理 SQE 的结果，只有一个 CQE 添加到完成队列中。这两者之间存在一一对应的关系。</p><pre><code># 注意这个结构是原始输入输出接口的一部分，在输入输出接口中定义。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">    __u64   user_data;      <span class="comment">/* sqe-&gt;data 提交内容已传回 */</span></span><br><span class="line">    __s32   res;            <span class="comment">/* 此事件的结果代码 */</span></span><br><span class="line">    __u32   flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQE:提交队列条目</title>
      <link href="/jony.github.io/1f47a91ce33a/"/>
      <url>/jony.github.io/1f47a91ce33a/</url>
      
        <content type="html"><![CDATA[<p>提交队列条目(SQE)是用来告诉 <strong><code>io_uring</code></strong> 你想要做什么，比如读取一个文件，写一个文件，监听一个 socket 上的连接等等。</p><pre><code># 注意这个结构是原始 io_uring 接口的一部分，在 io_uring.h 中定义。</code></pre><h2 id="struct-io-uring-sqe"><a class="header-anchor" href="#struct-io-uring-sqe">¶</a>struct io_uring_sqe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">    __u8    opcode;         <span class="comment">/* 此sqe的操作类型 */</span></span><br><span class="line">    __u8    flags;          <span class="comment">/* IOSQE_ 标记 */</span></span><br><span class="line">    __u16   ioprio;         <span class="comment">/* 请求的ioprio */</span></span><br><span class="line">    __s32   fd;             <span class="comment">/* 要执行IO的文件描述符 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        __u64       off;    <span class="comment">/* offset into file */</span></span><br><span class="line">        __u64       addr2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        __u64       addr;   <span class="comment">/* 指向缓冲区或iovecs的指针 */</span></span><br><span class="line">        __u64       splice_off_in;</span><br><span class="line">    &#125;;</span><br><span class="line">    __u32   len;            <span class="comment">/* 缓冲区大小或iovec的数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">__kernel_rwf_t</span>      rw_flags;</span><br><span class="line">        __u32               fsync_flags;</span><br><span class="line">        __u16               poll_events;</span><br><span class="line">        __u32               sync_range_flags;</span><br><span class="line">        __u32               msg_flags;</span><br><span class="line">        __u32               timeout_flags;</span><br><span class="line">        __u32               accept_flags;</span><br><span class="line">        __u32               cancel_flags;</span><br><span class="line">        __u32               open_flags;</span><br><span class="line">        __u32               statx_flags;</span><br><span class="line">        __u32               fadvise_advice;</span><br><span class="line">        __u32               splice_flags;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 在完成时传回的数据 */</span></span><br><span class="line">    __u64   user_data;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="comment">/* 索引到固定缓冲区（如果使用 */</span></span><br><span class="line">                __u16       buf_index;</span><br><span class="line">                <span class="comment">/* 用于分组缓冲区选择 */</span></span><br><span class="line">                __u16       buf_group;</span><br><span class="line">            &#125; __attribute__((packed));</span><br><span class="line">            <span class="comment">/* personality to use, if used */</span></span><br><span class="line">            __u16   personality;</span><br><span class="line">            __s32   splice_fd_in;</span><br><span class="line">        &#125;;</span><br><span class="line">        __u64       __pad2[<span class="number">3</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册一个eventfd</title>
      <link href="/jony.github.io/304bb0ffee1d/"/>
      <url>/jony.github.io/304bb0ffee1d/</url>
      
        <content type="html"><![CDATA[<p>关于 <a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a> 系统调用的细节不在讨论范围内。你可能需要查看 <a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a> man 页面来了解该系统调用的描述。 <a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a> 是一个 Linux 特有的同步机制。</p><p><code>io_uring</code> 能够在事件完成时在eventfd实例上发布事件。该功能允许使用 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> 或 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> 复用I/O的进程将 <code>io_uring</code> 注册的eventfd实例文件描述符添加到兴趣列表中，以便 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> 或 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a> 在完成时通过 <code>io_uring</code> 通知它们。这允许这样的程序忙于处理它们现有的事件循环，而不是在调用 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">io_uring_wait_cqe()</a> 时被阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SZ   512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buff[BUFF_SZ + <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_exit</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    perror(message);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">listener_thread</span><span class="params">(<span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">int</span> efd = (<span class="keyword">int</span>) data;</span><br><span class="line">    <span class="keyword">eventfd_t</span> v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting for completion event...\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = eventfd_read(efd, &amp;v);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) error_exit(<span class="string">&quot;eventfd_read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got completion event.\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 现在我们有了CQE，让我们来处理它 */</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n%s\n&quot;</span>, buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_io_uring</span><span class="params">(<span class="keyword">int</span> efd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_register_eventfd(&amp;ring, efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_file_with_io_uring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    io_uring_prep_read(sqe, fd, buff, BUFF_SZ, <span class="number">0</span>);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">int</span> efd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个eventfd实例 */</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (efd &lt; <span class="number">0</span>)</span><br><span class="line">        error_exit(<span class="string">&quot;eventfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建监听线程 */</span></span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, listener_thread, (<span class="keyword">void</span> *)efd);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 io_uring 实例和注册eventfd */</span></span><br><span class="line">    setup_io_uring(efd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化读 io_uring */</span></span><br><span class="line">    read_file_with_io_uring();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待监听线程完成 */</span></span><br><span class="line">    pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 所有完成，清空和退出 */</span></span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>它是如何工作的</h1><p>在主线程中，我们创建了一个<a href="http://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd(2)</a>实例。然后创建一个线程，将 <code>eventfd</code> 文件描述符传递给它。在线程中，我们打印一条消息并立即从 <code>eventfd</code> 文件描述符中读取。这将导致线程阻塞，因为在 <code>eventfd</code> 实例上还没有发布任何事件。</p><p>当子线程在读取 <code>eventfd</code> 文件描述符时阻塞，我们在父线程中休眠2秒以清楚地感知这个序列。接下来，在 <code>setup_io_uring()</code> 中，我们创建一个 <code>io_uring</code> 实例，并向它注册 <code>eventfd</code> 文件描述符。这将导致 <code>io_uring</code> 在每一次完成事件时，都会在这个 <code>eventfd</code> 上 post 一个事件。</p><p>然后从main调用 <code>read_file_with_io_uring()</code> 。在这里，我们提交一个读取文件的请求。这将导致io_uring在注册的eventfd实例上发布一个事件。这现在应该会导致 <code>[read(2)](http://man7.org/linux/man-pages/man2/read.2.html)</code> 调用，在该调用中 <code>listener_thread()</code> 被阻塞，以解除阻塞并继续执行。在这个线程中，我们获取完成并打印出数据。</p><pre><code># 注意请注意，`eventfd_read()` 是glibc提供的一个库函数。它本质上是在eventfd上调用read。</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轮询提交队列</title>
      <link href="/jony.github.io/973aa4b46332/"/>
      <url>/jony.github.io/973aa4b46332/</url>
      
        <content type="html"><![CDATA[<p>减少系统调用的次数是 <code>io_uring</code> 的一个主要目的。为此， <code>io_uring</code> 允许你提交I/O请求，而不需要进行一次系统调用。这是通过 <code>io_uring</code> 支持的一个特殊的提交队列轮询功能实现的。在这种模式下，当你的程序设置了轮询模式后， <code>io_uring</code> 就会启动一个特殊的内核线程，轮询共享的提交队列，查看你的程序可能添加的条目。这样一来，你只需要向共享队列提交条目，内核线程就会看到它，并获取提交队列条目，而不需要你的程序进行 <a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a> 系统调用，这通常由<code>liburing</code> 来处理。这是在用户空间和内核之间共享队列的一个好处。</p><p>如何使用这种模式？这个想法很简单。你通过在 <code>io_uring_params</code> 结构的 <code>flags</code> 成员中设置 <code>IORING_SETUP_SQPOLL</code> 标志来告诉 <code>io_uring</code> 你想使用这个模式。如果和你的进程一起启动的内核线程在一段时间内没有看到任何提交，它就会退出，你的程序需要再调用一次 <a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a>系统调用来唤醒它。这个时间段可以通过 :c:struct`io_uring_params` 结构的 <code>sq_thread_idle</code> 成员来配置。但是，如果不断收到提交，内核轮询器线程应该永远不会休眠</p><pre><code> # 注意： 当使用 liburing 时，你永远不会直接调用 [io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter) 系统调用。这通常由liburing的 [io_uring_submit()](https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit) 函数来处理。它能自动判断你是否使用轮询模式，并处理你的程序何时需要调用 [io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)，而不需要你判断。 # 注意 内核的轮询线程会占用大量的CPU。你需要小心使用这个功能。设置一个非常大的sq_thread_idle值会导致内核线程在你的程序没有提交时继续消耗CPU。如果你真的期望处理大量的I/O，那么使用这个特性是个好主意。而即使你这样做，也最好将轮询线程的空闲值设置为最多几秒钟。</code></pre><p>但是，如果您需要使用此功能，则还需要将其与 <a href="https://unixism.net/loti/ref-liburing/advanced_usage.html#c.io_uring_register_files">io_uring_register_files()</a>结合使用。使用它，您可以预先告诉内核有关文件描述符数组的信息。这只是您在启动I/O之前打开的常规文件描述符的数组。在提交期间，您需要在SQE的 <code>flags</code> 字段中设置 <code>IOSQE_FIXED_FILE</code> 标志，并传递您之前设置的文件描述符数组中的文件描述符的索引，而不是像通常那样将文件描述符传递给<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a>或 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a> 等调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME1  <span class="meta-string">&quot;/tmp/io_uring_sq_test.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR1        <span class="meta-string">&quot;What is this life if, full of care,\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR2        <span class="meta-string">&quot;We have no time to stand and stare.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sq_poll_kernel_thread_status</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (system(<span class="string">&quot;ps --ppid 2 | grep io_uring-sq&quot;</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Kernel thread io_uring-sq found running...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Kernel thread io_uring-sq is not running.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_sq_polling_ops</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buff1[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> buff2[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> buff3[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> buff4[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">int</span> str1_sz = <span class="built_in">strlen</span>(STR1);</span><br><span class="line">    <span class="keyword">int</span> str2_sz = <span class="built_in">strlen</span>(STR2);</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>] = open(FILE_NAME1, O_RDWR | O_TRUNC | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>] &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buff1, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buff2, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buff3, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buff4, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">strncpy</span>(buff1, STR1, str1_sz);</span><br><span class="line">    <span class="built_in">strncpy</span>(buff2, STR2, str2_sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_register_files(ring, fds, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error registering buffers: %s&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_write(sqe, <span class="number">0</span>, buff1, str1_sz, <span class="number">0</span>);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_write(sqe, <span class="number">0</span>, buff2, str2_sz, str1_sz);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_sq_poll_kernel_thread_status();</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_read(sqe, <span class="number">0</span>, buff3, str1_sz, <span class="number">0</span>);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_read(sqe, <span class="number">0</span>, buff4, str2_sz, str1_sz);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s&quot;</span>, buff3, buff4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (geteuid()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;You need root privileges to run this program.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_sq_poll_kernel_thread_status();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">    params.flags |= IORING_SETUP_SQPOLL;</span><br><span class="line">    params.sq_thread_idle = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init_params(<span class="number">8</span>, &amp;ring, &amp;params);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    start_sq_polling_ops(&amp;ring);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>它是如何工作的</h1><p>这个示例程序很像我们之前看到的固定缓冲区示例。虽然我们使用 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read_fixed">io_uring_prep_read_fixed()</a></strong> 和 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write_fixed">io_uring_prep_write_fixed()</a></strong> 等专门函数来处理固定缓冲区，但我们使用了 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a></strong>、<strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_readv">io_uring_prep_readv()</a></strong>、**<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a><strong>或</strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_writev">io_uring_prep_writev()</a><strong>等常规函数。然而，在使用描述提交的SQE中，设置 <code>IOSQE_FIXED_FILE</code> 标志时，在文件描述符数组中使用文件描述符的索引，而不是在调用</strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_readv">io_uring_prep_readv()</a>**和 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_writev">io_uring_prep_writev()</a></strong> 等调用中使用文件描述符本身。</p><p>当程序启动时，在我们设置 <code>io_uring</code> 实例之前，我们打印执行提交队列轮询的内核线程的运行状态。此线程的名称为 <code>io_uring-sq</code> 。函数 <code>print_sq_poll_kernel_thread_status()</code> 负责打印此状态。当然，如果有任何其他进程使用提交队列轮询，您将看到该内核线程确实在运行。所有内核线程的父线是 <code>kthreadd</code> 内核线程，这个线程是在 <code>init</code>之后马上启动的，众所周知，它的进程ID为1。因此，<code>kthreadd</code> 的PID为2，我们可以利用这一事实作为一种简单的优化来只过滤内核线程。</p><p>为了初始化<code>io_uring</code>，我们使用 <strong><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init_params">io_uring_queue_init_params()</a></strong> 而不是常用的 <strong><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a></strong> ，因为这需要一个指向 <strong>io_uring_params</strong> 结构的指针作为参数。正是在这个参数中，我们指定了 <code>IORING_SETUP_SQPOLL</code> 作为 <code>flags</code> 字段的一部分，并将 <code>sq_thread_idle</code> 设置为2000，这是提交队列轮询器内核线程的空闲时间。如果在这许多毫秒内没有提交，线程就会退出，需要通过 <code>liburing</code> 在内部进行 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a></strong> 系统调用，让内核线程再次启动。</p><p>由于提交队列轮询只能与固定文件结合使用，因此我们首先要注册处理的唯一文件描述符。如果要处理更多的文件，这时你要用 <strong><a href="https://unixism.net/loti/ref-liburing/advanced_usage.html#c.io_uring_register_files">io_uring_register_files()</a></strong> 函数打开并注册它们。对于每次提交，您需要使用 <code>io_sqe_set_flag()</code> 辅助函数设置 <code>IOSQE_FIXED_FILE</code> 标志，并将注册文件数组中打开文件的索引(而不是实际文件描述符本身)提供给 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a></strong> 或 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a></strong> 等函数。</p><p>在这个例子中，我们有4个缓冲区。前2个缓冲区被2个写操作用来向文件中各写一行。之后，我们用第3个和第4个缓冲区再进行2次读操作，读取这2行写入的内容并打印出来。写操作结束后，我们打印 <code>io_uring-sq</code> 内核线程的状态，现在我们应该发现它正在运行。</p><pre><code>➜  sudo ./sq_poll[sudo] password for shuveb:Kernel thread io_uring-sq is not running.Result of the operation: 36Result of the operation: 35   1750 ?        00:00:00 io_uring-sqKernel thread io_uring-sq found running...Result of the operation: 36Result of the operation: 35Contents read from file:What is this life if, full of care,We have no time to stand and stare.%    </code></pre><h1>通过内核验证轮询</h1><p>但是，您需要调用 <strong><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a></strong>。我们在前面的示例中看到，这会导致发出 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a></strong> 系统调用。但是，在已经设置了 <code>IORING_SETUP_SQPOLL</code> 标志的情况下不是这样。 <code>liburing</code> 完全隐藏了这一点，同时保持了程序的持续接口。但是，我们能证实这一点吗?当然，我们可以通过使用eBPF的 <code>bpftrace</code> 程序来窥探系统。这里，我们将在 <code>io_uring</code> 设置的内核中使用跟踪点来证明，当我们设置 <code>IORING_SETUP_SQPOLL</code> 并提交I/O请求时，尽管我们调用了 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_submit()</a></strong> 函数，但我们的程序不会执行 <strong><a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a></strong> 系统调用。如前所述，对于高吞吐量的程序，我们的想法是尽可能地避免系统调用。</p><p>在下面的程序中，我们添加一个 tracepoint 到 <code>io_uring</code> 的 <code>io_uring_submit_sqe</code> 。每当一个SQE被提交给内核时，这个tracepoint就会被触发。每次这个tracepoint被触发，我们使用 <code>bpftrace</code> 来打印命令的名称和它的PID。首先，让我们在一个终端上运行 <code>bpftrace</code> 命令，同时在另一个终端上运行<a href="https://unixism.net/loti/tutorial/fixed_buffers.html#fixed-buffers">固定缓冲区</a>的例子。下面是我机器上的输出示例。你可以看到 <code>fixed_buffers</code> 是提交SQE的那个。</p><pre><code>➜  sudo bpftrace -e 'tracepoint:io_uring:io_uring_submit_sqe &#123;printf(&quot;%s(%d)\n&quot;, comm, pid);&#125;'Attaching 1 probe...fixed_buffers(30336)fixed_buffers(30336)fixed_buffers(30336)fixed_buffers(30336)</code></pre><p>让我们重复前面的练习，但现在运行当前的例子。你可以看到，SQE的提交是通过 <code>io_uring_sq</code> 内核线程进行的。因此我们避免了系统调用。</p><pre><code>➜  sudo bpftrace -e 'tracepoint:io_uring:io_uring_submit_sqe &#123;printf(&quot;%s(%d)\n&quot;, comm, pid);&#125;'io_uring-sq(30429)io_uring-sq(30429)io_uring-sq(30429)io_uring-sq(30429)</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>固定缓冲区</title>
      <link href="/jony.github.io/48d3d8aca367/"/>
      <url>/jony.github.io/48d3d8aca367/</url>
      
        <content type="html"><![CDATA[<p>使用固定缓冲区的思想是这样的:您提供一组用<code>iovec</code>结构体数组描述的缓冲区，并使用 <code>[io_uring_register_buffers()](https://unixism.net/loti/ref-liburing/advanced_usage.html#c.io_uring_register_buffers)</code> 将它们注册到内核。这将导致内核将这些缓冲区映射到内存中，从而避免将来在用户空间中来回复制。然后可以使用像<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write_fixed">io_uring_prep_write_fixed()</a>和<a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read_fixed">io_uring_prep_read_fixed()</a>这样的“固定缓冲区”函数来指定要使用的缓冲区的索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;liburing.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME   <span class="meta-string">&quot;/tmp/io_uring_test.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR1        <span class="meta-string">&quot;What is this life if, full of care,\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR2        <span class="meta-string">&quot;We have no time to stand and stare.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fixed_buffers</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[4];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        iov[i].iov_base = <span class="built_in">malloc</span>(BUF_SIZE);</span><br><span class="line">        iov[i].iov_len = BUF_SIZE;</span><br><span class="line">        <span class="built_in">memset</span>(iov[i].iov_base, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_register_buffers(ring, iov, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error registering buffers: %s&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> str1_sz = <span class="built_in">strlen</span>(STR1);</span><br><span class="line">    <span class="keyword">int</span> str2_sz = <span class="built_in">strlen</span>(STR2);</span><br><span class="line">    <span class="built_in">strncpy</span>(iov[<span class="number">0</span>].iov_base, STR1, str1_sz);</span><br><span class="line">    <span class="built_in">strncpy</span>(iov[<span class="number">1</span>].iov_base, STR2, str2_sz);</span><br><span class="line">    io_uring_prep_write_fixed(sqe, fd, iov[<span class="number">0</span>].iov_base, str1_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_prep_write_fixed(sqe, fd, iov[<span class="number">1</span>].iov_base, str2_sz, str1_sz, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read_fixed(sqe, fd, iov[<span class="number">2</span>].iov_base, str1_sz, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read_fixed(sqe, fd, iov[<span class="number">3</span>].iov_base, str2_sz, str1_sz, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                    strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s&quot;</span>, iov[<span class="number">2</span>].iov_base, iov[<span class="number">3</span>].iov_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fixed_buffers(&amp;ring);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>它是如何工作的</h1><p>我们通过malloc(3)分配4个缓冲区，然后用io_uring_register_buffers()函数向内核注册它们。iovec结构通过持有一个基地址和分配的缓冲区大小来描述每个数组。我们使用一个4个元素长的iovec结构数组来保存我们需要的4个数组的详细信息。</p><p>这个程序只是简单的演示了如何使用固定缓冲区，除此之外并没有更多有用的东西。使用两个固定的写操作(io_uring_prep_write_fixed())将两个字符串写入写入到一个使用索引为0和1的缓冲区的文件。 之后，我们使用两个固定的读操作(io_uring_prep_read_fixed())读取文件，这次使用的是2和3的缓冲区。然后我们打印这些读取的结果。</p><p>你可以看到这个程序的输出如下所示:</p><pre><code>Result of the operation: 36Result of the operation: 35Result of the operation: 36Result of the operation: 35Contents read from file:What is this life if, full of care,We have no time to stand and stare.</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求链</title>
      <link href="/jony.github.io/6629bb792093/"/>
      <url>/jony.github.io/6629bb792093/</url>
      
        <content type="html"><![CDATA[<p>在<code>io_uring</code>中，完成没有按照提交的问题所在的顺序到达。这在<a href="https://unixism.net/loti/low_level.html#low-level">底层io_uring接口</a>一章中讨论过。如果您想要强制某些操作按顺序进行，该怎么办?这可以通过将请求链实现。这里的示例向您展示了如何实现这一点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;liburing.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME   <span class="meta-string">&quot;/tmp/io_uring_test.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR         <span class="meta-string">&quot;Hello, io_uring!&quot;</span></span></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link_operations</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_write(sqe, fd, STR, <span class="built_in">strlen</span>(STR), <span class="number">0</span> );</span><br><span class="line">    sqe-&gt;flags |= IOSQE_IO_LINK;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read(sqe, fd, buff, <span class="built_in">strlen</span>(STR),<span class="number">0</span>);</span><br><span class="line">    sqe-&gt;flags |= IOSQE_IO_LINK;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_close(sqe, fd);</span><br><span class="line"></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                                                            strerror(-ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Now that we have the CQE, let&#x27;s process the data */</span></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buffer contents: %s\n&quot;</span>, buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    link_operations(&amp;ring);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个相当简单的程序。我们打开一个空文件，向它写入一个字符串，从文件中读取字符串，然后关闭它。由于 <code>io_uring</code> 并不能保证提交的操作会按顺序执行，这可能会给我们的程序带来问题。因为它是一个空文件，在程序的每一次运行中都会被截断，如果如果在读取之前没有完成写操作，那么将没有任何东西可以读。另外，如果关闭操作在读取或写入操作或这两个操作之前完成，这些操作也可能失败。为此，本程序用 <code>IOSQE_IO_LINK</code> 标志来链接操作。这样可以保证操作串行地执行。</p><p>这个程序理解起来相当简单。在 <code>link_operations()</code> 函数中，我们调用 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_write">io_uring_prep_write()</a>，但是在它上面设置 <code>IOSQE_IO_LINK</code>标志，这样下一个操作就会和这个操作链接起来。接下来，我们调用 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_read">io_uring_prep_read()</a>，现在它已经链接到了之前的写操作。我们还在此操作上设置了 <code>IOSQE_IO_LINK</code> 标志，这样我们用 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_close">io_uring_prep_close()</a>设置的后续关闭操作就会与这个操作链接起来。这样就会使 <code>io_uring</code> 接连执行写、读和关闭操作。</p><h1>请求链中的故障</h1><p>当涉及到链操作时，一个操作的失败会导致所有后续的链接操作失败，并出现错误 “Operation cancelled.”。一般情况下，如果你在内核5.6以上版本上运行这个程序，应该会有这个输出。</p><pre><code>→  cmake-build-debug ./linkResult of the operation: 16Result of the operation: 16Result of the operation: 0Buffer contents: Hello, io_uring!</code></pre><p>如果我们切换它们的open()语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>以只写模式打开文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(FILE_NAME, O_WRONLY|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>我们的写操作应该会通过，但是我们的读操作会失败，因为文件现在是以只写模式打开的。由于后续的close操作链接到read操作。现在这个有缺陷的程序的输出将是。</p><pre><code>→  cmake-build-debug ./linkError in async operation: Bad file descriptorResult of the operation: -9Error in async operation: Operation canceledResult of the operation: -125</code></pre><p>你看到的第一个错误(“Bad file descriptor”)是来自于失败的读取操作。你看到的下一个错误(“Operation cancelled”)是io_uring取消了链接关闭操作。</p><pre><code># 注意请注意，你需要内核5.6或更高版本的内核才能工作，因为在早期版本中不支持读、写和关闭操作。</code></pre><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探测支持功能</title>
      <link href="/jony.github.io/4aa7709cef2f/"/>
      <url>/jony.github.io/4aa7709cef2f/</url>
      
        <content type="html"><![CDATA[<p>下面的程序演示了如何使用 <code>io_uring_get_probe()</code> 。它打印出是否支持某个操作。</p><blockquote><p>A program to print details about supported and unsupported operations</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing/io_uring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *op_strs[] = &#123;</span><br><span class="line">        <span class="string">&quot;IORING_OP_NOP&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_READV&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_WRITEV&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FSYNC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_READ_FIXED&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_WRITE_FIXED&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_POLL_ADD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_POLL_REMOVE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SYNC_FILE_RANGE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SENDMSG&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_RECVMSG&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_TIMEOUT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_TIMEOUT_REMOVE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_ACCEPT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_ASYNC_CANCEL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_LINK_TIMEOUT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_CONNECT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FALLOCATE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_OPENAT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_CLOSE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FILES_UPDATE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_STATX&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_READ&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_WRITE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_FADVISE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_MADVISE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SEND&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_RECV&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_OPENAT2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_EPOLL_CTL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_SPLICE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_PROVIDE_BUFFERS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IORING_OP_REMOVE_BUFFERS&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">u</span>;</span></span><br><span class="line">    uname(&amp;u);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You are running kernel version: %s\n&quot;</span>, u.release);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_probe</span> *<span class="title">probe</span> =</span> io_uring_get_probe();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Report of your kernel&#x27;s list of supported io_uring operations:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; IORING_OP_LAST; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, op_strs[i]);</span><br><span class="line">        <span class="keyword">if</span>(io_uring_opcode_supported(probe, i))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;yes.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(probe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是程序在Linux内核5.6.4上运行时的输出<br>You are running kernel version: 5.6.4-arch1-1<br>Report of your kernel’s list of supported io_uring operations:<br>IORING_OP_NOP: yes.<br>IORING_OP_READV: yes.<br>IORING_OP_WRITEV: yes.<br>IORING_OP_FSYNC: yes.<br>IORING_OP_READ_FIXED: yes.<br>IORING_OP_WRITE_FIXED: yes.<br>IORING_OP_POLL_ADD: yes.<br>IORING_OP_POLL_REMOVE: yes.<br>IORING_OP_SYNC_FILE_RANGE: yes.<br>IORING_OP_SENDMSG: yes.<br>IORING_OP_RECVMSG: yes.<br>IORING_OP_TIMEOUT: yes.<br>IORING_OP_TIMEOUT_REMOVE: yes.<br>IORING_OP_ACCEPT: yes.<br>IORING_OP_ASYNC_CANCEL: yes.<br>IORING_OP_LINK_TIMEOUT: yes.<br>IORING_OP_CONNECT: yes.<br>IORING_OP_FALLOCATE: yes.<br>IORING_OP_OPENAT: yes.<br>IORING_OP_CLOSE: yes.<br>IORING_OP_FILES_UPDATE: yes.<br>IORING_OP_STATX: yes.<br>IORING_OP_READ: yes.<br>IORING_OP_WRITE: yes.<br>IORING_OP_FADVISE: yes.<br>IORING_OP_MADVISE: yes.<br>IORING_OP_SEND: yes.<br>IORING_OP_RECV: yes.<br>IORING_OP_OPENAT2: yes.<br>IORING_OP_EPOLL_CTL: yes.<br>IORING_OP_SPLICE: no.<br>IORING_OP_PROVIDE_BUFFERS: no.<br>IORING_OP_REMOVE_BUFFERS: no.</p><h1>源码</h1><p>源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a>上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liburing 实现 web 服务器</title>
      <link href="/jony.github.io/90d9c32a425c/"/>
      <url>/jony.github.io/90d9c32a425c/</url>
      
        <content type="html"><![CDATA[<h1>liburing 实现 web 服务器</h1><p>我们在<a href="https://unixism.net/loti/async_intro.html#async-intro">介绍</a>中讨论过，因为 <a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>和 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>报告对本地/常规文件的操作始终处于就绪状态，<br>所以像 libuv (这个 NodeJS 底层实现)这样的库使用单独的线程池来处理文件 i/o。<br><code>io_uring</code> 的一个巨大优势是，它为多种类型的I/O提供了一个单一的、干净的统一的、最重要的是高效的接口。</p><p>在这个示例中，我们将研究一个额外的操作 accept()以及如何使用 io_uring 来实现它。加上 readv()和 writev()的操作，<br>您就有能力编写一个简单的 web 服务器了！这个web服务器是基于我为ZeroHTTPd写的代码，<br>这个程序的特点是在我写的一系列文章中探索各种 Linux 进程模型以及它们相互之间的性能比较。<br>已经重写了 ZeroHTTPd 来专门使用 io/uring 接口。</p><p>下面是通过 ZeroHTTPd 提供的index页面:</p><p><img src="/jony.github.io/images/ZeroHTTPd_static.png" alt="index页面" title="index 页面"></p><p>现在让我们进入代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_STRING <span class="meta-string">&quot;Server: zerohttpd/0.1\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_DEPTH 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_SZ 8192</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_ACCEPT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_READ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_TYPE_WRITE 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> event_type;</span><br><span class="line">    <span class="keyword">int</span> iovec_count;</span><br><span class="line">    <span class="keyword">int</span> client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *unimplemented_content =</span><br><span class="line">    <span class="string">&quot;HTTP/1.0 400 Bad Request\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Content-type: text/html\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;html&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;title&gt;ZeroHTTPd: Unimplemented&lt;/title&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;h1&gt;Bad Request (Unimplemented)&lt;/h1&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;p&gt;Your client sent a request ZeroHTTPd did not understand and it is probably not your fault.&lt;/p&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *http_404_content =</span><br><span class="line">    <span class="string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Content-type: text/html\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;html&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;title&gt;ZeroHTTPd: Not Found&lt;/title&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/head&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;h1&gt;Not Found (404)&lt;/h1&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;p&gt;Your client is asking for an object that was not found on this server.&lt;/p&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/body&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用于将字符串转换为小写的实用函数。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strtolower</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; *str; ++str)</span><br><span class="line">        *str = (<span class="keyword">char</span>)<span class="built_in">tolower</span>(*str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 一个打印系统调用和错误详情的函数</span></span><br><span class="line"><span class="comment"> 然后以错误代码1退出。非零的意思是事情不顺利。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fatal_error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *syscall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(syscall);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为使代码看起来更干净的辅助功能。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zh_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *buf = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (!buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fatal error: unable to allocate memory.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数负责设置web服务器使用的主监听套接字。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_listening_socket</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock,</span><br><span class="line">                   SOL_SOCKET, SO_REUSEADDR,</span><br><span class="line">                   &amp;enable, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;setsockopt(SO_REUSEADDR)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">    srv_addr.sin_family = AF_INET;</span><br><span class="line">    srv_addr.sin_port = htons(port);</span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们绑定到一个端口，将这个套接字变成一个监听套接字。</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sock,</span><br><span class="line">             (<span class="keyword">const</span> struct sockaddr *)&amp;srv_addr,</span><br><span class="line">             <span class="keyword">sizeof</span>(srv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(sock, <span class="number">10</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_accept_request</span><span class="params">(<span class="keyword">int</span> server_socket, struct sockaddr_in *client_addr, <span class="keyword">socklen_t</span> *client_addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    io_uring_prep_accept(sqe, server_socket, (struct sockaddr *)client_addr, client_addr_len, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req));</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_ACCEPT;</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_read_request</span><span class="params">(<span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req) + <span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_base = <span class="built_in">malloc</span>(READ_SZ);</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_len = READ_SZ;</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_READ;</span><br><span class="line">    req-&gt;client_socket = client_socket;</span><br><span class="line">    <span class="built_in">memset</span>(req-&gt;iov[<span class="number">0</span>].iov_base, <span class="number">0</span>, READ_SZ);</span><br><span class="line">    <span class="comment">/* Linux内核5.5支持readv，但不支持recv()或read() */</span></span><br><span class="line">    io_uring_prep_readv(sqe, client_socket, &amp;req-&gt;iov[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_write_request</span><span class="params">(struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_WRITE;</span><br><span class="line">    io_uring_prep_writev(sqe, req-&gt;client_socket, req-&gt;iov, req-&gt;iovec_count, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _send_static_string_content(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> client_socket)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> zh_malloc(<span class="keyword">sizeof</span>(*req) + <span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slen = <span class="built_in">strlen</span>(str);</span><br><span class="line">    req-&gt;iovec_count = <span class="number">1</span>;</span><br><span class="line">    req-&gt;client_socket = client_socket;</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    req-&gt;iov[<span class="number">0</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(req-&gt;iov[<span class="number">0</span>].iov_base, str, slen);</span><br><span class="line">    add_write_request(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当ZeroHTTPd遇到除GET或POST以外的其他HTTP方法时，这个函数用来通知客户端。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_unimplemented_method</span><span class="params">(<span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _send_static_string_content(unimplemented_content, client_socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数用于在请求的文件未找到时，向客户端发送 &quot;HTTP Not Found &quot;代码和消息。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_http_404</span><span class="params">(<span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _send_static_string_content(http_404_content, client_socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一旦确定了要服务的静态文件，这个函数就会被用来读取文件，</span></span><br><span class="line"><span class="comment"> * 并使用Linux的sendfile()系统调用在客户端套接字上写入。</span></span><br><span class="line"><span class="comment"> * 这样我们就省去了将文件缓冲区从内核传送到用户空间再传送回来的麻烦。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_file_contents</span><span class="params">(<span class="keyword">char</span> *file_path, <span class="keyword">off_t</span> file_size, struct iovec *iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = zh_malloc(file_size);</span><br><span class="line">    fd = open(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        fatal_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We should really check for short reads here */</span></span><br><span class="line">    <span class="keyword">int</span> ret = read(fd, buf, file_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; file_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Encountered a short read.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    iov-&gt;iov_base = buf;</span><br><span class="line">    iov-&gt;iov_len = file_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 简单的函数，获取我们要服务的文件的文件扩展名。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">get_filename_ext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dot = <span class="built_in">strrchr</span>(filename, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dot || dot == filename)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> dot + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送HTTP 200 OK头，即服务器字符串，对于一些类型的文件，</span></span><br><span class="line"><span class="comment"> * 它还可以根据文件扩展名发送内容类型。它还会发送内容长度头。</span></span><br><span class="line"><span class="comment"> * 最后，它在一行中发送一个&#x27;\r\n&#x27;，表示头的结束和任何内容的开始。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_headers</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> len, struct iovec *iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> small_case_path[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> send_buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(small_case_path, path);</span><br><span class="line">    strtolower(small_case_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slen = <span class="built_in">strlen</span>(str);</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">0</span>].iov_base, str, slen);</span><br><span class="line"></span><br><span class="line">    slen = <span class="built_in">strlen</span>(SERVER_STRING);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">1</span>].iov_base, SERVER_STRING, slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 检查网页上某些常见类型文件的文件扩展名，并发送适当的内容类型头。</span></span><br><span class="line"><span class="comment">                 * 由于扩展名可以混合大小写，如JPG、jpg或Jpg，所以我们在检查前将扩展名变成小写。</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file_ext = get_filename_ext(small_case_path);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;jpg&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/jpeg\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;jpeg&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/jpeg\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;png&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/png\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;gif&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: image/gif\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;htm&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;html&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;js&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: application/javascript\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;css&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/css\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;txt&quot;</span>, file_ext) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;Content-Type: text/plain\r\n&quot;</span>);</span><br><span class="line">    slen = <span class="built_in">strlen</span>(send_buffer);</span><br><span class="line">    iov[<span class="number">2</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">2</span>].iov_base, send_buffer, slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送内容长度头，也就是本例中的文件大小。 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(send_buffer, <span class="string">&quot;content-length: %ld\r\n&quot;</span>, len);</span><br><span class="line">    slen = <span class="built_in">strlen</span>(send_buffer);</span><br><span class="line">    iov[<span class="number">3</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">3</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">3</span>].iov_base, send_buffer, slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 当浏览器看到一行中的&#x27;\r\n&#x27;序列时，它就会明白没有更多的标题了。内容可能随之而来。</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(send_buffer, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    slen = <span class="built_in">strlen</span>(send_buffer);</span><br><span class="line">    iov[<span class="number">4</span>].iov_base = zh_malloc(slen);</span><br><span class="line">    iov[<span class="number">4</span>].iov_len = slen;</span><br><span class="line">    <span class="built_in">memcpy</span>(iov[<span class="number">4</span>].iov_base, send_buffer, slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_get_method</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> final_path[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 如果一个路径以尾部的斜杠结束，客户端可能希望索引文件在该目录内。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(final_path, <span class="string">&quot;public&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(final_path, path);</span><br><span class="line">        <span class="built_in">strcat</span>(final_path, <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(final_path, <span class="string">&quot;public&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(final_path, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stat()系统调用会给出文件的信息，如类型（普通文件、目录等）、大小等。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">path_stat</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(final_path, &amp;path_stat) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;404 Not Found: %s (%s)\n&quot;</span>, final_path, path);</span><br><span class="line">        handle_http_404(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*检查这是否是一个正常的/常规的文件，而不是一个目录或其他东西。*/</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(path_stat.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            struct request *req = zh_malloc(<span class="keyword">sizeof</span>(*req) + (<span class="keyword">sizeof</span>(struct iovec) * <span class="number">6</span>));</span><br><span class="line">            req-&gt;iovec_count = <span class="number">6</span>;</span><br><span class="line">            req-&gt;client_socket = client_socket;</span><br><span class="line">            send_headers(final_path, path_stat.st_size, req-&gt;iov);</span><br><span class="line">            copy_file_contents(final_path, path_stat.st_size, &amp;req-&gt;iov[<span class="number">5</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;200 %s %ld bytes\n&quot;</span>, final_path, path_stat.st_size);</span><br><span class="line">            add_write_request(req);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            handle_http_404(client_socket);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;404 Not Found: %s\n&quot;</span>, final_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个函数查看所使用的方法，并调用相应的处理函数。因为我们只实现了GET和POST方法，</span></span><br><span class="line"><span class="comment"> * 所以它调用handle_unimplemented_method()，以防这两个方法不匹配。这将向客户发送一个错误。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_http_method</span><span class="params">(<span class="keyword">char</span> *method_buffer, <span class="keyword">int</span> client_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *method, *path, *saveptr;</span><br><span class="line"></span><br><span class="line">    method = strtok_r(method_buffer, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line">    strtolower(method);</span><br><span class="line">    path = strtok_r(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(method, <span class="string">&quot;get&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        handle_get_method(path, client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        handle_unimplemented_method(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">char</span> *dest, <span class="keyword">int</span> dest_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dest_sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">        <span class="keyword">if</span> (src[i] == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; src[i + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_client_request</span><span class="params">(struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> http_request[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">/* 获取第一行，这将是请求的内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (get_line(req-&gt;iov[<span class="number">0</span>].iov_base, http_request, <span class="keyword">sizeof</span>(http_request)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Malformed request\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    handle_http_method(http_request, req-&gt;client_socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server_loop</span><span class="params">(<span class="keyword">int</span> server_socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> (struct request *)cqe-&gt;user_data;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            fatal_error(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Async request failed: %s for event: %d\n&quot;</span>,</span><br><span class="line">                    strerror(-cqe-&gt;res), req-&gt;event_type);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (req-&gt;event_type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> EVENT_TYPE_ACCEPT:</span><br><span class="line">            add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">            add_read_request(cqe-&gt;res);</span><br><span class="line">            <span class="built_in">free</span>(req);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EVENT_TYPE_READ:</span><br><span class="line">            <span class="keyword">if</span> (!cqe-&gt;res)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Empty request!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            handle_client_request(req);</span><br><span class="line">            <span class="built_in">free</span>(req-&gt;iov[<span class="number">0</span>].iov_base);</span><br><span class="line">            <span class="built_in">free</span>(req);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EVENT_TYPE_WRITE:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req-&gt;iovec_count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(req-&gt;iov[i].iov_base);</span><br><span class="line">            &#125;</span><br><span class="line">            close(req-&gt;client_socket);</span><br><span class="line">            <span class="built_in">free</span>(req);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将此请求标记为已处理 */</span></span><br><span class="line">        io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;^C pressed. Shutting down.\n&quot;</span>);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_socket = setup_listening_socket(DEFAULT_SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    server_loop(server_socket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>运行这个程序</h1><p>这个程序要求您从包含“ public”文件夹的目录中运行它，该文件夹中有一个 <code>index.html</code> 文件和一个图像。<br>如果您按照<a href="https://github.com/shuveb/loti-examples">构建指令</a>到示例程序，那么您新构建的二进制文件应该位于 <code>build</code> 目录中。<br>你需要换到git repo的根目录下，&quot;public &quot;文件夹就在那里，然后运行它。<br>构建所有示例并运行这个 webserver 示例的示例会话如下所示:</p><pre><code>$ mkdir build$ cd build$ cmake ..$ cmake --build .$ cd ..$ build/webserver_liburingMinimum kernel version required is: 5.5Your kernel version is: 5.6ZeroHTTPd listening on port: 8000</code></pre><h2 id="程序结构"><a class="header-anchor" href="#程序结构">¶</a>程序结构</h2><p>首先，main()函数调用 <strong>setup_listening_socket()</strong> 在指定的端口上监听。但是我们不调用accept()来实际接受连接。<br>我们通过io_uring请求来实现这一点，后面会解释。</p><p>程序的核心是**server_loop()**函数，它向io_uring发送提交(自己和通过其他函数)，<br>等待完成队列条目并处理它们。让我们仔细看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server_loop</span><span class="params">(<span class="keyword">int</span> server_socket)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">        add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> (struct request *) cqe-&gt;user_data;</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                        fatal_error(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Async request failed: %s for event: %d\n&quot;</span>,</span><br><span class="line">                                        strerror(-cqe-&gt;res), req-&gt;event_type);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">switch</span> (req-&gt;event_type) &#123;</span><br><span class="line">                        <span class="keyword">case</span> EVENT_TYPE_ACCEPT:</span><br><span class="line">                                add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">                                add_read_request(cqe-&gt;res);</span><br><span class="line">                                <span class="built_in">free</span>(req);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> EVENT_TYPE_READ:</span><br><span class="line">                                <span class="keyword">if</span> (!cqe-&gt;res) &#123;</span><br><span class="line">                                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Empty request!\n&quot;</span>);</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                handle_client_request(req);</span><br><span class="line">                                <span class="built_in">free</span>(req-&gt;iov[<span class="number">0</span>].iov_base);</span><br><span class="line">                                <span class="built_in">free</span>(req);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> EVENT_TYPE_WRITE:</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req-&gt;iovec_count; i++) &#123;</span><br><span class="line">                                        <span class="built_in">free</span>(req-&gt;iov[i].iov_base);</span><br><span class="line">                                &#125;</span><br><span class="line">                                close(req-&gt;client_socket);</span><br><span class="line">                                <span class="built_in">free</span>(req);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 将此请求标记为已处理 */</span></span><br><span class="line">                io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入while循环之前，我们通过调用 <code>add_accept_request()</code> 来提交一个 <code>accept()</code> 的请求。这样就可以接受任何客户端对服务器的连接。让我们仔细看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_accept_request</span><span class="params">(<span class="keyword">int</span> server_socket, struct sockaddr_in *client_addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">socklen_t</span> *client_addr_len)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">        io_uring_prep_accept(sqe, server_socket, (struct sockaddr *) client_addr,</span><br><span class="line">                                                client_addr_len, <span class="number">0</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req));</span><br><span class="line">        req-&gt;event_type = EVENT_TYPE_ACCEPT;</span><br><span class="line">        io_uring_sqe_set_data(sqe, req);</span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得到一个 SQE，并准备一个 accept ()操作，用liburing的io_uring_prep_accept()提交。我们使用一个request结构体来跟踪我们的每个提交。这些实例具有每个请求从一个状态到下一个状态的上下文。让我们来看一下 request 结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> event_type;</span><br><span class="line">        <span class="keyword">int</span> iovec_count;</span><br><span class="line">        <span class="keyword">int</span> client_socket;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户机请求要经过3个状态，上面的结构体可以容纳足够的信息，能够处理这些状态之间的转换。客户端请求的三种状态是:</p><p>Accepted -&gt; Request read -&gt; Response written</p><p>让我们看看在完成侧大的 switch/case 代码块，一旦 <code>accept ()</code> 操作完成后会发生什么:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EVENT_TYPE_ACCEPT:</span><br><span class="line">     add_accept_request(server_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">     add_read_request(cqe-&gt;res);</span><br><span class="line">     <span class="built_in">free</span>(req);</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>既然已经处理了前一个请求，我们就在提交队列中添加一个新的<code>accept()</code>请求。否则我们的程序将不会接受任何来自客户端的新连接。<br>然后我们调用<code>add_read_request()</code>函数，它为readv()添加一个提交请求，这样我们就可以从客户端读取HTTP请求。<br>这里有几件事:</p><ol><li>我们本来可以使用<code>read()</code>，但是<code>io_uring</code>中直到内核版本5.6才支持该操作，而在撰写本文时，<br>内核版本5.6是一个非常稳定的版本，至少几个月后才会在许多发行版中出现。</li><li>使用<code>readv()</code>和<code>writev()</code>允许我们内置许多通用逻辑，特别是我们稍后会看到的缓冲区管理。现在，让我们看看<code>add_read_request()</code>:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_read_request</span><span class="params">(<span class="keyword">int</span> client_socket)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*req) + <span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">        req-&gt;iov[<span class="number">0</span>].iov_base = <span class="built_in">malloc</span>(READ_SZ);</span><br><span class="line">        req-&gt;iov[<span class="number">0</span>].iov_len = READ_SZ;</span><br><span class="line">        req-&gt;event_type = EVENT_TYPE_READ;</span><br><span class="line">        req-&gt;client_socket = client_socket;</span><br><span class="line">        <span class="built_in">memset</span>(req-&gt;iov[<span class="number">0</span>].iov_base, <span class="number">0</span>, READ_SZ);</span><br><span class="line">        <span class="comment">/* Linux kernel 5.5 has support for readv, but not for recv() or read() */</span></span><br><span class="line">        io_uring_prep_readv(sqe, client_socket, &amp;req-&gt;iov[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        io_uring_sqe_set_data(sqe, req);</span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，这是相当直接的。我们分配一个足够大的缓冲区来容纳客户机请求，<br>并在提交请求之前调用 <code>io_uring_prep_readv ()</code>,该调用处于liburing状态。完成端相应的处理是由switch/case块中的条件来完成的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EVENT_TYPE_READ:</span><br><span class="line">    <span class="keyword">if</span> (!cqe-&gt;res) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Empty request!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    handle_client_request(req);</span><br><span class="line">    <span class="built_in">free</span>(req-&gt;iov[<span class="number">0</span>].iov_base);</span><br><span class="line">    <span class="built_in">free</span>(req);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里，我们实际上调用了 <code>handle_client_request()</code> 函数处理 HTTP 请求。如果一切顺利，客户端要求的是磁盘上的一个文件，这段代码运行如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> zh_malloc(<span class="keyword">sizeof</span>(*req) + (<span class="keyword">sizeof</span>(struct iovec) * <span class="number">6</span>));</span><br><span class="line">req-&gt;iovec_count = <span class="number">6</span>;</span><br><span class="line">req-&gt;client_socket = client_socket;</span><br><span class="line">set_headers(final_path, path_stat.st_size, req-&gt;iov);</span><br><span class="line">copy_file_contents(final_path, path_stat.st_size, &amp;req-&gt;iov[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;200 %s %ld bytes\n&quot;</span>, final_path, path_stat.st_size);</span><br><span class="line">add_write_request( req);</span><br></pre></td></tr></table></figure><p>函数 set_headers() 设置了总共5个小缓冲区，由5个不同的 ivec 结构体表示。<br>最终的 iovec 实例包含正在读取的文件的内容。最后，调用 add_write_request ()来添加一个提交队列条目:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_write_request</span><span class="params">(struct request *req)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">    req-&gt;event_type = EVENT_TYPE_WRITE;</span><br><span class="line">    io_uring_prep_writev(sqe, req-&gt;client_socket, req-&gt;iov, req-&gt;iovec_count, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, req);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此提交导致内核在客户端套接字上写出响应头和文件内容，从而完成请求/响应循环。以下是我们在完成方面所做的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EVENT_TYPE_WRITE:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req-&gt;iovec_count; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(req-&gt;iov[i].iov_base);</span><br><span class="line">    &#125;</span><br><span class="line">    close(req-&gt;client_socket);</span><br><span class="line">    <span class="built_in">free</span>(req);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>我们释放我们曾经创建的多个指向缓冲区的iovec，释放了请求结构体实例，还关闭了客户端套接字，从而完成了 HTTP 请求的服务。</p><h1>源代码</h1><p>这个和其他例子的源代码可以在 <a href="https://github.com/shuveb/loti-examples">Github</a> 上找到。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liburing 实现 cp 命令</title>
      <link href="/jony.github.io/fbcd2bb270f6/"/>
      <url>/jony.github.io/fbcd2bb270f6/</url>
      
        <content type="html"><![CDATA[<h1>liburing 实现 cp 命令</h1><p>在前面的小节中，我们看到了如何使用liburing提供的高级接口来构建相当于Unix cat的工具。<br>然而，在这两个例子中，我们队列没有同时处理超过一个请求。 io_uring的目标之一是能够通过<br>让用户同时排队几个操作来减少系统调用的数量，这样内核就可以一下子接收并处理这些操作，<br>而不需要程序为每个I/O请求进行一次或多次系统调用。</p><p>为此，在本部分中，我们构建一个复制文件的复制程序。它试图通过队<br>列深度允许的尽可能多的请求进来，这样尽量提高效率。让我们看看一些代码。<br>这在很大程度上是基于 <a href="https://github.com/axboe/fio/blob/master/t/io_uring.c">fio 包</a> 中的一个程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QD  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BS (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> infd, outfd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> read;</span><br><span class="line">    <span class="keyword">off_t</span> first_offset, offset;</span><br><span class="line">    <span class="keyword">size_t</span> first_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setup_context</span><span class="params">(<span class="keyword">unsigned</span> entries, struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = io_uring_queue_init(entries, ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;queue_init: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> *size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(st.st_mode)) &#123;</span><br><span class="line">        *size = st.st_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        *size = bytes;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue_prepped</span><span class="params">(struct io_uring *ring, struct io_data *data)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    assert(sqe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;read)</span><br><span class="line">        io_uring_prep_readv(sqe, infd, &amp;data-&gt;iov, <span class="number">1</span>, data-&gt;offset);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        io_uring_prep_writev(sqe, outfd, &amp;data-&gt;iov, <span class="number">1</span>, data-&gt;offset);</span><br><span class="line"></span><br><span class="line">    io_uring_sqe_set_data(sqe, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_read</span><span class="params">(struct io_uring *ring, <span class="keyword">off_t</span> size, <span class="keyword">off_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(*data));</span><br><span class="line">    <span class="keyword">if</span> (!data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data-&gt;read = <span class="number">1</span>;</span><br><span class="line">    data-&gt;offset = data-&gt;first_offset = offset;</span><br><span class="line"></span><br><span class="line">    data-&gt;iov.iov_base = data + <span class="number">1</span>;</span><br><span class="line">    data-&gt;iov.iov_len = size;</span><br><span class="line">    data-&gt;first_len = size;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_readv(sqe, infd, &amp;data-&gt;iov, <span class="number">1</span>, offset);</span><br><span class="line">    io_uring_sqe_set_data(sqe, data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue_write</span><span class="params">(struct io_uring *ring, struct io_data *data)</span> </span>&#123;</span><br><span class="line">    data-&gt;read = <span class="number">0</span>;</span><br><span class="line">    data-&gt;offset = data-&gt;first_offset;</span><br><span class="line"></span><br><span class="line">    data-&gt;iov.iov_base = data + <span class="number">1</span>;</span><br><span class="line">    data-&gt;iov.iov_len = data-&gt;first_len;</span><br><span class="line"></span><br><span class="line">    queue_prepped(ring, data);</span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_file</span><span class="params">(struct io_uring *ring, <span class="keyword">off_t</span> insize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reads, writes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">off_t</span> write_left, offset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write_left = insize;</span><br><span class="line">    writes = reads = offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (insize || write_left) &#123;</span><br><span class="line">        <span class="keyword">int</span> had_reads, got_comp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 尽可能多地排队读取 */</span></span><br><span class="line">        had_reads = reads;</span><br><span class="line">        <span class="keyword">while</span> (insize) &#123;</span><br><span class="line">            <span class="keyword">off_t</span> this_size = insize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (reads + writes &gt;= QD)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (this_size &gt; BS)</span><br><span class="line">                this_size = BS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!this_size)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (queue_read(ring, this_size, offset))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            insize -= this_size;</span><br><span class="line">            offset += this_size;</span><br><span class="line">            reads++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (had_reads != reads) &#123;</span><br><span class="line">            ret = io_uring_submit(ring);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;io_uring_submit: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 此时队列已满。让我们至少找到一个 completion */</span></span><br><span class="line">        got_comp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (write_left) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!got_comp) &#123;</span><br><span class="line">                ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">                got_comp = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret = io_uring_peek_cqe(ring, &amp;cqe);</span><br><span class="line">                <span class="keyword">if</span> (ret == -EAGAIN) &#123;</span><br><span class="line">                    cqe = <span class="literal">NULL</span>;</span><br><span class="line">                    ret = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;io_uring_peek_cqe: %s\n&quot;</span>,</span><br><span class="line">                        strerror(-ret));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!cqe)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            data = io_uring_cqe_get_data(cqe);</span><br><span class="line">            <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cqe-&gt;res == -EAGAIN) &#123;</span><br><span class="line">                    queue_prepped(ring, data);</span><br><span class="line">                    io_uring_cqe_seen(ring, cqe);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;cqe failed: %s\n&quot;</span>,</span><br><span class="line">                        strerror(-cqe-&gt;res));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cqe-&gt;res != data-&gt;iov.iov_len) &#123;</span><br><span class="line">                <span class="comment">/*短时间读/写；调整并重新排队 */</span></span><br><span class="line">                data-&gt;iov.iov_base += cqe-&gt;res;</span><br><span class="line">                data-&gt;iov.iov_len -= cqe-&gt;res;</span><br><span class="line">                queue_prepped(ring, data);</span><br><span class="line">                io_uring_cqe_seen(ring, cqe);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 全都做完了。如果写了，就没别的事可做了。如果读取，则将相应的写入排队。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data-&gt;read) &#123;</span><br><span class="line">                queue_write(ring, data);</span><br><span class="line">                write_left -= data-&gt;first_len;</span><br><span class="line">                reads--;</span><br><span class="line">                writes++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">free</span>(data);</span><br><span class="line">                writes--;</span><br><span class="line">            &#125;</span><br><span class="line">            io_uring_cqe_seen(ring, cqe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="keyword">off_t</span> insize;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;infile&gt; &lt;outfile&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (infd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open infile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outfd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open outfile&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_context(QD, &amp;ring))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (get_file_size(infd, &amp;insize))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ret = copy_file(&amp;ring, insize);</span><br><span class="line"></span><br><span class="line">    close(infd);</span><br><span class="line">    close(outfd);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>程序结构</h1><p>这个复制程序像大多数其他程序一样，将第一个参数指向的文件复制到第二个参数指向的文件中。<br>该程序的核心是 <strong><code>copy_ file()</code></strong> 函数。在这里，我们设置了一个外层的 <code>while</code> 循环，而这个循环又包含了另外2个嵌套在同一层次的 <code>while</code> 循环。虽然外层的 while 循环是为了确保源文件的所有字节都被复制，但是第一个嵌套 <code>while</code> 循环的任务是创建尽可能多的 <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a> 类型请求。事实上，<br>它排队的数量是队列深度允许的数量。</p><p>一旦队列满了，我们就进入第二个嵌套的 <code>while</code> 循环。这个循环收集完成队列条目，<br>并提交写入目标文件的请求，现在数据已经被读取。有几个变量跟踪状态，可能会有点混乱。但异步文件复制程序能有多难呢？:)</p><p>基于 <a href="unixism.net/2020/04/io-uring-by-example-part-2-queuing-multiple-requests/">unixism.net/2020/04/io-uring-by-example-part-2-queuing-multiple-requests/</a></p><h1>源码</h1><p>此示例和其他示例的源代码可在<a href="https://github.com/shuveb/loti-examples">Github</a>上使用。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>liburing 实现 cat 命令</title>
      <link href="/jony.github.io/33f4e488c2f3/"/>
      <url>/jony.github.io/33f4e488c2f3/</url>
      
        <content type="html"><![CDATA[<h1>cat 使用 liburing 实现</h1><p>我们看到，用io_uring构建一个读取文件的程序这么简单的东西，可能并不那么简单。事实证明，与读取同步 i/o 文件的程序相比，它的代码更多。但是，如果你分析使用<a href="https://unixism.net/loti/low_level.html#low-level">底层 io _ uring 接口的 cat 实用程序</a>的代码，你会发现大部分代码都是重复代码，可以很容易地隐藏在一个单独的文件中，它应该不会出现在应用逻辑。无论如何，无论如何，我们学习底层的io_uring细节是为了更好地理解它的工作原理。现在，让我们看看如何使用 liburing 实现功能类似的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SZ    1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">off_t</span> file_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovecs</span>[];</span>      <span class="comment">/* Referred by readv/writev */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回传入打开文件描述符的文件的大小。 </span></span><br><span class="line"><span class="comment">* 正确处理常规文件和块设备。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bytes;</span><br><span class="line">        <span class="comment">// 获取文件字节大小64位</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(st.st_mode))</span><br><span class="line">        <span class="keyword">return</span> st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出一串长度为len的字符到stdout。</span></span><br><span class="line"><span class="comment"> * 我们在这里使用缓冲输出是有效的，因为我们需要逐字符输出。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_to_console</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        fputc(*buf++, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 等待完成可用，从readv操作中获取数据并打印到控制台。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_completion_and_print</span><span class="params">(struct io_uring *ring)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="comment">// 等待完成队列</span></span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果完成队列的事件代码小于0</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Async readv failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取完成队列的数据返回</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span> =</span> io_uring_cqe_get_data(cqe);</span><br><span class="line">    <span class="comment">// 文件字节大小初一数据块大小，按照 1024 字节切割</span></span><br><span class="line">    <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) fi-&gt;file_sz / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">if</span> (fi-&gt;file_sz % BLOCK_SZ) blocks++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks; i ++)</span><br><span class="line">        output_to_console(fi-&gt;iovecs[i].iov_base, fi-&gt;iovecs[i].iov_len);</span><br><span class="line"></span><br><span class="line">    io_uring_cqe_seen(ring, cqe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过liburing提交readv请求</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">submit_read_request</span><span class="params">(<span class="keyword">char</span> *file_path, struct io_uring *ring)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">int</span> file_fd = open(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="keyword">off_t</span> file_sz = get_file_size(file_fd);</span><br><span class="line">    <span class="comment">// 文件剩余字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> bytes_remaining = file_sz;</span><br><span class="line">    <span class="comment">// 偏移值</span></span><br><span class="line">    <span class="keyword">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前块大小</span></span><br><span class="line">    <span class="keyword">int</span> current_block = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算文件可以切割多少快</span></span><br><span class="line">    <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) file_sz / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">if</span> (file_sz % BLOCK_SZ) blocks++;</span><br><span class="line">    <span class="comment">// 分配文件大小信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*fi) + (<span class="keyword">sizeof</span>(struct iovec) * blocks));</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">char</span> *buff = <span class="built_in">malloc</span>(file_sz);</span><br><span class="line">    <span class="keyword">if</span> (!buff) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to allocate memory.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对于我们需要读取的文件的每个块，</span></span><br><span class="line"><span class="comment">     * 我们分配一个iovec结构，它被索引到iovecs数组中。 </span></span><br><span class="line"><span class="comment">     * 此数组作为提交的一部分传入。 如果您不明白这一点，</span></span><br><span class="line"><span class="comment">     * 那么您需要查找readv()和writev()系统调用是如何工作的。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span> (bytes_remaining) &#123;</span><br><span class="line">        <span class="keyword">off_t</span> bytes_to_read = bytes_remaining;</span><br><span class="line">        <span class="comment">// 每次最多读 1024 字节</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_read &gt; BLOCK_SZ)</span><br><span class="line">            bytes_to_read = BLOCK_SZ;</span><br><span class="line">        <span class="comment">// 偏移值</span></span><br><span class="line">        offset += bytes_to_read;</span><br><span class="line"></span><br><span class="line">        fi-&gt;iovecs[current_block].iov_len = bytes_to_read;</span><br><span class="line">        <span class="keyword">void</span> *buf;</span><br><span class="line">        <span class="comment">// posix_memalign:https://blog.csdn.net/wallwind/article/details/7461701</span></span><br><span class="line">        <span class="comment">// 动态分配内存，1024 字节对齐</span></span><br><span class="line">        <span class="keyword">if</span>( posix_memalign(&amp;buf, BLOCK_SZ, BLOCK_SZ)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据的基地地址</span></span><br><span class="line">        fi-&gt;iovecs[current_block].iov_base = buf;</span><br><span class="line">        <span class="comment">// 当前块大小加一</span></span><br><span class="line">        current_block++;</span><br><span class="line">        <span class="comment">// 剩余字节数减一</span></span><br><span class="line">        bytes_remaining -= bytes_to_read;</span><br><span class="line">    &#125;</span><br><span class="line">    fi-&gt;file_sz = file_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取一个 SQE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line">    <span class="comment">/* 设置读操作n */</span></span><br><span class="line">    io_uring_prep_readv(sqe, file_fd, fi-&gt;iovecs, blocks, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 设置用户数据 */</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, fi);</span><br><span class="line">    <span class="comment">/* 最后提交请求 */</span></span><br><span class="line">    io_uring_submit(ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [file name] &lt;[file name] ...&gt;\n&quot;</span>,</span><br><span class="line">                argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize io_uring */</span></span><br><span class="line">    io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = submit_read_request(argv[i], &amp;ring);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error reading file: %s\n&quot;</span>, argv[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        get_completion_and_print(&amp;ring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the clean-up function. */</span></span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复的代码被提取后。让我们快速浏览一下。我们像这样初始化 io_uring:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在方法 submit_read_request()中，我们得到一个 SQE，准备执行 readv 操作并提交它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取一个 SQE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line"><span class="comment">/* 设置一个 readv 操作 */</span></span><br><span class="line">io_uring_prep_readv(sqe, file_fd, fi-&gt;iovecs, blocks, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 设置 user_data */</span></span><br><span class="line">io_uring_sqe_set_data(sqe, fi);</span><br><span class="line"><span class="comment">/* 最后提交请求 */</span></span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure><p>我们等待一个完成事件，然后得到我们在提交端设置的用户数据，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span> =</span> io_uring_cqe_get_data(cqe);</span><br></pre></td></tr></table></figure><p>当然，与使用原始界面相比，使用这个界面要简单得多。</p><h1>参考</h1><ul><li><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_init">io_uring_queue_init()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_get_sqe">io_uring_get_sqe()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_readv">io_uring_prep_readv()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_sqe_set_data">io_uring_sqe_set_data()</a></li><li><a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_submit">io_uring_submit()</a></li><li><a href="https://unixism.net/loti/ref-liburing/completion.html#c.io_uring_wait_cqe">io_uring_wait_cqe()</a></li><li><a href="https://unixism.net/loti/ref-liburing/completion.html#c.io_uring_cqe_get_data">io_uring_cqe_get_data()</a></li><li><a href="https://unixism.net/loti/ref-liburing/setup_teardown.html#c.io_uring_queue_exit">io_uring_queue_exit()</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io_uring 底层接口</title>
      <link href="/jony.github.io/3d70b9e6d77f/"/>
      <url>/jony.github.io/3d70b9e6d77f/</url>
      
        <content type="html"><![CDATA[<h1>io_uring 的底层接口</h1><p>正如在前一个文章中所建议的那样，您不太可能在正式的程序中使用 <code>io_uring</code> 底层的 API。但是知道接口真正使用起来是什么样的方式总是一个好主意。为此，您必须通过共享环缓冲区和相关的 <code>io_uring</code> 系统调用来处理 <code>io_uring</code> 直接呈现给程序的接口。一个很好、简单的例子，可以很好地展示这个接口。为此，在这里，我们提供了一个模拟 Unix cat 实用程序的示例。为了保持简单，我们将创建一个程序，一次显示一个操作，等待它完成并显示下一个操作等等。虽然一个真正的程序也可以使用同步/阻塞调用来以这种方式完成工作，但这个程序的主要目的是让您熟悉 i/o 接口，而不会受到其他程序逻辑的干扰。</p><h2 id="熟悉readv（2）系统调用"><a class="header-anchor" href="#熟悉readv（2）系统调用">¶</a>熟悉<a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv（2）</a>系统调用</h2><p>为了更好地理解这个示例，您需要熟悉 <code>[readv（2）](http://man7.org/linux/man-pages/man2/readv.2.html)</code>系统调用。如果你不熟悉它，我建议你读<a href="https://unixism.net/2020/04/io-uring-by-example-part-1-introduction/">一个更通俗的介绍</a>，然后回到这里继续。</p><h2 id="底层接口介绍"><a class="header-anchor" href="#底层接口介绍">¶</a>底层接口介绍</h2><p>它的接口很简单。有一个提交队列和一个完成队列。在提交队列中，您可以提交你想要完成的各种操作的信息。例如，在我们当前的程序中，我们希望使用 <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv（2）</a>读取文件，因此我们放置一个提交队列请求，将其描述为提交队列条目(SQE)的一部分。此外，您可以放置多个请求。根据队列深度(您可以定义)允许的请求数量。这些操作可以是读、写等操作的混合。这些操作可以是读、写等操作的混合。然后，我们调用 <code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code>系统调用，告诉内核我们已经向提交队列添加了请求。一旦它完成了这些请求的处理，它将结果作为 CQE 的一部分放置在完成队列中，或者为每个相应的 SQE 放置一个完成队列条目。这些 CQEs 可以立即从用户空间访问，因为它们被放置在一个由内核和用户空间共享的缓冲区中。</p><p>我们在前面已经讨论了 io_uring 的这个特殊优点，但是聪明的读者会注意到这样一个接口: 用多个 i/o 请求填充到一个队列中，然后进行一次系统调用的接口，而不是对每个I/O请求进行一次系统调用，这样就已经很高效了。为了进一步提高效率，<code>io_uring</code> 支持了一种模式，在这种模式下，内核会对你加入提交队列的条目进行轮询，<br>而你甚至不需要调用 **<code>[io_uring_enter ()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code>**来通知内核更新的提交队列条目。另一点需要注意的是，<br>在 <strong>Specter</strong> 和 <strong>Meltdown</strong> 硬件漏洞被发现并且操作系统为其创建了解决方案之后，系统调用比以往任何时候都要昂贵。因此，对于高性能应用程序来说，减少系统调用的数量确实是一件大事。</p><p>在执行这些操作之前，需要设置队列，它们实际上是具有一定深度/长度的环形缓冲区。<br>您可以调用 **<code>[io_ uring_setup ()](https://unixism.net/loti/ref-iouring/io_uring_setup.html#c.io_uring_setup)</code>**系统调用来完成此操作。我们通过将提交队列条目添加到循环缓冲区并从完成队<br>列循环缓冲区读取完成队列条目来完成真正的工作。这是对这个io_uring接口设计的概述。</p><h2 id="完成队列条目"><a class="header-anchor" href="#完成队列条目">¶</a>完成队列条目</h2><p>现在我们已经有了一个关于如何工作的心智模型，让我们更详细地看看这是如何完成的。与提交队列条目(SQE)相比，<br>完成队列条目(CQE)非常简单。那么，让我们先来看看。SQE 是一个 <strong><code>io_uring_sqe</code></strong> 结构的实例，您可以使用它提交请求。<br>将其添加到提交环缓冲区。CQE 是一个 <strong>io_uring_cqe</strong> 结构的实例，内核对添加到提交队列中的每个 <strong><code>io_uring_sqe</code></strong> 结构实例进行响应。它包含您通过 SQE 实例请求的操作的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">  __u64  user_data;   <span class="comment">/* sqe-&gt;user_data submission passed back */</span></span><br><span class="line">  __s32  res;         <span class="comment">/* 此事件的结果代码 */</span></span><br><span class="line">  __u32  flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="将完成与提交相关联"><a class="header-anchor" href="#将完成与提交相关联">¶</a>将完成与提交相关联</h2><p>正如在代码注释中提到的，<strong>user_data</strong> 字段是按原样从 SQE 传递到 CQE 实例的。假设您在提交队列中提交了一组请求，那么这些请求不一定以相同的顺序完成，<br>也不必以 CQEs 的身份出现在完成队列中。以下面的场景为例: 您的机器上有两个磁盘: 一个是慢速旋转的硬盘驱动器，另一个是超快的 SSD。<br>您在提交队列中提交2个请求。第一个在慢速旋转的硬盘上读取100kB 的文件，第二个在快速固态硬盘上读取同样大小的文件。<br>如果维护排序，即使来自 SSD 文件的数据会更早到达，内核是否应该等待来自旋转硬盘上的文件的数据变得可用？这是个不好的想法，<br>因为这会阻止我们以最快的速度运行。因此，当 CQEs 可用时，它们可以按任意顺序到达。无论哪个操作完成，其结果都会在 CQ 上公布。<br>由于 CQEs 的到达没有特定的顺序，现在你已经知道了从上面的 <strong>io_uring_cqe</strong> 结构中看到的 CQE 是什么样子的，你如何识别一个特定 CQE 对应的 SQE 请求？一种方法是使用 SQEs 和 CQEs 共有的 <strong>user_data</strong> 字段来标识完成情况。并不是说你要设置一个唯一的 ID 或者其他什么，而是你通常会传递一个指针。如果你对此感到困惑，那就等着看后面的例子吧。</p><p>完成队列条目很简单，因为它主要关注系统调用的返回值，这个返回值在 res 字段中返回。例如，如果您读取操作队列成功执行完成，那么它将包含读取的字节数。如果有错误，它将包含一个负的错误号。本质上，**<a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>**系统调用自身的内容将返回。</p><h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2><p>虽然我提到了 CQEs 可以以任何顺序到达，但是您可以强制使用 SQE 排序对某些操作进行排序，实际上是将它们链接起来。有关更多细节，请参见<a href="https://unixism.net/loti/tutorial/link_liburing.html#link-liburing">链接</a>请求教程。</p><h2 id="提交队列条目"><a class="header-anchor" href="#提交队列条目">¶</a>提交队列条目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">     <span class="keyword">void</span>  *iov_base;    <span class="comment">/*开始地址 */</span></span><br><span class="line">     <span class="keyword">size_t</span> iov_len;     <span class="comment">/*要传输的字节数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>iovec 每个结构只指向一个缓冲区。基址和长度。</p><p>submission 队列条目比 completion 队列条目稍微复杂一些，因为它需要足够通用，以表示和处理目前 Linux 可能采用的各种 i/o操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">  __u8  opcode;   <span class="comment">/* 指定操作类型 */</span></span><br><span class="line">  __u8  flags;    <span class="comment">/* IOSQE_ 标记 */</span></span><br><span class="line">  __u16  ioprio;  <span class="comment">/* ioprio 请求 */</span></span><br><span class="line">  __s32  fd;      <span class="comment">/* 要执行 IO 的文件描述符 */</span></span><br><span class="line">  __u64  off;     <span class="comment">/* 文件偏移 */</span></span><br><span class="line">  __u64  addr;    <span class="comment">/* 指向缓冲区或者iovecs */</span></span><br><span class="line">  __u32  len;     <span class="comment">/* 缓冲区大小或者iovecs 数量 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">__kernel_rwf_t</span>  rw_flags;</span><br><span class="line">    __u32    fsync_flags;</span><br><span class="line">    __u16    poll_events;</span><br><span class="line">    __u32    sync_range_flags;</span><br><span class="line">    __u32    msg_flags;</span><br><span class="line">  &#125;;</span><br><span class="line">  __u64  user_data;   <span class="comment">/* 完成时传回的数据  */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    __u16  buf_index; <span class="comment">/* 索引到固定缓冲区（如果使用） */</span></span><br><span class="line">    __u64  __pad2[<span class="number">3</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我知道这个结构看起来很繁杂。通常使用的字段只有少数，这很容易用一个简单的例子来解释，<br>比如我们正在处理的这个字段: cat。当你想使用 <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a>系统调用读取一个文件时:</p><ul><li>opcode 用于指定操作，在这个case 中， <a href="http://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a> 使用的是 <strong>IORING_OP_READV</strong> 常量</li><li>fd 用于指定表示要从中读取的文件的文件描述符</li><li>addr 用于指向 iovec 结构的数组，这些结构包含我们为 i/o 分配的缓冲区的地址和长度。</li><li>len  用于保存 iovec 结构的数组的长度。</li></ul><p>这并不是很难，不是吗？你填写这些值，让 io_uring 知道该做什么。你可以将多个SQE 加入队列，最后当你想让内核开始处理你 SQE 队列的请求时，调用 <strong><code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code></strong> 。</p><h2 id="使用-io-uring-实现-cat-命令"><a class="header-anchor" href="#使用-io-uring-实现-cat-命令">¶</a>使用 io_uring 实现 cat 命令</h2><p>让我们看看如何通过使用底层 <strong>io_uring</strong> 接口的来实现类似 cat 实用程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果你编译失败缺少这个头文件，那么是因为你得内核版本太低了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SZ    1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  x86规范 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_barrier()  __asm__ __volatile__(<span class="meta-string">&quot;&quot;</span>:::<span class="meta-string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_barrier() __asm__ __volatile__(<span class="meta-string">&quot;&quot;</span>:::<span class="meta-string">&quot;memory&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">struct io_uring_sqe &#123;</span></span><br><span class="line"><span class="comment">  __u8  opcode;   // sqe 操作类型代码</span></span><br><span class="line"><span class="comment">  __u8  flags;    // IOSQE_ flags </span></span><br><span class="line"><span class="comment">  __u16  ioprio;  // 请求ioprio</span></span><br><span class="line"><span class="comment">  __s32  fd;      // 执行IO操作的文件描述符</span></span><br><span class="line"><span class="comment">  __u64  off;     // 文件中的偏移量 </span></span><br><span class="line"><span class="comment">  __u64  addr;    // 指向缓冲区或iovecs的指针</span></span><br><span class="line"><span class="comment">  __u32  len;     // 缓冲区大小或iovecs数量</span></span><br><span class="line"><span class="comment">  union &#123;</span></span><br><span class="line"><span class="comment">    __kernel_rwf_t  rw_flags;</span></span><br><span class="line"><span class="comment">    __u32    fsync_flags;</span></span><br><span class="line"><span class="comment">    __u16    poll_events;</span></span><br><span class="line"><span class="comment">    __u32    sync_range_flags;</span></span><br><span class="line"><span class="comment">    __u32    msg_flags;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">  __u64  user_data;   // 完成时要传回的数据</span></span><br><span class="line"><span class="comment">  union &#123;</span></span><br><span class="line"><span class="comment">    __u16  buf_index; // 索引到固定缓冲区(如果使用)</span></span><br><span class="line"><span class="comment">    __u64  __pad2[3];</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct io_uring_params &#123;</span></span><br><span class="line"><span class="comment">  __u32 sq_entries;</span></span><br><span class="line"><span class="comment">  __u32 cq_entries;</span></span><br><span class="line"><span class="comment">  __u32 flags;</span></span><br><span class="line"><span class="comment">  __u32 sq_thread_cpu;</span></span><br><span class="line"><span class="comment">  __u32 sq_thread_idle;</span></span><br><span class="line"><span class="comment">  __u32 resv[5];</span></span><br><span class="line"><span class="comment">  struct io_sqring_offsets sq_off;</span></span><br><span class="line"><span class="comment">  struct io_cqring_offsets cq_off;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> &#123;</span> <span class="comment">// Submission ring</span></span><br><span class="line">    <span class="keyword">unsigned</span> *head;</span><br><span class="line">    <span class="keyword">unsigned</span> *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_entries;</span><br><span class="line">    <span class="keyword">unsigned</span> *flags;</span><br><span class="line">    <span class="keyword">unsigned</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> &#123;</span> <span class="comment">// completions ring</span></span><br><span class="line">    <span class="keyword">unsigned</span> *head;</span><br><span class="line">    <span class="keyword">unsigned</span> *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_entries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqes</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">submitter</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ring_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> <span class="title">sq_ring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> <span class="title">cq_ring</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">off_t</span> file_sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovecs</span>[];</span>      <span class="comment">/* Referred by readv/writev */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这段代码是在io_uring相关的系统调用不属于标准C库的时候编写的。 </span></span><br><span class="line"><span class="comment">* 所以，我们推出了自己的系统调用封装函数。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_setup</span><span class="params">(<span class="keyword">unsigned</span> entries, struct io_uring_params *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) syscall(__NR_io_uring_setup, entries, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_enter</span><span class="params">(<span class="keyword">int</span> ring_fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> to_submit,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> min_complete, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) syscall(__NR_io_uring_enter, ring_fd, to_submit, min_complete,</span><br><span class="line">                flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回传入的打开文件描述符的文件大小。也能正确处理常规文件和驱动设备。很好。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">get_file_size</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bytes;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(st.st_mode))</span><br><span class="line">        <span class="keyword">return</span> st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* io_uring需要进行大量的设置，这些设置看起来相当复杂，但并不都很难理解。</span></span><br><span class="line"><span class="comment">* 因为所有这些案例代码， 都在 io_uring的作者创建的liburing中，而且 liburing 相对容易使用。</span></span><br><span class="line"><span class="comment">* 但是，您应该花些时间来理解这段代码。</span></span><br><span class="line"><span class="comment">* 了解它的工作原理总是好的。出去好吹牛逼</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">app_setup_uring</span><span class="params">(struct submitter *s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> *<span class="title">sring</span> =</span> &amp;s-&gt;sq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> *<span class="title">cring</span> =</span> &amp;s-&gt;cq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *sq_ptr, *cq_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 我们需要将 io_uring_params 结构传递给的io_uring_setup（）调用并初始化为0。 </span></span><br><span class="line"><span class="comment">    * 如果需要，我们可以设置任何标志，但是对于本示例，我们不需要，因为这里只是做了简单的了解。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// io_uring_setup 返回值将用于调用 mmap 将两个环缓冲区和一组提交队列映射到用户空间</span></span><br><span class="line">    s-&gt;ring_fd = io_uring_setup(QUEUE_DEPTH, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ring_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_setup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * io_uring 通过两个 kernel-user 共享空间形成环形缓冲区通信。在最近的内核中，可以用 mmap() 调用来</span></span><br><span class="line"><span class="comment">    * 联合映射这个环形缓冲区。在直接操作完成队列时，提交队列有一个介于两者之间的间接数组。我们把它也映射进去。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sring_sz = p.sq_off.<span class="built_in">array</span> + p.sq_entries * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>);</span><br><span class="line">    <span class="keyword">int</span> cring_sz = p.cq_off.cqes + p.cq_entries * <span class="keyword">sizeof</span>(struct io_uring_cqe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 在内核版本 5.4 及以上，可能使用一个 mmap()  来映射 completion 缓冲区和 submission缓冲区.</span></span><br><span class="line"><span class="comment">    * 如果去检测内核版本还不如直接使用 io_uring_params 结构的特征字段，这是一个位掩码。如果设置了 IORING_FEAT_SINGLE_MMAP </span></span><br><span class="line"><span class="comment">    * 那么我们就可以不用再调用第二个mmap()来映射 CQ ring。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cring_sz &gt; sring_sz) &#123;</span><br><span class="line">            sring_sz = cring_sz;</span><br><span class="line">        &#125;</span><br><span class="line">        cring_sz = sring_sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * submission 队列和 completion 队列可以映射到 ring 缓冲区，但是老版本的内核只能映射到队列中。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    sq_ptr = mmap(<span class="number">0</span>, sring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">            MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line">    <span class="keyword">if</span> (sq_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">        cq_ptr = sq_ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 在旧的内核中分别映射完成队列环缓冲区 */</span></span><br><span class="line">        cq_ptr = mmap(<span class="number">0</span>, cring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_SHARED | MAP_POPULATE,</span><br><span class="line">                s-&gt;ring_fd, IORING_OFF_CQ_RING);</span><br><span class="line">        <span class="keyword">if</span> (cq_ptr == MAP_FAILED) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  将有用的字段保存在全局app_io_sq_ring结构中，以便以后方便地引用*/</span></span><br><span class="line">    sring-&gt;head = sq_ptr + p.sq_off.head;</span><br><span class="line">    sring-&gt;tail = sq_ptr + p.sq_off.tail;</span><br><span class="line">    sring-&gt;ring_mask = sq_ptr + p.sq_off.ring_mask;</span><br><span class="line">    sring-&gt;ring_entries = sq_ptr + p.sq_off.ring_entries;</span><br><span class="line">    sring-&gt;flags = sq_ptr + p.sq_off.flags;</span><br><span class="line">    sring-&gt;<span class="built_in">array</span> = sq_ptr + p.sq_off.<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射到提交队列条目数组中 */</span></span><br><span class="line">    s-&gt;sqes = mmap(<span class="number">0</span>, p.sq_entries * <span class="keyword">sizeof</span>(struct io_uring_sqe),</span><br><span class="line">            PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_SQES);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;sqes == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将有用的字段保存在全局的app_io_cq_ring结构中，以便以后方便地引用 */</span></span><br><span class="line">    cring-&gt;head = cq_ptr + p.cq_off.head;</span><br><span class="line">    cring-&gt;tail = cq_ptr + p.cq_off.tail;</span><br><span class="line">    cring-&gt;ring_mask = cq_ptr + p.cq_off.ring_mask;</span><br><span class="line">    cring-&gt;ring_entries = cq_ptr + p.cq_off.ring_entries;</span><br><span class="line">    cring-&gt;cqes = cq_ptr + p.cq_off.cqes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将长度为len的字符串输出到标准输出。我们在这里使用缓冲输出以提高效率，因为我们需要逐字符输出。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_to_console</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        fputc(*buf++, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从 completion 队列读取。在这个函数中，我们从 completion 队列中读取完成事件，</span></span><br><span class="line"><span class="comment">* 获取包含文件数据的数据缓冲区，并将其打印到控制台。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_from_cq</span><span class="params">(struct submitter *s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_cq_ring</span> *<span class="title">cring</span> =</span> &amp;s-&gt;cq_ring;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> head, reaped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    head = *cring-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read_barrier();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 记住，这是一个环形缓冲区。如果head == tail，则表示缓冲区为空。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (head == *cring-&gt;tail)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取一个条目 */</span></span><br><span class="line">        cqe = &amp;cring-&gt;cqes[head &amp; *s-&gt;cq_ring.ring_mask];</span><br><span class="line">        fi = (struct file_info*) cqe-&gt;user_data;</span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(<span class="built_in">abs</span>(cqe-&gt;res)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) fi-&gt;file_sz / BLOCK_SZ;</span><br><span class="line">        <span class="keyword">if</span> (fi-&gt;file_sz % BLOCK_SZ) blocks++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks; i++)</span><br><span class="line">            output_to_console(fi-&gt;iovecs[i].iov_base, fi-&gt;iovecs[i].iov_len);</span><br><span class="line"></span><br><span class="line">        head++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *cring-&gt;head = head;</span><br><span class="line">    write_barrier();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 提交到 submission 队列.</span></span><br><span class="line"><span class="comment">* 在这个方法, 我们提交请求到 submission 队列. </span></span><br><span class="line"><span class="comment">* 您可以提交多种类型的请求。我们的将是readv()请求，我们通过IORING_OP_READV来指定。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">submit_to_sq</span><span class="params">(<span class="keyword">char</span> *file_path, struct submitter *s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> file_fd = open(file_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">app_io_sq_ring</span> *<span class="title">sring</span> =</span> &amp;s-&gt;sq_ring;</span><br><span class="line">    <span class="keyword">unsigned</span> index = <span class="number">0</span>, current_block = <span class="number">0</span>, tail = <span class="number">0</span>, next_tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">off_t</span> file_sz = get_file_size(file_fd);</span><br><span class="line">    <span class="keyword">if</span> (file_sz &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">off_t</span> bytes_remaining = file_sz;</span><br><span class="line">    <span class="keyword">int</span> blocks = (<span class="keyword">int</span>) file_sz / BLOCK_SZ;</span><br><span class="line">    <span class="keyword">if</span> (file_sz % BLOCK_SZ) blocks++;</span><br><span class="line"></span><br><span class="line">    fi = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*fi) + <span class="keyword">sizeof</span>(struct iovec) * blocks);</span><br><span class="line">    <span class="keyword">if</span> (!fi) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to allocate memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fi-&gt;file_sz = file_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对于需要读取的每个文件块，我们分配一个iovec结构体，该结构体被索引到iovecs数组中。</span></span><br><span class="line"><span class="comment">    * 此数组作为提交的一部分传入。如果您不理解这一点，那么您需要查看readv()和writev()系统调用是如何工作的。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">while</span> (bytes_remaining) &#123;</span><br><span class="line">        <span class="keyword">off_t</span> bytes_to_read = bytes_remaining;</span><br><span class="line">        <span class="keyword">if</span> (bytes_to_read &gt; BLOCK_SZ)</span><br><span class="line">            bytes_to_read = BLOCK_SZ;</span><br><span class="line"></span><br><span class="line">        fi-&gt;iovecs[current_block].iov_len = bytes_to_read;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *buf;</span><br><span class="line">        <span class="keyword">if</span>( posix_memalign(&amp;buf, BLOCK_SZ, BLOCK_SZ)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;posix_memalign&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fi-&gt;iovecs[current_block].iov_base = buf;</span><br><span class="line"></span><br><span class="line">        current_block++;</span><br><span class="line">        bytes_remaining -= bytes_to_read;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将我们的 submission 队列条目添加到SQE ring缓冲区的尾部 */</span></span><br><span class="line">    next_tail = tail = *sring-&gt;tail;</span><br><span class="line">    next_tail++;</span><br><span class="line">    read_barrier();</span><br><span class="line">    index = tail &amp; *s-&gt;sq_ring.ring_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> &amp;s-&gt;sqes[index];</span><br><span class="line">    sqe-&gt;fd = file_fd;</span><br><span class="line">    sqe-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    sqe-&gt;opcode = IORING_OP_READV;</span><br><span class="line">    sqe-&gt;addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fi-&gt;iovecs;</span><br><span class="line">    sqe-&gt;len = blocks;</span><br><span class="line">    sqe-&gt;off = <span class="number">0</span>;</span><br><span class="line">    sqe-&gt;user_data = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) fi;</span><br><span class="line">    sring-&gt;<span class="built_in">array</span>[index] = index;</span><br><span class="line">    tail = next_tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新尾部以便内核能够看到它. */</span></span><br><span class="line">    <span class="keyword">if</span>(*sring-&gt;tail != tail) &#123;</span><br><span class="line">        *sring-&gt;tail = tail;</span><br><span class="line">        write_barrier();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 用io_uring_enter()系统调用告诉内核我们已经提交了事件。</span></span><br><span class="line"><span class="comment">    * 我们还传递了IOURING_ENTER_GETEVENTS标志，</span></span><br><span class="line"><span class="comment">    * 它使io_uring_enter()调用等到min_complete事件（第3个参数）完成。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">int</span> ret =  io_uring_enter(s-&gt;ring_fd, <span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">            IORING_ENTER_GETEVENTS);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_enter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">submitter</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*s));</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(*s));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(app_setup_uring(s)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup uring!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(submit_to_sq(argv[i], s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error reading file\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        read_from_cq(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释"><a class="header-anchor" href="#解释">¶</a>解释</h2><p>让我们更深入地研究代码中特定的、重要的领域，看看这个示例程序是如何工作的。</p><h2 id="初始化设置"><a class="header-anchor" href="#初始化设置">¶</a>初始化设置</h2><p>在 <strong>main()</strong> 中，我们调用 <strong>app_setup_uring()</strong> ，它完成了我们使用 <strong>io_uring</strong> 所需的初始化工作。首先，我们调用 <strong>io_uring_setup()</strong> 系统调用，将我们需要的队列深度和结构 <strong>io_uring_params</strong> 的实例全部设置为0。当调用返回时，内核将填充这个结构成员中的值。这就是 <strong>io_uring_params</strong> 的样子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">  __u32 sq_entries;</span><br><span class="line">  __u32 cq_entries;</span><br><span class="line">  __u32 flags;</span><br><span class="line">  __u32 sq_thread_cpu;</span><br><span class="line">  __u32 sq_thread_idle;</span><br><span class="line">  __u32 resv[<span class="number">5</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在将这个结构作为 **<code>io_uring_setup ()</code>**系统调用的一部分传递之前，您唯一可以指定的是 flags 结构成员，但是在这个示例中，<br>我们不想传递任何 flag 。此外，在这个示例中，我们一个接一个地处理文件。我们不打算做任何并行 i/o，因为这是一个简单的例子，主要是为了了解 io_uring 的原始接口。为此，我们将队列深度设置为1。</p><p>来自 <strong><code>io_uring_setup ()</code></strong> 的返回值、文件描述符和 <strong>io_uring_param</strong> 结构中的其他字段随后将用于调用 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a>以将两个环缓冲区和一组提交队列条目映射到用户空间。看看吧。我已经删除了一些周围的代码，以便将重点放在 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a> 调用上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* submission 和 completion 队列中映射环形缓冲区.</span></span><br><span class="line"><span class="comment"> * 不过旧的内核只在提交队列中映射。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">sq_ptr = mmap(<span class="number">0</span>, sring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">        MAP_SHARED | MAP_POPULATE,</span><br><span class="line">        s-&gt;ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line"><span class="keyword">if</span> (sq_ptr == MAP_FAILED) &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p.features &amp; IORING_FEAT_SINGLE_MMAP) &#123;</span><br><span class="line">    cq_ptr = sq_ptr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 在旧内核中单独映射完成队列环形缓冲区 */</span></span><br><span class="line">    cq_ptr = mmap(<span class="number">0</span>, cring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">            MAP_SHARED | MAP_POPULATE,</span><br><span class="line">            s-&gt;ring_fd, IORING_OFF_CQ_RING);</span><br><span class="line">    <span class="keyword">if</span> (cq_ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 映射到提交队列条目数组中 */</span></span><br><span class="line">s-&gt;sqes = mmap(<span class="number">0</span>, p.sq_entries * <span class="keyword">sizeof</span>(struct io_uring_sqe),</span><br><span class="line">        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">        s-&gt;ring_fd, IORING_OFF_SQES);</span><br></pre></td></tr></table></figure><p>我们将重要的细节保存在 <strong><code>app_io_sq_ring</code></strong> 和 <strong><code>app_io_cq_ring</code></strong> 中，以便以后参考。<br>当我们将两个环缓冲区分别映射为提交和完成时，您可能想知道第三个映射是用来做什么的。<br>完成队列环直接对 CQEs 的共享数组建立索引，而提交环在两者之间有一个间接数组。<br>提交端环形缓冲区是该数组的索引，该数组又包含 SQEs 中的索引。这对于将提交请求嵌入内部数据结构的某些应用程序非常有用。<br>这种设置允许他们一次提交多个提交条目，同时允许他们更容易地采用io_uring。</p><pre><code># 注意在内核版本5.4及以上，单个 mmap (2)映射提交队列和完成队列。然而，在较老的内核中，它们需要单独映射。与检查内核版本不同，您可以通过检查 IORING_FEAT_SINGLE_MMAP  功能标志来检查内核使用一个 mmap (2)映射两个队列的能力，就像我们在上面的代码中所做的那样。# 参考- [io_uring_setup](https://unixism.net/loti/ref-iouring/io_uring_setup.html#io-uring-setup)</code></pre><h2 id="处理共享-ring-缓冲器"><a class="header-anchor" href="#处理共享-ring-缓冲器">¶</a>处理共享 ring 缓冲器</h2><p>在常规编程中，我们习惯于处理用户空间和内核之间非常清晰的接口: 系统调用。然而，<br>系统调用确实有成本，对于像 <strong>io_uring</strong> 这样的高性能接口，希望尽可能去掉系统调用。<br>我们在前面看到，与通常的多个系统调用不同，使用 io_uring<br>允许我们批处理多个 i/o 请求，并对 <strong><code>[io_uring_enter ()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code></strong> 系统调用进行单个调用。或者在<a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">轮询模式</a>下，甚至不需要调用。</p><p>当从用户空间读取或更新共享 ring 缓冲区时，需要注意一些事项，以确保在读取时看到最新的数据，<br>并在更新之后“刷新”或“同步”写操作，以便内核看到您的更新。这是因为 CPU 可以重新安排读写顺序，<br>编译器也可以。当读写操作发生在同一个 CPU 上时，这通常不是问题。但是在 <strong><code>io_uring</code></strong> 的情况下，<br>当一个共享缓冲区涉及到两个不同的上下文: 用户空间和内核，并且它们在上下文<br>切换之后可以在不同的 cpu 上运行。您需要确保从用户空间读取之前，先前的写操作是可见的。<br>或者，当您在 SQE 中填充细节并更新提交缓冲区的尾部时，您希望确保在更新环缓冲区尾部的写入之前，<br>对 SQE 成员进行的写入是有序的。如果这些写操作没有被排序，内核可能会看到尾部被更新，<br>但是当它读取 SQE 时，它可能无法在读取 SQE 时找到所需的所有数据。在轮询模式中，<br>内核正在查找对尾部的更改，这就成了一个真正的问题。<br>这都是因为 cpu 和编译器为了优化而对读写进行重新排序。</p><h2 id="读取完成队列条目"><a class="header-anchor" href="#读取完成队列条目">¶</a>读取完成队列条目</h2><p>一如既往，我们首先处理事情的完成方面，因为它比提交方面更简单。<br>这些解释甚至是必要的，因为我们需要讨论内存的顺序和我们需要如何处理它。<br>否则，我们只想看看如何处理环形缓冲区。对于完成事件，内核将 CQEs 添加到循环缓冲区并更新尾部，<br>而我们在用户空间中从头部读取。在任何环形缓冲区中，如果头部和尾部相等，则表示环形缓冲区为空。看看下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> head;</span><br><span class="line">head = cqring-&gt;head;</span><br><span class="line">read_barrier(); <span class="comment">/* 确保以前的写入可见 */</span></span><br><span class="line"><span class="keyword">if</span> (head != cqring-&gt;tail) &#123;</span><br><span class="line">    <span class="comment">/* 环形缓冲区中有可用的数据 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> index;</span><br><span class="line">    index = head &amp; (cqring-&gt;mask);</span><br><span class="line">    cqe = &amp;cqring-&gt;cqes[index];</span><br><span class="line">    <span class="comment">/* 在此处完成cqe过程 */</span></span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">/* 我们现在已经消耗了这一项 */</span></span><br><span class="line">    head++;</span><br><span class="line">&#125;</span><br><span class="line">cqring-&gt;head = head;</span><br><span class="line">write_barrier();</span><br></pre></td></tr></table></figure><p>为了得到头部的索引，应用程序需要使用环形缓冲区的大小掩码来掩码头部。请记住，<br>上面代码中的任何一行都可能在上下文切换之后运行。因此，在比较之前，<br>我们有一个 <strong><code>read_barrier()</code></strong> ，这样，如果内核确实更新了尾部，<br>我们可以在 if 语句中将其作为比较的一部分来读取。一旦我们获得了 CQE 并处理它，<br>我们就更新 head，让内核知道我们已经使用了来自 ring 缓冲区的条目。最后一个 **<code>write_barrier()</code>**确保我们的写操作可见，这样内核就可以知道它。</p><h2 id="提交-submission"><a class="header-anchor" href="#提交-submission">¶</a>提交 submission</h2><p>做一个提交和读取一个完成是相反的。在处理 completion 时，内核将条目添加到尾部，<br>我们从循环缓冲区的头部读取条目，当 submission 时，我们添加到尾部，内核从循环缓冲区的头部读取条目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> tail, index;</span><br><span class="line">tail = sqring-&gt;tail;</span><br><span class="line">index = tail &amp; (*sqring-&gt;ring_mask);</span><br><span class="line">sqe = &amp;sqring-&gt;sqes[index];</span><br><span class="line"><span class="comment">/* 此函数调用填写此IO请求的SQE详细信息 */</span></span><br><span class="line">app_init_io(sqe);</span><br><span class="line"><span class="comment">/* 将SQE索引填充到SQ环数组中 */</span></span><br><span class="line">sqring-&gt;<span class="built_in">array</span>[index] = index;</span><br><span class="line">tail++;</span><br><span class="line">write_barrier();</span><br><span class="line">sqring-&gt;tail = tail;</span><br><span class="line">write_barrier();</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，应用程序中的 <strong><code>app_init_io()</code></strong> 函数将填充提交请求的详细信息。在尾部更新之前，<br>我们有一个 <strong><code>write_barrier()</code></strong> 来确保前面的写操作是有序的。然后我们更新 tail 并再次调用 <strong><code>write_barrier()</code></strong> 以确保我们的更新被看到。我们在这里按照正确的顺序处理。</p><h2 id="源代码"><a class="header-anchor" href="#源代码">¶</a>源代码</h2><p>本文档中的代码和其他示例可以在这个 <a href="https://github.com/shuveb/loti-examples">Github</a> 存储库中找到。</p><h2 id="参考文档"><a class="header-anchor" href="#参考文档">¶</a>参考文档</h2><ul><li><a href="https://unixism.net/loti/low_level.html">The Low-level io_uring Interface</a></li><li><a href="https://kernel.dk/io_uring.pdf">Efficient IO with io_uring PDF</a></li><li><a href="https://github.com/axboe/liburing">Efficient IO with io_uring github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io_uring 是什么?</title>
      <link href="/jony.github.io/98b4e846459c/"/>
      <url>/jony.github.io/98b4e846459c/</url>
      
        <content type="html"><![CDATA[<p>io_uring 是一个新的 Linux 异步 I/O API，由 Facebook 的 Jens Axboe 创建。它的目的是提供一个不受当前<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>、<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>系列系统调用限制的API，我们在上一节讨论过。鉴于异步编程模型的用户首先是出于性能的考虑而选择它，因此，拥有一个性能开销非常低的API是有意义的。我们将在后面的章节中看到io_uring是如何实现这一点的。</p><h1>io_uring 接口</h1><p>io_uring这个名字的由来是由于该接口使用环形缓冲区作为内核与用户空间通信的主要接口。虽然涉及到系统调用，但它们被保持在最低限度。并且可以使用轮询模式来尽可能地减少系统调用的需要。</p><blockquote><h2 id="参阅"><a class="header-anchor" href="#参阅">¶</a>参阅</h2><ul><li><a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">提交队列轮询教程</a>与示例程序。</li></ul></blockquote><h3 id="心智模型"><a class="header-anchor" href="#心智模型">¶</a>心智模型</h3><p>为了使用 <code>io_uring</code> 构建异步处理I/O的程序，需要构建的心智模型，但是相当简单。</p><ul><li>有两个环形缓冲区，一个用于提交请求(提交队列或SQ)，另一个用于通知您这些请求已完成(完成队列或CQ)。</li><li>这些环形缓冲区在内核和用户空间之间共享。您可以使用 <code>[io_uring_setup()](https://unixism.net/loti/ref-iouring/io_uring_setup.html#c.io_uring_setup)</code> 设置这些缓冲区，然后通过2个<a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2)</a>调用将它们映射到用户空间。</li><li>你告诉 <code>io_uring</code> 你需要做什么(读或写文件，接受客户端连接，等等)，你把它描述为提交队列条目(SQE)的一部分，并把它添加到提交环缓冲区的尾部。</li><li>然后你通过 <code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code> 系统调用告诉内核你已经在提交队列环形缓冲区中添加了一个SQE。你也可以在进行系统调用之前添加多个SQE。</li><li>另外，<code>[io_uring_enter()](https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter)</code> 也可以在返回之前等待内核处理一些请求，这样你就知道可以从完成队列读取结果了。</li><li>内核处理提交的请求，并将完成队列事件（CQE）添加到完成队列环形缓冲区的尾部。</li><li>您从完成队列环形缓冲区的头部读取CQE。每个SQE对应一个CQE，它包含该特定请求的状态。</li><li>您可以根据需要继续添加SQE和获取CQE。</li><li>有一种<a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">轮询模式可用</a>，内核在该模式下轮询提交队列中的新条目。这避免了每次提交条目进行处理时调用<a href="https://unixism.net/loti/ref-iouring/io_uring_enter.html#c.io_uring_enter">io_uring_enter()</a>的系统调用开销。</li></ul><blockquote><h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3><ul><li><a href="https://unixism.net/loti/low_level.html#low-level">io_uring 底层接口</a></li></ul></blockquote><h1>io_uring 性能</h1><p>由于内核和用户空间之间共享环形缓冲区，因此io_uring可以是零拷贝系统。当涉及在内核和用户空间之间传输数据的系统调用时，需要复制字节。但是，由于io_uring中的大部分通信是通过内核和用户空间之间共享的缓冲区进行的，因此完全避免了这种巨大的性能开销。虽然系统调用(我们习惯于大量调用)可能看起来不是很大的开销，但在高性能应用程序中，大量调用将开始变得重要。此外，系统调用也不像以前那么便宜了。再加上操作系统为应对<a href="https://meltdownattack.com/">Specter和Meltdown</a>而采取的工作方法，我们谈论的不是微不足道的开销。因此，在高性能应用程序中，尽可能避免系统调用确实是一个很棒的想法。</p><p>在使用同步编程接口时，甚至在Linux下使用异步编程接口时，每个请求的提交都至少涉及一个系统调用。在 <code>io_uring</code> 中，您可以添加几个请求，只需添加多个sqe，每个sqe描述您想要的I/O操作，并对io_uring_enter进行一次调用。对于初学者来说，这就是一场胜利。但它会变得更好。</p><p>你可以让内核在你将SQEs添加到提交队列中时，进行轮询并提取它们进行处理，这样可以让你不用调用io_uring_enter()来告诉内核提取SQEs。对于高性能的应用，这意味着更少的系统调用开销。更多细节请参见<a href="https://unixism.net/loti/tutorial/sq_poll.html#sq-poll">提交队列轮询教程</a>。</p><p>通过巧妙地使用共享环形缓冲区，<code>io_uring</code> 的性能其实是受内存限制的，因为在轮询模式下，我们可以完全不使用系统调用。重要的是要记住，性能基准测试是一个相对的过程，需要有某种共同的参考点。根据<a href="https://kernel.dk/io_uring.pdf">io_uring的论文</a>，在一台参考机器上，在轮询模式下，io_uring管理着1.7M 4k IOPS的时钟，而<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>管理着608k。虽然远超过一倍，但这并不是一个公平的比较，因为 <a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a> 并不具备轮询模式。但即使禁用轮询模式，io_uring也达到了1.2M IOPS，接近于 <a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a> 的两倍。</p><p>为了检查 <code>io_uring</code> 接口的原始吞吐量，有一个no-op请求类型。有了这个类型，在参考机器上，<code>io_uring</code> 实现了每秒20M的消息量。更多细节请参见 <a href="https://unixism.net/loti/ref-liburing/submission.html#c.io_uring_prep_nop">io_uring_prep_nop()</a>。</p><h1>使用底层API的 Demo</h1><p>编写一个小程序来读取文件并将它们打印到控制台，就像Unix的 <code>cat</code> 实用程序一样，这可能是一个很好的起点，可以让你熟悉 <code>io_uring</code> API。请看下一章中的一个例子。</p><h1>只使用 liburing</h1><p>虽然熟悉低级别的 <code>io_uring</code> API肯定是件好事，但在实际的、严肃的程序中，你可能想使用liburing提供的更高级别的接口。像QEMU这样的程序已经在使用它了。如果 <code>liburing</code> 从来没有存在过，你就会在低级的IO接口上构建一些抽象层， <code>liburing</code> 为你做到了这一点，它也是一个经过深思熟虑的接口。简而言之，你可能应该花一些精力去了解底层的 <code>io_uring</code> 接口是如何工作的，但默认情况下，你应该在你的程序中真正使用 <code>liburing</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下异步编程</title>
      <link href="/jony.github.io/493f5652fc23/"/>
      <url>/jony.github.io/493f5652fc23/</url>
      
        <content type="html"><![CDATA[<p>我们生活在这样一个时代，我们使用的大多数应用程序都在云上运行。每当用户连接到基于云的应用程序时，通常编写在某种web框架之上的大多数业务逻辑都会运行。每个请求要么在单独的进程、单独的线程中处理，要么在异步程序中处理，多个请求在同一个进程中处理。今天，基于线程池和异步模型的应用程序框架同样流行。这些应用程序混合了对网络的调用和与文件相关的系统调用，以完成它们的工作。</p><h1>Processes</h1><p>通常，当您调用一个系统调用(如<a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>)时，您的程序会一直阻塞，直到文件被读取并且数据可用。这通常是相当快的，而且您通常没有意识到您的程序正在阻塞。但您可能也没有意识到，您的程序，特别是在繁忙的机器上，可能每秒数百次地从CPU切换到运行其他程序。当系统调用阻塞时，只要在内核模式下运行的系统调用返回并继续运行，您的程序就会解除阻塞。如果它像大多数其他程序一样，每当它需要操作系统的某些东西时，它就会继续这个阻塞和解锁的循环。这种范例很容易理解，因为事件按逻辑顺序一个接一个地发生-即使您的程序可能被抢占以运行其他程序，或者它可能被系统调用阻塞。如果您忽略了您的程序被抢占以运行其他程序这一事实，那么您的程序就好像是按顺序执行其逻辑一样。</p><h1>多线程程序</h1><p>在多线程程序中，这种心智模型可以很好地推断。在你的程序中，有许多执行线程。这些实例可以是相同逻辑的实例(为处理客户端请求而创建的线程的一个实例)，也可以是其他逻辑的实例(一个专门的线程总是在后台运行以清理临时文件)。这些单独的线程被系统调用抢占、阻塞和解除阻塞。有几个或几个在运行，当然这个心智模型也是相当可扩展的。但是，在多线程过程中仍然会遇到锁和互斥等复杂的东西。但为了我们的讨论，我们最好忽略它们。</p><h1>为什么是异步编程</h1><p>如果你要构建一些每小时处理数千甚至数十万个请求的东西，你不需要为异步I/O而烦恼。围绕着基于线程池架构设计的应用框架就能满足你的需求。但如果你想高效地处理每小时数百万次的请求，并且你很关心效率，你可能要更仔细地研究异步编程。异步编程通过在单线程中处理大部分的I/O，避免了操作系统的线程/进程上下文切换开销。操作系统的上下文切换开销看似不大，但当你要处理大量的规模和并发时，它就开始变得重要起来。</p><p>请看下图，它描述了一组请求在一秒钟内发生的事情。线程从阻塞到运行状态。虽然很清楚单线程和多线程应用程序中发生了什么，但异步编程的工作方式可能有点难以理解，尽管它不像造火箭那么难。我希望下图能帮助你理解。</p><p><img src="/jony.github.io/images/Linux_Process_Models.jpg" alt="阻塞到异步" title="阻塞到异步"></p><p>下面是用一个教育网站服务器运行实验的图表，功能上是一样的，但使用不同的Linux进程模型编写。下面是对每种架构名称的解释。</p><ul><li><strong>迭代<code>Iterative</code></strong> ：这种服务器类型为一个又一个请求提供服务。当它在服务一个请求时，其他可能到达的请求必须等待前一个请求处理完毕。操作系统排队的请求数量是有限制的。默认情况下，Linux在5.4以下的内核版本中最多排队128个，新版本中最多排队4,096个。</li><li><strong>Forking</strong> :这种类型的服务器为每个需要服务的请求创建一个新进程。这样，请求就不需要等待以前的请求处理完成。不同的进程处理不同的请求。此外，当有许多进程或线程在工作时，它们往往会利用多个可用的CPU内核。</li><li><strong>Preforked</strong>：这种类型的服务器避免了每次需要处理请求时必须创建一个全新进程的开销。它通过创建一个进程池来实现这一点，这些进程在请求传入时被分配。只有当池中的所有进程都繁忙时，传入的请求才应该等待轮到它们被处理。管理员通常能够根据他们通常遇到的负载来调整池中进程的数量。</li><li><strong>线程化<code>Threaded</code></strong>:这种类型的服务器在每次需要处理请求时都会生成一个新线程。线程与创建它的主进程共享大量数据，因此与创建新进程相比，在创建过程中产生的开销略低 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 。</li><li><strong>预线程<code>Prethreaded</code></strong>:这相当于预分叉架构的线程。在这种风格中，创建了一个线程池，并在收到请求时将池中的线程分配给它们。和预分叉模式一样，只有当所有线程都在忙于处理之前收到的请求时，请求才需要等待。这是一种非常高效的模式，也是大多数Web应用框架所遵循的模式。</li><li><strong>poll</strong>：这种类型的服务器是单线程的，使用<a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>系统调用在请求之间进行多路复用。然而 <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>是一个有严重限制的系统调用：当扩展到处理大量文件描述符时，它会产生性能问题。。从下面的图表中可以看出这一点。在这种设计中，每个请求的状态都会被跟踪，并进行一系列函数回调，将该请求的处理带到下一个阶段。</li><li><strong>epoll</strong>：这也是一种单线程的，服务器使用<a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列系统调用代替 <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a> ，但除此之外，架构上是一样的。</li></ul><p><img src="/jony.github.io/images/Linux_Performance_upto_1000_users.png" alt="Linux_Performance_upto_1000_users" title="Linux_Performance_upto_1000_users"><br><img src="/jony.github.io/images/Linux_Performance_more_than_1000_users.png" alt="Linux_Performance_more_than_1000_users" title="Linux_Performance_more_than_1000_users"><br><img src="/jony.github.io/images/Linux_Performance_upto_1000_users.png" alt="Linux_Performance_Fulll_Chart-1" title="Linux_Performance_Fulll_Chart-1"></p><p>正如您所看到的，Prethreaded 或基于线程池的Web服务器使基于<a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>的服务器在这个特定的基准测试中达到11,000个用户的并发性之前都是运行非常良好。这是大量的并发用户。只有非常流行的Web服务才会体验到这种并发性。这一点非常重要，因为就复杂性而言，与异步程序相比，基于线程池的程序更容易编码。这也意味着它们也更容易维护，因为它们本质上更容易理解。</p><p>阅读我的<a href="https://unixism.net/2019/04/linux-applications-performance-introduction/">系列文章</a>，深入了解你的应用可以使用的各种Linux进程模型。这是通过基于各种流程架构从头开始构建功能相同的Web服务器来实现的。</p><h1>简化异步编程</h1><p>当你构建一个异步架构的程序时，通常会使用一个高级库，让开发人员的工作更轻松。另一种选择是将你的程序分层，这样你可以在最低层处理异步Linux接口，而更高的层则提供一个更易于使用的接口，在此基础上构建功能。抽象这些低层操作系统接口的库的一个很好的例子是<a href="https://libevent.org/">libevent</a>和<a href="https://libuv.org/">libuv</a>，它们为<a href="https://nodejs.org/en/">NodeJS</a>提供支持。</p><p>除非您正在编写专门的应用程序(如Web框架或高性能网络服务)，否则通常不需要使用这些低级API进行编程。但如果你很好奇，想要了解系统程序是如何工作的，那你就来对地方了。在这个世界上，好奇心永远不会害死猫。很多时候，它会变成一只老虎。</p><p>像<a href="https://www.tornadoweb.org/">Tornado</a>和NodeJS这样的Web应用框架可以让你轻松地编写异步Web应用，并且拥有异步I/O性能优势。如果你正在编写一个Web服务或者<a href="https://www.electronjs.org/">桌面应用程序</a>，你可能想使用这些这些框架，因为它们允许你用高级语言编写你的业务逻辑，同时保留了很多性能优势。</p><h1>io_uring之前的Linux异步api</h1><p>我们看到，在同步编程的情况下，在<a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>的情况下，处理读写或远程连接的系统调用会分别被阻塞，直到数据读取、写入或客户端连接可用。在此之前，上述进程或线程都会被阻塞。如果你需要做其他事情怎么办？可以创建其他线程来处理这些其他任务。例如，主线程可能在<a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>时阻塞，这样新的客户端连接就会被立即处理，而其他线程可能正在处理来自前一个客户端的请求。但是，如果你需要保持活跃来接受客户端连接，同时也试图从客户端套接字中读取，同时也试图在一个线程中读取或写入本地文件呢？FTP服务器在服务(读)和接受(写)文件时，既要处理套接字，又要处理常规的文件描述符，这将是一个很好的例子。如何在一个线程或进程中完成这些工作？这就是<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>和<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列系统调用的作用。</p><p>这些系统调用允许您监视一组文件描述符(套接字也是文件描述符)，并在其中一个或多个准备就绪时通知您。举个例子，FTP服务器正在等待从几个已连接的客户端读取下一个命令，同时还在监听<a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>上是否有任何新的客户端请求。程序将告诉<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列系统调用监视这些文件描述符，并在其中一个或多个文件描述符上有任何活动时让程序知道。为此，与基于进程或线程专门处理每个请求的程序相比，您需要以非常不同的方式构建您的程序。</p><p>Linux的<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>系列系统调用可以异步处理文件和套接字。然而，你需要注意一些限制：</p><ul><li><a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>只支持用O_DIRECT打开的文件或在非缓冲模式下打开的文件。这无疑是它最大的限制。在通常情况下并非所有的应用程序都希望以无缓冲模式打开文件。</li><li>即使在无缓冲模式下，如果文件元数据不可用，io(7) 也会被阻塞。它将等待元数据可用</li><li>有些存储设备有固定数量的槽位用于请求。如果所有的槽都忙，<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>提交可能会阻塞。</li><li>提交和完成总共需要复制104个字节。此外，还需要对I/O进行两个不同的系统调用（提交和完成各一个）。</li></ul><p>上述限制在<a href="http://man7.org/linux/man-pages/man7/aio.7.html">aio(7)</a>子系统中引入了大量的不确定性和性能开销</p><h1>常规文件的问题</h1><p>在一个不是很忙的服务器上，读写一个文件可能不需要很长的时间。以上面使用异步设计编写的FTP服务器为例。当它真的很忙的时候，有很多并发用户同时下载和上传很多很大的文件，作为程序员，您需要了解一个问题。在这么繁忙的服务器上，调用 <a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>和<a href="http://man7.org/linux/man-pages/man2/write.2.html">write(2)</a>会开始大量阻塞。但是<a href="http://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或者<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>系列的系统调用对我们没有帮助吗？不幸的是没有。这些系统调用只是会告诉常规文件已经准备好进行 I/O。这是他们的致命弱点。我们不会去讨论为什么会这样，但重要的是要明白，虽然它们对套接字工作得很好，但它们只会为常规文件返回“就绪”。</p><p>不幸的是，这使得文件描述符在异步编程下是非统一的。支持常规文件的文件描述符会受到歧视。出于这个原因，像<code>libuv</code>这样的库为常规文件的I/O使用了一个单独的线程池，暴露了一个向用户隐藏这种差异的API。阅读这篇<a href="https://blog.libtorrent.org/2012/10/asynchronous-disk-io/">优秀的文章</a>，调查了各种操作系统上的异步I/O API。</p><h1>io_uring中存在这个问题吗</h1><p>没有。无论是处理套接字还是普通文件，io_uring都提供了一个统一的接口。另外，由于 API 的设计，程序可以直接获取读取或写入文件描述符的数据，而不是像 <a href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>或者<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7)</a>一样，知道文件描述符何时准备好，然后再开始对其进行 I/O 操作。这并不是 io_uring 与现有 Linux 异步 I/O API 相比的唯一优势。我们将在接下来的章节中讨论更多。</p><h2 id="脚注"><a class="header-anchor" href="#脚注">¶</a>脚注</h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>虽然在Linux下创建线程或进程都是通过clone(2)系统调用来完成的，并且产生的开销也是一样的，但就在创建之后，如果一个共享父进程地址空间的只读副本的子进程向其页面写入，内核就会为子进程创建父进程地址空间的副本，这是真正的开销。进程中的线程共享地址空间，因此不会产生这种复制开销。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
            <tag> 异步 </tag>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到 Lord of the io_uring</title>
      <link href="/jony.github.io/88c499707f04/"/>
      <url>/jony.github.io/88c499707f04/</url>
      
        <content type="html"><![CDATA[<p>io_uring是在Linux下进行异步I/O编程的一种强大的新方法。<code>io_uring</code> 消除了上一代I/O子系统的各种限制，拥有巨大的前景。关于io_uring带来的更多细节，请参阅“<a href="">什么是 <code>io_uring</code></a> ?”</p><p>这本IO指南是由Shuveb Hussain创建的，他也是专注于Linux的博客unixism.net的作者。</p><h1>Contributing</h1><p>本指南的源代码库在Github上。如果你想投稿，请发送我拉请求。如果你在文档或包含的源代码示例中发现任何错误，请在GitHub上提出问题。示例程序的存储库是分开维护的。请看下面的细节。</p><h1>源代码案例</h1><p>本指南中所有示例程序的源代码都可以在 Github 上找到。如果您在示例中发现了 bug，请在 Github 上提出问题。我想让这些例子简单明了。出于这个原因，我很多不会合并添加特性的拉请求。欢迎提出修复 bug 的请求。</p><h1>文档</h1><p>引言</p><ul><li><a href="/jony.github.io/493f5652fc23/">Linux 下的异步编程</a></li><li><a href="/jony.github.io/98b4e846459c/">什么是 io_uring？</a></li><li><a href="/jony.github.io/3d70b9e6d77f/"><code>io_uring</code> 的底层接口</a></li></ul><p>教程</p><ul><li><a href="/jony.github.io/33f4e488c2f3/">cat 使用 liburing 实现</a></li><li><a href="/jony.github.io/fbcd2bb270f6/">cp 使用 liburing 实现</a></li><li><a href="/jony.github.io/90d9c32a425c/">web 服务器使用 liburing 实现</a></li><li><a href="/jony.github.io/4aa7709cef2f/">探测支持功能</a></li><li><a href="/jony.github.io/6629bb792093/">请求链</a></li><li><a href="/jony.github.io/48d3d8aca367/">固定的缓冲区</a></li><li><a href="/jony.github.io/973aa4b46332/">轮询提交队列</a></li><li><a href="/jony.github.io/304bb0ffee1d/">注册一个eventfd</a></li></ul><p>liburing 参考资料</p><ul><li><a href="/jony.github.io/1f47a91ce33a/">SQE: 提交队列条目</a></li><li><a href="/jony.github.io/201d74132273/">CQE: 完成队列事件</a></li><li>支持的功能</li><li>安装和卸载</li><li>提交</li><li>完成</li><li>高级使用</li></ul><p>io_uring 参考资料</p><ul><li>io_uring_setup</li><li>io_uring_enter</li><li>io_uring_register</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lord of the io_uring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io_uring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
