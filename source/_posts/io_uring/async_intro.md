---
title: Linux 下异步编程
date: 2021-02-07 09:05:38
categories: ["Lord of the io_uring"]
tags:
  - io_uring
  - 异步
  - 理论

---

我们生活在这样一个时代，我们使用的大多数应用程序都在云上运行。每当用户连接到基于云的应用程序时，通常编写在某种web框架之上的大多数业务逻辑都会运行。每个请求要么在单独的进程、单独的线程中处理，要么在异步程序中处理，多个请求在同一个进程中处理。今天，基于线程池和异步模型的应用程序框架同样流行。这些应用程序混合了对网络的调用和与文件相关的系统调用，以完成它们的工作。

# Processes

通常，当您调用一个系统调用(如[read(2)](http://man7.org/linux/man-pages/man2/read.2.html))时，您的程序会一直阻塞，直到文件被读取并且数据可用。这通常是相当快的，而且您通常没有意识到您的程序正在阻塞。但您可能也没有意识到，您的程序，特别是在繁忙的机器上，可能每秒数百次地从CPU切换到运行其他程序。当系统调用阻塞时，只要在内核模式下运行的系统调用返回并继续运行，您的程序就会解除阻塞。如果它像大多数其他程序一样，每当它需要操作系统的某些东西时，它就会继续这个阻塞和解锁的循环。这种范例很容易理解，因为事件按逻辑顺序一个接一个地发生-即使您的程序可能被抢占以运行其他程序，或者它可能被系统调用阻塞。如果您忽略了您的程序被抢占以运行其他程序这一事实，那么您的程序就好像是按顺序执行其逻辑一样。

# 多线程程序

在多线程程序中，这种心智模型可以很好地推断。在你的程序中，有许多执行线程。这些实例可以是相同逻辑的实例(为处理客户端请求而创建的线程的一个实例)，也可以是其他逻辑的实例(一个专门的线程总是在后台运行以清理临时文件)。这些单独的线程被系统调用抢占、阻塞和解除阻塞。有几个或几个在运行，当然这个心智模型也是相当可扩展的。但是，在多线程过程中仍然会遇到锁和互斥等复杂的东西。但为了我们的讨论，我们最好忽略它们。

# 为什么是异步编程

如果你要构建一些每小时处理数千甚至数十万个请求的东西，你不需要为异步I/O而烦恼。围绕着基于线程池架构设计的应用框架就能满足你的需求。但如果你想高效地处理每小时数百万次的请求，并且你很关心效率，你可能要更仔细地研究异步编程。异步编程通过在单线程中处理大部分的I/O，避免了操作系统的线程/进程上下文切换开销。操作系统的上下文切换开销看似不大，但当你要处理大量的规模和并发时，它就开始变得重要起来。

请看下图，它描述了一组请求在一秒钟内发生的事情。线程从阻塞到运行状态。虽然很清楚单线程和多线程应用程序中发生了什么，但异步编程的工作方式可能有点难以理解，尽管它不像造火箭那么难。我希望下图能帮助你理解。

![阻塞到异步](/jony.github.io/images/Linux_Process_Models.jpg "阻塞到异步")


下面是用一个教育网站服务器运行实验的图表，功能上是一样的，但使用不同的Linux进程模型编写。下面是对每种架构名称的解释。

- **迭代``Iterative``** ：这种服务器类型为一个又一个请求提供服务。当它在服务一个请求时，其他可能到达的请求必须等待前一个请求处理完毕。操作系统排队的请求数量是有限制的。默认情况下，Linux在5.4以下的内核版本中最多排队128个，新版本中最多排队4,096个。
- **Forking** :这种类型的服务器为每个需要服务的请求创建一个新进程。这样，请求就不需要等待以前的请求处理完成。不同的进程处理不同的请求。此外，当有许多进程或线程在工作时，它们往往会利用多个可用的CPU内核。
- **Preforked**：这种类型的服务器避免了每次需要处理请求时必须创建一个全新进程的开销。它通过创建一个进程池来实现这一点，这些进程在请求传入时被分配。只有当池中的所有进程都繁忙时，传入的请求才应该等待轮到它们被处理。管理员通常能够根据他们通常遇到的负载来调整池中进程的数量。
- **线程化``Threaded``**:这种类型的服务器在每次需要处理请求时都会生成一个新线程。线程与创建它的主进程共享大量数据，因此与创建新进程相比，在创建过程中产生的开销略低 [^1] 。
- **预线程``Prethreaded``**:这相当于预分叉架构的线程。在这种风格中，创建了一个线程池，并在收到请求时将池中的线程分配给它们。和预分叉模式一样，只有当所有线程都在忙于处理之前收到的请求时，请求才需要等待。这是一种非常高效的模式，也是大多数Web应用框架所遵循的模式。
- **poll**：这种类型的服务器是单线程的，使用[poll(2)](https://man7.org/linux/man-pages/man2/poll.2.html)系统调用在请求之间进行多路复用。然而 [poll(2)](https://man7.org/linux/man-pages/man2/poll.2.html)是一个有严重限制的系统调用：当扩展到处理大量文件描述符时，它会产生性能问题。。从下面的图表中可以看出这一点。在这种设计中，每个请求的状态都会被跟踪，并进行一系列函数回调，将该请求的处理带到下一个阶段。
- **epoll**：这也是一种单线程的，服务器使用[epoll(7)](https://man7.org/linux/man-pages/man7/epoll.7.html)系列系统调用代替 [poll(2)](https://man7.org/linux/man-pages/man2/poll.2.html) ，但除此之外，架构上是一样的。

![Linux_Performance_upto_1000_users](/jony.github.io/images/Linux_Performance_upto_1000_users.png "Linux_Performance_upto_1000_users")
![Linux_Performance_more_than_1000_users](/jony.github.io/images/Linux_Performance_more_than_1000_users.png "Linux_Performance_more_than_1000_users")
![Linux_Performance_Fulll_Chart-1](/jony.github.io/images/Linux_Performance_upto_1000_users.png "Linux_Performance_Fulll_Chart-1")

正如您所看到的，Prethreaded 或基于线程池的Web服务器使基于[epoll(7)](https://man7.org/linux/man-pages/man7/epoll.7.html)的服务器在这个特定的基准测试中达到11,000个用户的并发性之前都是运行非常良好。这是大量的并发用户。只有非常流行的Web服务才会体验到这种并发性。这一点非常重要，因为就复杂性而言，与异步程序相比，基于线程池的程序更容易编码。这也意味着它们也更容易维护，因为它们本质上更容易理解。

阅读我的[系列文章](https://unixism.net/2019/04/linux-applications-performance-introduction/)，深入了解你的应用可以使用的各种Linux进程模型。这是通过基于各种流程架构从头开始构建功能相同的Web服务器来实现的。

# 简化异步编程

当你构建一个异步架构的程序时，通常会使用一个高级库，让开发人员的工作更轻松。另一种选择是将你的程序分层，这样你可以在最低层处理异步Linux接口，而更高的层则提供一个更易于使用的接口，在此基础上构建功能。抽象这些低层操作系统接口的库的一个很好的例子是[libevent](https://libevent.org/)和[libuv](https://libuv.org/)，它们为[NodeJS](https://nodejs.org/en/)提供支持。

除非您正在编写专门的应用程序(如Web框架或高性能网络服务)，否则通常不需要使用这些低级API进行编程。但如果你很好奇，想要了解系统程序是如何工作的，那你就来对地方了。在这个世界上，好奇心永远不会害死猫。很多时候，它会变成一只老虎。

像[Tornado](https://www.tornadoweb.org/)和NodeJS这样的Web应用框架可以让你轻松地编写异步Web应用，并且拥有异步I/O性能优势。如果你正在编写一个Web服务或者[桌面应用程序](https://www.electronjs.org/)，你可能想使用这些这些框架，因为它们允许你用高级语言编写你的业务逻辑，同时保留了很多性能优势。

# io_uring之前的Linux异步api

我们看到，在同步编程的情况下，在[accept(2)](http://man7.org/linux/man-pages/man2/accept.2.html)的情况下，处理读写或远程连接的系统调用会分别被阻塞，直到数据读取、写入或客户端连接可用。在此之前，上述进程或线程都会被阻塞。如果你需要做其他事情怎么办？可以创建其他线程来处理这些其他任务。例如，主线程可能在[accept(2)](http://man7.org/linux/man-pages/man2/accept.2.html)时阻塞，这样新的客户端连接就会被立即处理，而其他线程可能正在处理来自前一个客户端的请求。但是，如果你需要保持活跃来接受客户端连接，同时也试图从客户端套接字中读取，同时也试图在一个线程中读取或写入本地文件呢？FTP服务器在服务(读)和接受(写)文件时，既要处理套接字，又要处理常规的文件描述符，这将是一个很好的例子。如何在一个线程或进程中完成这些工作？这就是[select(2)](http://man7.org/linux/man-pages/man2/select.2.html)、[poll(2)](http://man7.org/linux/man-pages/man2/poll.2.html)和[epoll(7)](http://man7.org/linux/man-pages/man7/epoll.7.html)系列系统调用的作用。

这些系统调用允许您监视一组文件描述符(套接字也是文件描述符)，并在其中一个或多个准备就绪时通知您。举个例子，FTP服务器正在等待从几个已连接的客户端读取下一个命令，同时还在监听[accept(2)](http://man7.org/linux/man-pages/man2/accept.2.html)上是否有任何新的客户端请求。程序将告诉[select(2)](http://man7.org/linux/man-pages/man2/select.2.html)、[poll(2)](http://man7.org/linux/man-pages/man2/poll.2.html)或[epoll(7)](http://man7.org/linux/man-pages/man7/epoll.7.html)系列系统调用监视这些文件描述符，并在其中一个或多个文件描述符上有任何活动时让程序知道。为此，与基于进程或线程专门处理每个请求的程序相比，您需要以非常不同的方式构建您的程序。

Linux的[aio(7)](http://man7.org/linux/man-pages/man7/aio.7.html)系列系统调用可以异步处理文件和套接字。然而，你需要注意一些限制：

- [aio(7)](http://man7.org/linux/man-pages/man7/aio.7.html)只支持用O_DIRECT打开的文件或在非缓冲模式下打开的文件。这无疑是它最大的限制。在通常情况下并非所有的应用程序都希望以无缓冲模式打开文件。
- 即使在无缓冲模式下，如果文件元数据不可用，io(7) 也会被阻塞。它将等待元数据可用
- 有些存储设备有固定数量的槽位用于请求。如果所有的槽都忙，[aio(7)](http://man7.org/linux/man-pages/man7/aio.7.html)提交可能会阻塞。
- 提交和完成总共需要复制104个字节。此外，还需要对I/O进行两个不同的系统调用（提交和完成各一个）。

上述限制在[aio(7)](http://man7.org/linux/man-pages/man7/aio.7.html)子系统中引入了大量的不确定性和性能开销

# 常规文件的问题

在一个不是很忙的服务器上，读写一个文件可能不需要很长的时间。以上面使用异步设计编写的FTP服务器为例。当它真的很忙的时候，有很多并发用户同时下载和上传很多很大的文件，作为程序员，您需要了解一个问题。在这么繁忙的服务器上，调用 [read(2)](http://man7.org/linux/man-pages/man2/read.2.html)和[write(2)](http://man7.org/linux/man-pages/man2/write.2.html)会开始大量阻塞。但是[select(2)](http://man7.org/linux/man-pages/man2/select.2.html)、[poll(2)](http://man7.org/linux/man-pages/man2/poll.2.html)或者[epoll(7)](http://man7.org/linux/man-pages/man7/epoll.7.html)系列的系统调用对我们没有帮助吗？不幸的是没有。这些系统调用只是会告诉常规文件已经准备好进行 I/O。这是他们的致命弱点。我们不会去讨论为什么会这样，但重要的是要明白，虽然它们对套接字工作得很好，但它们只会为常规文件返回“就绪”。

不幸的是，这使得文件描述符在异步编程下是非统一的。支持常规文件的文件描述符会受到歧视。出于这个原因，像``libuv``这样的库为常规文件的I/O使用了一个单独的线程池，暴露了一个向用户隐藏这种差异的API。阅读这篇[优秀的文章](https://blog.libtorrent.org/2012/10/asynchronous-disk-io/)，调查了各种操作系统上的异步I/O API。

# io_uring中存在这个问题吗

没有。无论是处理套接字还是普通文件，io_uring都提供了一个统一的接口。另外，由于 API 的设计，程序可以直接获取读取或写入文件描述符的数据，而不是像 [poll(2)](http://man7.org/linux/man-pages/man2/poll.2.html)或者[epoll(7)](http://man7.org/linux/man-pages/man7/epoll.7.html)一样，知道文件描述符何时准备好，然后再开始对其进行 I/O 操作。这并不是 io_uring 与现有 Linux 异步 I/O API 相比的唯一优势。我们将在接下来的章节中讨论更多。


## 脚注
[^1]: 虽然在Linux下创建线程或进程都是通过clone(2)系统调用来完成的，并且产生的开销也是一样的，但就在创建之后，如果一个共享父进程地址空间的只读副本的子进程向其页面写入，内核就会为子进程创建父进程地址空间的副本，这是真正的开销。进程中的线程共享地址空间，因此不会产生这种复制开销。

